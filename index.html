<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwaF Tandem Matcher v2.0</title>
    <!-- Leaflet CSS f√ºr Karten -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <style>
        /* SwaF Farbpalette basierend auf der Styleguide */
        :root {
            --swaf-red: #C3003B;
            --swaf-teal: #009892;
            --swaf-black: #000000;
            --swaf-light-gray: #F5F5F5;
            --swaf-dark-gray: #555555;
            --swaf-lightest-red: #FFE6ED;
            --swaf-light-red: #FF99B5;
            --swaf-lightest-teal: #E6FFFD;
            --swaf-light-teal: #99FFFA;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--swaf-light-gray);
            color: var(--swaf-black);
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, var(--swaf-red), var(--swaf-teal));
            color: white;
            padding: 1rem 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .header p {
            opacity: 0.9;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .tabs {
            display: flex;
            background: white;
            border-radius: 8px 8px 0 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        .tab {
            padding: 1rem 1.5rem;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: var(--swaf-dark-gray);
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .tab:hover {
            background-color: var(--swaf-lightest-teal);
            color: var(--swaf-teal);
        }

        .tab.active {
            background-color: var(--swaf-teal);
            color: white;
            border-bottom-color: var(--swaf-red);
        }

        .tab-content {
            background: white;
            border-radius: 0 0 8px 8px;
            padding: 2rem;
            min-height: 600px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--swaf-teal);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--swaf-teal);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--swaf-red);
            color: white;
        }

        .btn-primary:hover {
            background-color: #a30030;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: var(--swaf-teal);
            color: white;
        }

        .btn-secondary:hover {
            background-color: #007a75;
            transform: translateY(-2px);
        }

        .btn-outline {
            background-color: transparent;
            color: var(--swaf-teal);
            border: 2px solid var(--swaf-teal);
        }

        .btn-outline:hover {
            background-color: var(--swaf-teal);
            color: white;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }

        .grid {
            display: grid;
            gap: 1rem;
        }

        .grid-2 {
            grid-template-columns: 1fr 1fr;
        }

        .grid-3 {
            grid-template-columns: 1fr 1fr 1fr;
        }

        .card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid var(--swaf-teal);
        }

        .card h3 {
            color: var(--swaf-red);
            margin-bottom: 1rem;
        }

        .progress {
            width: 100%;
            height: 8px;
            background-color: #ddd;
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--swaf-teal), var(--swaf-red));
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Floating Template Panel */
        .floating-templates {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 2px solid var(--swaf-teal);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 5000;
            transition: all 0.3s ease;
            display: none;
        }

        .floating-templates.visible {
            display: block;
            animation: slideInRight 0.3s ease-out;
        }

        .floating-templates.collapsed {
            width: 40px;
            height: 40px;
            padding: 0.5rem;
            overflow: hidden;
            cursor: pointer;
        }

        .floating-templates h4 {
            color: var(--swaf-teal);
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
        }

        .floating-template-btn {
            display: block;
            width: 100%;
            margin: 0.2rem 0;
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--swaf-teal);
            background: white;
            color: var(--swaf-teal);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            text-align: left;
            transition: all 0.2s ease;
        }

        .floating-template-btn:hover {
            background: var(--swaf-lightest-teal);
            transform: translateX(-2px);
        }

        /* Quick-Action Buttons f√ºr schnelleres Arbeiten */
        .quick-actions {
            position: fixed;
            bottom: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 1000;
        }

        .quick-action-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .quick-action-btn:hover {
            transform: scale(1.1);
        }

        .quick-action-btn.quick-save {
            background: var(--swaf-teal);
        }

        .quick-action-btn.quick-common {
            background: var(--swaf-red);
        }

        .quick-action-btn.quick-clear {
            background: #ff6b6b;
        }

        /* Keyboard Shortcuts Info */
        .keyboard-shortcuts {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 2000;
        }

        .keyboard-shortcuts.visible {
            opacity: 1;
        }

        /* Auto-Complete Dropdown */
        .auto-complete {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--swaf-teal);
            border-top: none;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .auto-complete-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .auto-complete-item:hover,
        .auto-complete-item.selected {
            background: var(--swaf-lightest-teal);
        }

        .auto-complete-item:last-child {
            border-bottom: none;
        }

        /* Bulk Edit Mode */
        .bulk-edit-mode .tandem-table td[contenteditable] {
            background: var(--swaf-lightest-red) !important;
            border: 2px dashed var(--swaf-red) !important;
        }

        .bulk-edit-toolbar {
            position: fixed;
            top: 100px;
            right: 20px;
            background: white;
            border: 2px solid var(--swaf-red);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 2000;
            display: none;
        }

        .bulk-edit-toolbar.visible {
            display: block;
        }

        .floating-template-btn.priority {
            background: var(--swaf-lightest-red);
            border-color: var(--swaf-red);
            color: var(--swaf-red);
            font-weight: bold;
        }

        .floating-template-btn.priority:hover {
            background: var(--swaf-red);
            color: white;
        }

        .template-category {
            border-top: 1px solid #eee;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
        }

        .template-category:first-child {
            border-top: none;
            margin-top: 0;
            padding-top: 0;
        }

        .template-category-title {
            font-size: 0.7rem;
            font-weight: bold;
            color: var(--swaf-dark-gray);
            margin-bottom: 0.3rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .floating-templates-toggle {
            position: fixed;
            right: 20px;
            top: 200px;
            width: 50px;
            height: 50px;
            background: var(--swaf-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 5001;
            transition: all 0.3s ease;
        }

        .floating-templates-toggle:hover {
            background: var(--swaf-red);
            transform: scale(1.1);
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateY(-50%) translateX(20px);
            }

            to {
                opacity: 1;
                transform: translateY(-50%) translateX(0);
            }
        }

        @media (max-width: 768px) {
            .floating-templates {
                position: fixed;
                right: 10px;
                bottom: 80px;
                top: auto;
                transform: none;
                max-width: 250px;
                max-height: 250px;
            }

            .floating-templates-toggle {
                right: 10px;
                top: auto;
                bottom: 150px;
            }
        }

        .alert {
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            border-left: 4px solid;
        }

        .alert-info {
            background-color: var(--swaf-lightest-teal);
            border-color: var(--swaf-teal);
            color: var(--swaf-teal);
        }

        .alert-success {
            background-color: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .alert-warning {
            background-color: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }

        .alert-error {
            background-color: var(--swaf-lightest-red);
            border-color: var(--swaf-red);
            color: var(--swaf-red);
        }

        .profiles-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        .profile-item {
            padding: 1rem;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .profile-item:hover {
            border-color: var(--swaf-teal);
            transform: translateY(-2px);
        }

        .profile-item.selected {
            border-color: var(--swaf-red);
            background-color: var(--swaf-lightest-red);
            box-shadow: 0 4px 12px rgba(195, 0, 59, 0.3);
        }

        .matched-pair.selected {
            background-color: var(--swaf-lightest-teal);
            border-left: 4px solid var(--swaf-teal);
        }

        .matched-pairs {
            list-style: none;
            background: white;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }

        .matched-pair {
            padding: 1rem;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .matched-pair:last-child {
            border-bottom: none;
        }

        .matched-pair:hover {
            background-color: var(--swaf-lightest-teal);
        }

        .tandem-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .tandem-table th,
        .tandem-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .tandem-table th {
            background-color: var(--swaf-teal);
            color: white;
            font-weight: 600;
        }

        .tandem-table tr:hover {
            background-color: var(--swaf-lightest-teal);
        }

        .tandem-table td {
            vertical-align: top;
            max-width: 300px;
            word-wrap: break-word;
        }

        .bookmarklet-box {
            background: #f8f9fa;
            border: 2px dashed var(--swaf-teal);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            text-align: center;
        }

        .bookmarklet {
            background: var(--swaf-red);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            text-decoration: none;
            font-weight: 600;
            display: inline-block;
            margin: 0.5rem;
            user-select: all;
            cursor: pointer;
        }

        .status-bar {
            background: var(--swaf-dark-gray);
            color: white;
            padding: 0.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .template-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .hidden {
            display: none !important;
        }

        /* Rich Text Editor */
        .rich-text-editor {
            border: 2px solid #ddd;
            border-radius: 4px;
            min-height: 200px;
            padding: 1rem;
            background: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.5;
            outline: none;
        }

        .rich-text-editor:focus {
            border-color: var(--swaf-teal);
        }

        .rich-text-toolbar {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            flex-wrap: wrap;
        }

        .rich-text-btn {
            padding: 0.3rem 0.6rem;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
            min-width: 30px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .rich-text-btn:hover {
            background: var(--swaf-lightest-teal);
            border-color: var(--swaf-teal);
        }

        .rich-text-btn.active {
            background: var(--swaf-teal);
            color: white;
            border-color: var(--swaf-teal);
        }

        .email-template-section {
            background: white;
            border: 2px solid var(--swaf-teal);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .email-preview {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.5;
        }

        .email-preview h3 {
            color: var(--swaf-red);
            margin-top: 0;
        }

        .email-subject-line {
            background: var(--swaf-lightest-teal);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            border-left: 4px solid var(--swaf-teal);
        }

        .tandem-link-placeholder {
            background: var(--swaf-lightest-red);
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
            border-left: 4px solid var(--swaf-red);
            font-style: italic;
        }

        @keyframes pulse {
            0% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.05);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }

        .profile-detected {
            animation: highlight 1s ease-in-out;
        }

        @keyframes highlight {
            0% {
                background: var(--swaf-lightest-teal);
            }

            50% {
                background: var(--swaf-light-teal);
            }

            100% {
                background: var(--swaf-lightest-teal);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .grid-2 {
                grid-template-columns: 1fr;
            }

            .profiles-list {
                grid-template-columns: 1fr;
            }

            .tabs {
                flex-wrap: wrap;
            }
        }

        .contextual-category-section {
            transition: all 0.3s ease;
        }

        .contextual-category-section:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .contextual-category-section table {
            font-size: 0.9rem;
        }

        .contextual-category-section table th {
            font-weight: 600;
            text-align: center;
        }

        .contextual-category-section table td {
            vertical-align: top;
        }

        .contextual-category-section textarea {
            resize: vertical;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .contextual-category-section textarea:focus {
            outline: none;
            border-color: var(--swaf-teal);
            box-shadow: 0 0 0 2px rgba(0, 152, 146, 0.2);
        }

        .template-priority-checkbox {
            transform: scale(1.2);
            margin-bottom: 0.3rem;
        }

        .contextual-templates-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        @media (max-width: 768px) {
            .contextual-templates-grid {
                grid-template-columns: 1fr;
            }

            .contextual-category-section table {
                font-size: 0.8rem;
            }

            .contextual-category-section textarea {
                min-height: 40px;
            }
        }

        /* Logo-Stil */
        .logo {
            width: 60px;
            height: 30px;
            background: var(--swaf-red);
            color: white;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 4px;
            margin-right: 1rem;
        }

        /* Floating Action Button f√ºr Schnellzugriff */
        .fab {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 60px;
            height: 60px;
            background: var(--swaf-red);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .fab:hover {
            transform: scale(1.1);
            background: #a30030;
        }

        /* Vereinfachtes Bookmarklet-Display */
        .simple-bookmarklet {
            background: var(--swaf-red);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            display: inline-block;
            margin: 1rem;
            user-select: all;
            cursor: grab;
        }

        .simple-bookmarklet:active {
            cursor: grabbing;
        }

        /* Polite Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--swaf-teal);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Auto-Complete f√ºr intelligentes Texting */
        .smart-input {
            position: relative;
        }

        .smart-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--swaf-teal);
            border-top: none;
            max-height: 150px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .smart-suggestion {
            padding: 0.5rem;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
        }

        .smart-suggestion:hover,
        .smart-suggestion.selected {
            background: var(--swaf-lightest-teal);
        }

        .smart-suggestion:last-child {
            border-bottom: none;
        }

        .smart-suggestion .suggestion-text {
            font-weight: bold;
            color: var(--swaf-teal);
        }

        /* Ausklappbare Profile */
        .profile-details {
            display: none;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 2px solid var(--swaf-lightest-teal);
            max-height: 300px;
            overflow-y: auto;
        }

        .profile-details.expanded {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 300px;
            }
        }

        .profile-details-content {
            font-size: 0.85rem;
        }

        .profile-field-item {
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--swaf-lightest-teal);
        }

        .profile-field-item:last-child {
            border-bottom: none;
        }

        .profile-field-question {
            font-weight: 600;
            color: var(--swaf-teal);
            margin-bottom: 0.2rem;
        }

        .profile-field-answer {
            color: var(--swaf-dark-gray);
        }

        .expand-toggle {
            display: inline-block;
            cursor: pointer;
            color: var(--swaf-teal);
            font-size: 0.9rem;
            margin-top: 0.5rem;
            padding: 0.3rem 0.6rem;
            border-radius: 3px;
            background: var(--swaf-lightest-teal);
            transition: all 0.2s;
        }

        .expand-toggle:hover {
            background: var(--swaf-teal);
            color: white;
        }

        .smart-suggestion .suggestion-context {
            font-size: 0.8rem;
            color: var(--swaf-dark-gray);
            margin-top: 0.2rem;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1><span class="logo">SwaF</span>Tandem Vorschl√§ge</h1>
        <p>Start with a Friend - Tandem-Vorschl√§ge intelligent erstellen</p>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab(0)">1. Profile sammeln</button>
            <button class="tab" onclick="switchTab(1)">2. Tandems matchen</button>
            <button class="tab" onclick="switchTab(2)">3. Felder ausw√§hlen</button>
            <button class="tab" onclick="switchTab(3)">4. Bearbeitung</button>
            <button class="tab" onclick="switchTab(4)">5. Verwaltung</button>
        </div>

        <div class="tab-content">
            <!-- Tab 1: Profile sammeln -->
            <div class="tab-panel active" id="tab-0">
                <h2>üîÑ Profile automatisch sammeln</h2>

                <div class="alert alert-info">
                    <strong>üéØ Einfachste Methode:</strong> Verwende das vereinfachte Bookmarklet f√ºr schnelles und
                    zuverl√§ssiges Sammeln von Profildaten!
                </div>

                <!-- Zwischenablage-Einstellungen -->
                <div style="background: var(--swaf-lightest-red); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600;">
                        <input type="checkbox" id="auto-clipboard-detection" onchange="toggleAutoClipboardDetection()" checked
                            style="margin-right: 0.5rem; transform: scale(1.2);">
                        <span>üîÑ Automatische Zwischenablage-Erkennung (empfohlen)</span>
                    </label>
                    <p style="margin: 0.5rem 0 0 1.7rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                        <strong>Deaktivieren bei h√§ufigen Browser-Berechtigungsanfragen.</strong><br>
                        Danach manuell "üìã Aus Zwischenablage einf√ºgen" verwenden.
                    </p>
                </div>

                <!-- Vereinfachte Bookmarklet-Sektion -->
                <div class="card">
                    <h3>üìå Schritt 1: Bookmarklet installieren</h3>

                    <!-- Checkbox f√ºr Bookmarklet-Status -->
                    <div
                        style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600;">
                            <input type="checkbox" id="bookmarklet-installed" onchange="toggleBookmarkletStatus()"
                                style="margin-right: 0.5rem; transform: scale(1.2);">
                            <span>‚úÖ Bookmarklet (Lesezeichen) schon abgespeichert?</span>
                        </label>
                    </div>

                    <div id="bookmarklet-install-section">
                        <div style="text-align: center; margin: 2rem 0;">
                            <p style="margin-bottom: 1rem;">Ziehe diesen Button in deine Lesezeichen-Leiste:</p>

                            <a href="javascript:(function(){try{var d={url:location.href,name:'',fields:[],pageType:'',timestamp:Date.now()};function clearData(){localStorage.removeItem('swaf_batch_profiles');alert('‚úÖ Alle Daten wurden gel√∂scht.');}function createClearButton(){if(document.getElementById('swafClearBtn'))return;var b=document.createElement('button');b.id='swafClearBtn';b.textContent='üßπ Daten l√∂schen';Object.assign(b.style,{position:'fixed',top:'10px',right:'10px',zIndex:999999,background:'#c00',color:'#fff',border:'none',padding:'8px 12px',borderRadius:'6px',cursor:'pointer',fontSize:'14px'});b.onclick=clearData;document.body.appendChild(b);}function collectData(){if(document.querySelector('.js_question-wrapper')){d.pageType='Interview';var h=document.querySelector('h1')||document.querySelector('.breadcrumb-item.active');d.name=h?(h.textContent||'').trim():'Interview_'+Date.now();document.querySelectorAll('.js_question-wrapper').forEach(function(w){var qEl=w.querySelector('h2 span.text-break')||w.querySelector('h2');if(!qEl)return;var q=qEl.textContent.trim();var ans=[];w.querySelectorAll('input[type=checkbox]:checked,input[type=radio]:checked').forEach(function(inp){var sp=inp.nextElementSibling;if(sp&&sp.tagName==='SPAN'){ans.push(sp.textContent.trim());}else{var parent=inp.closest('label');if(parent)ans.push(parent.textContent.trim());}});w.querySelectorAll('option[selected]').forEach(function(opt){var txt=opt.textContent.trim();if(txt&&!txt.startsWith('--')&&txt!=='Bitte w√§hlen'&&txt!=='Ausw√§hlen'){ans.push(txt);}});w.querySelectorAll('textarea').forEach(function(ta){if(ta.disabled||ta.offsetHeight===0||ta.offsetWidth===0)return;var c=ta.textContent.trim()||ta.value.trim();if(c&&c.length>0)ans.push(c);});w.querySelectorAll('input[type=text],input[type=email],input[type=number]').forEach(function(inp){var v=inp.value.trim();if(v&&v.length>0)ans.push(v);});var answer=ans.filter(function(a){return a&&a.length>0;}).join(', ');if(q&&answer)d.fields.push({question:q,answer:answer});});}else{d.pageType='Hauptprofil';var nameEl=document.querySelector('span[name=name]')||document.querySelector('.o_field_char')||document.querySelector('h1');if(nameEl)d.name=(nameEl.textContent||nameEl.innerText||'').trim();if(!d.name)d.name='Profil_'+Date.now();document.querySelectorAll('span.o_field_widget,div.o_field_widget,a.o_field_widget').forEach(function(field){var labels=document.querySelectorAll('label.o_form_label');var matched=null;for(var i=0;i<labels.length;i++){var label=labels[i];var fRect=field.getBoundingClientRect();var lRect=label.getBoundingClientRect();if(Math.abs(lRect.top-fRect.top)<10&&lRect.left<fRect.left){if(!matched||Math.abs(lRect.left-fRect.left)<Math.abs(matched.getBoundingClientRect().left-fRect.left)){matched=label;}}}if(matched){var q=matched.textContent.trim().replace(':','');var a=field.textContent.trim();if(q&&a&&a.length>0&&!a.includes('o_field')&&a!=='false'&&a!=='true'&&q!==a)d.fields.push({question:q,answer:a});}});document.querySelectorAll('.tab-pane').forEach(function(pane){pane.querySelectorAll('tr').forEach(function(row){var label=row.querySelector('label.o_form_label');var field=row.querySelector('span.o_field_widget,div.o_field_widget,a.o_field_widget');if(label&&field&&!field.classList.contains('o_field_empty')){var q=label.textContent.trim().replace(':','');var a=field.textContent.trim();if(q&&a&&a.length>0&&!a.includes('o_field')&&a!=='false'&&a!=='true'&&q!==a){var exists=d.fields.some(function(f){return f.question===q;});if(!exists)d.fields.push({question:q,answer:a});}}});});}var stored=localStorage.getItem('swaf_batch_profiles');var arr=[];if(stored){try{var parsed=JSON.parse(stored);arr=Array.isArray(parsed)?parsed:(parsed.profiles||[]);}catch(e){arr=[];}}arr.push(d);localStorage.setItem('swaf_batch_profiles',JSON.stringify(arr));var clipText='';arr.forEach(function(p){clipText+='SWAF_PROFILE_START'+JSON.stringify(p)+'SWAF_PROFILE_END\n';});if(navigator.clipboard&&navigator.clipboard.writeText){navigator.clipboard.writeText(clipText).then(function(){alert('Profil '+arr.length+' gesammelt!\n\nAlle '+arr.length+' Profile in Zwischenablage!\n\nJetzt zur App wechseln und STRG+V dr√ºcken.');}).catch(function(){alert('Profil '+arr.length+' gesammelt!\n\nZur App wechseln und STRG+V dr√ºcken.');});}else{alert('Profil '+arr.length+' gesammelt!\n\nZur App wechseln und STRG+V dr√ºcken.');}}createClearButton();collectData();}catch(e){alert('Fehler: '+e.message);}})();" class="simple-bookmarklet" draggable="true">
                                üìã SwaF Sammler (Batch)
                            </a>

                            <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                                <strong>Funktioniert nicht?</strong> Rechtsklick auf den Button ‚Üí "Link speichern unter"
                                ‚Üí Als Lesezeichen speichern
                            </p>
                        </div>

                        <div
                            style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                            <h4>üöÄ Einfacher Workflow:</h4>
                            <ol style="margin-left: 1rem; margin-top: 0.5rem;">
                                <li><strong>Einzelne Profile:</strong> Einfach das Bookmarklet klicken ‚Üí zur App
                                    wechseln ‚Üí automatisch erkannt</li>
                                <li><strong>Mehrere Profile:</strong> F√ºr jedes Profil das Bookmarklet verwenden</li>
                            </ol>
                        </div>
                    </div>

                    <div style="background: #fff3cd; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <h4>üí° Automatische Erkennung:</h4>
                        <p>Die App erkennt automatisch SwaF-Profildaten in der Zwischenablage. Du kannst auch manuell
                            einf√ºgen:</p>
                        <button class="btn btn-secondary" onclick="pasteFromClipboard()" style="margin-top: 0.5rem;">
                            üìã Aus Zwischenablage einf√ºgen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="clearClipboard()" style="background: #ff6b6b; color: white;">
                            üóëÔ∏è Zwischenablage leeren
                        </button>
                    </div>
                </div>

                <!-- Status und gesammelte Profile -->
                <div class="card">
                    <h3>üìä Gesammelte Profile</h3>

                    <div class="progress">
                        <div class="progress-bar" id="download-progress" style="width: 0%"></div>
                    </div>

                    <div id="profile-status" style="margin: 1rem 0; font-weight: 600;">
                        Bereit zum Sammeln ‚Ä¢ Aktuell: <span id="profile-count">0</span> Profile
                    </div>

                    <div id="collected-profiles-display"></div>

                    <!-- Aktionsbuttons -->
                    <div style="margin-top: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="switchTab(1)" id="continue-btn" style="display: none;">
                            ‚û°Ô∏è Weiter zum Matching (<span id="profile-count-btn">0</span> Profile)
                        </button>
                        <button class="btn btn-secondary" onclick="addTestProfile()">
                            üß™ Test-Profil hinzuf√ºgen
                        </button>
                        <button class="btn btn-outline" onclick="showManualInput()">
                            ‚úèÔ∏è Profil manuell eingeben
                        </button>
                        <button class="btn btn-outline" onclick="clearAllProfiles()">
                            üóëÔ∏è Alle Profile l√∂schen
                        </button>
                    </div>
                </div>

                <!-- Profile-Merge Tool -->
                <div class="card">
                    <h3>üîÑ Profile zusammenf√ºhren</h3>
                    <p style="margin-bottom: 1rem;">F√ºhre zwei Profile derselben Person manuell zusammen:</p>

                    <div class="grid grid-2" style="margin-bottom: 1rem;">
                        <div class="form-group">
                            <label>Erstes Profil:</label>
                            <select id="merge-profile-1" style="width: 100%;">
                                <option value="">-- Profil ausw√§hlen --</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Zweites Profil:</label>
                            <select id="merge-profile-2" style="width: 100%;">
                                <option value="">-- Profil ausw√§hlen --</option>
                            </select>
                        </div>
                    </div>

                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="manualMergeProfiles()">üîÑ Profile zusammenf√ºhren</button>
                        <button class="btn btn-outline" onclick="updateMergeProfileLists()">üîÑ Listen aktualisieren</button>
                        <button class="btn btn-outline" onclick="showMergePreview()">üëÄ Vorschau anzeigen</button>
                    </div>
                </div>

                <!-- Debug-Sektion -->
                <div class="card" id="debug-help-section" style="display: none;">
                    <h3>üîß Debug & Hilfe</h3>
                    <p style="margin-bottom: 1rem;">Falls etwas nicht funktioniert:</p>

                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-outline btn-small" onclick="checkClipboardForProfileData()">
                            üìã Zwischenablage pr√ºfen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="pasteFromClipboard()">
                            üì• Manuell einf√ºgen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="clearClipboard()" style="background: #ff6b6b; color: white;">
                            üóëÔ∏è Zwischenablage leeren
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testClipboardFormat()">
                            üß™ Clipboard-Format testen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="transferBatchToClipboard()">
                            üìã Batch √ºbertragen (Strg+V bereit machen)
                        </button>
                        <button class="btn btn-primary btn-small" onclick="transferBatchToClipboard()">
                            üìã Batch ‚Üí Zwischenablage
                        </button>

                        <button class="btn btn-outline btn-small" onclick="cleanupBatchStorage()" style="background: #ff9800; color: white;">
                            üßπ Storage bereinigen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="showBatchStatus()">
                            üìä Batch-Status
                        </button>

                        <button class="btn btn-outline btn-small" onclick="resetBatch()" style="background: #ff6b6b; color: white;">
                            üóëÔ∏è Batch leeren
                        </button>
                        <button class="btn btn-outline btn-small" onclick="showDebugInfo()">
                            üìä Debug-Info anzeigen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testLocalStorage()">
                            üíæ localStorage testen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testPLZDistance()">
                            üìç PLZ-Distanz testen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testDataCleaning()">
                            üßπ Datenbereinigung testen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="showInstructions()">
                            ‚ùì Detaillierte Anleitung
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testPLZDistanceAPI()">
                            üåê PLZ-Distanz API testen
                        </button>
                        <button class="btn btn-primary btn-small" onclick="testAdvancedPLZFeatures()">
                            üó∫Ô∏è Erweiterte PLZ-Features testen
                        </button>
                        <button class="btn btn-secondary btn-small" onclick="interactivePLZTest()">
                            üìç Interaktive PLZ-Distanz
                        </button>
                        <button class="btn btn-outline btn-small" onclick="debugRoutingCache()">
                            üíæ Routing-Cache pr√ºfen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="clearRoutingCache()">
                            üóëÔ∏è Cache leeren
                        </button>
                        <button class="btn btn-outline btn-small" onclick="debugQuestionSimilarity()">üîç Fragen-Duplikate finden</button>
                        <button class="btn btn-primary btn-small" onclick="analyzeCurrentData()">üìä Daten analysieren</button>
                        <button class="btn btn-secondary btn-small" onclick="createDataBackup()">üíæ Backup erstellen</button>
                        <button class="btn btn-primary" onclick="migrateExistingProfiles()" style="background: var(--swaf-red); margin-top: 1rem;">üîÑ R√ºckwirkende Bereinigung</button>
                        <button class="btn btn-secondary btn-small" onclick="testIntelligentMatching()">üß™ Intelligente Matching Tests</button>
                        <button class="btn btn-outline btn-small" onclick="testNameExtraction()">üë§ Namen-Extraktion testen</button>
                        <button class="btn btn-outline btn-small" onclick="debugModalSystem()">üîß Modal System testen</button>
                    </div>
                </div>

                <div class="card" id="plz-distance-section" style="display: none;">
                    <h3>üìç PLZ-Distanzberechnung</h3>
                    <p style="margin-bottom: 1rem;">Die App berechnet automatisch Entfernungen zwischen Postleitzahlen
                        und zeigt diese in den Gemeinsamkeiten an.</p>

                    <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px;">
                        <h4>üéØ Entfernungs-Kategorien:</h4>
                        <ul style="margin: 0.5rem 0 0 1rem; font-size: 0.9rem;">
                            <li><strong>Gleiche PLZ:</strong> Identische Postleitzahl</li>
                            <li><strong>Sehr nah (‚â§ 10 km):</strong> Fu√ül√§ufig/Fahrrad erreichbar</li>
                            <li><strong>Nah (‚â§ 25 km):</strong> √ñffentliche Verkehrsmittel</li>
                            <li><strong>Mittlere Entfernung (‚â§ 50 km):</strong> Regionale Verbindung</li>
                            <li><strong>Gr√∂√üere Entfernung (‚â§ 100 km):</strong> Bundesweit erreichbar</li>
                        </ul>
                        <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                            <strong>Hinweis:</strong> Entfernungen √ºber 100 km werden nicht als Gemeinsamkeit angezeigt.
                        </p>
                    </div>
                </div>
                
                <div class="card" id="auto-cleanup-section" style="display: none;">
                    <h3>üßπ Automatische Datenbereinigung</h3>
                    <!-- Admin Toggle (Doppelklick auf Logo aktiviert versteckte Bereiche) -->
                    <script>
                        let logoClickCount = 0;
                        document.addEventListener('DOMContentLoaded', function() {
                            const logo = document.querySelector('.logo');
                            if (logo) {
                                logo.addEventListener('dblclick', function() {
                                    logoClickCount++;
                                    if (logoClickCount >= 2) {
                                        document.getElementById('debug-help-section').style.display = 'block';
                                        document.getElementById('plz-distance-section').style.display = 'block';
                                        document.getElementById('auto-cleanup-section').style.display = 'block';
                                        showNotification('üîì Admin-Bereiche eingeblendet', 'success');
                                        logoClickCount = 0;
                                    }
                                });
                            }
                        });
                    </script>
                    <p style="margin-bottom: 1rem;">Die App bereinigt automatisch st√∂rende Formulierungen aus den
                        Profildaten.</p>

                    <div style="background: var(--swaf-lightest-red); padding: 1rem; border-radius: 4px;">
                        <h4>‚ùå Automatisch entfernte Formulierungen:</h4>
                        <div
                            style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin: 0.5rem 0; font-size: 0.9rem;">
                            <div>
                                <strong>Standardformulierungen:</strong>
                                <ul style="margin: 0.3rem 0 0 1rem;">
                                    <li>"-- Hier kannst du etwas ausw√§hlen --"</li>
                                    <li>"Keine Auswahl"</li>
                                    <li>"Bitte ausw√§hlen"</li>
                                </ul>
                            </div>
                            <div>
                                <strong>Sonstiges-Eintr√§ge:</strong>
                                <ul style="margin: 0.3rem 0 0 1rem;">
                                    <li>"sonstiges:," / "Anderer Grund:,"</li>
                                    <li>"anderes:,"</li>
                                    <li>"Etwas anderes (bitte genauer beschreiben)"</li>
                                </ul>
                            </div>
                        </div>
                        <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                            <strong>Ergebnis:</strong> Nur relevante, aussagekr√§ftige Inhalte bleiben erhalten.
                        </p>
                    </div>

                    <div
                        style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin-top: 1rem;">
                        <h4>‚úÖ Bereinigung erfolgt automatisch beim:</h4>
                        <ul style="margin: 0.5rem 0 0 1rem; font-size: 0.9rem;">
                            <li><strong>Profil-Import:</strong> Alle neuen Profile werden sofort bereinigt</li>
                            <li><strong>Daten-Kombination:</strong> Beim Zusammenf√ºhren mehrerer Profile</li>
                            <li><strong>Export:</strong> Ausgabedaten sind automatisch sauber</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Tab 2: Tandems matchen -->
            <div class="tab-panel" id="tab-1">
                <!-- Gamification Panel -->
                <div id="gamification-panel" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 2rem; flex-wrap: wrap;">
                        <!-- Progress Section -->
                        <div style="flex: 1; min-width: 250px;">
                            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem;">üìä Dein Fortschritt</h3>
                            <div style="background: rgba(255,255,255,0.2); border-radius: 20px; height: 30px; overflow: hidden; margin-bottom: 0.5rem;">
                                <div id="progress-bar" style="background: linear-gradient(90deg, #FFB000, #FF6B6B); height: 100%; width: 0%; transition: width 0.5s ease; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.85rem;">
                                    0%
                                </div>
                            </div>
                            <div id="progress-text" style="font-size: 0.9rem; opacity: 0.95;">0 von 0 Profilen gematcht</div>

                            <!-- Stats -->
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 0.75rem; margin-top: 1rem;">
                                <div style="background: rgba(255,255,255,0.15); padding: 0.75rem; border-radius: 6px; text-align: center;">
                                    <div style="font-size: 1.5rem; font-weight: bold;" id="stat-today">0</div>
                                    <div style="font-size: 0.75rem; opacity: 0.9;">Heute</div>
                                </div>
                                <div style="background: rgba(255,255,255,0.15); padding: 0.75rem; border-radius: 6px; text-align: center;">
                                    <div style="font-size: 1.5rem; font-weight: bold;" id="stat-streak">0</div>
                                    <div style="font-size: 0.75rem; opacity: 0.9;">Streak üî•</div>
                                </div>
                                <div style="background: rgba(255,255,255,0.15); padding: 0.75rem; border-radius: 6px; text-align: center;">
                                    <div style="font-size: 1.5rem; font-weight: bold;" id="stat-quality">-</div>
                                    <div style="font-size: 0.75rem; opacity: 0.9;">√ò Qualit√§t</div>
                                </div>
                            </div>
                        </div>

                        <!-- Achievements Section -->
                        <div style="flex: 1; min-width: 250px;">
                            <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem;">üèÜ Achievements</h3>
                            <div id="achievements-container" style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                <!-- Achievements werden hier eingef√ºgt -->
                            </div>

                            <!-- Undo Button -->
                            <div style="margin-top: 1rem;">
                                <button id="undo-button" class="btn btn-outline" onclick="undoLastMatch()" disabled
                                    style="background: rgba(255,255,255,0.2); border: 2px solid white; color: white; width: 100%; opacity: 0.5;">
                                    ‚Ü©Ô∏è Letztes Tandem r√ºckg√§ngig (5s)
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <h2>ü§ù Profile zu Tandems matchen</h2>

                <div class="alert alert-info">
                    <strong>Anleitung:</strong> W√§hle genau 2 Profile aus (durch Anklicken) und erstelle dann ein
                    Tandem.
                    Der Auto-Match analysiert automatisch Gemeinsamkeiten.
                </div>

                <!-- Smart Match Vorschl√§ge -->
                <div id="smart-match-panel" style="background: #f0f9ff; border: 2px solid #0ea5e9; border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; display: none;">
                    <h3 style="margin: 0 0 1rem 0; color: #0c4a6e; font-size: 1rem;">ü§ñ Smart Match Vorschl√§ge</h3>
                    <div id="smart-match-suggestions" style="display: flex; flex-direction: column; gap: 0.75rem;">
                        <!-- Vorschl√§ge werden hier eingef√ºgt -->
                    </div>
                </div>

                <div class="grid grid-2">
                    <div class="card">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h3>Verf√ºgbare Profile</h3>
                            <button class="btn btn-outline btn-small" onclick="loadAvailableProfiles()">üîÑ
                                Aktualisieren</button>
                        </div>
                        <!-- Ansichtsumschalter -->
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; border-bottom: 2px solid var(--swaf-lightest-teal); padding-bottom: 0.5rem;">
                            <button class="btn btn-outline btn-small" id="list-view-btn" onclick="switchProfileView('list')" style="flex: 1; background: var(--swaf-teal); color: white;">
                                üìã Listenansicht
                            </button>
                            <button class="btn btn-outline btn-small" id="map-view-btn" onclick="switchProfileView('map')" style="flex: 1;">
                                üó∫Ô∏è Kartenansicht
                            </button>
                            <button class="btn btn-primary btn-small" onclick="openFullScreenMap()" style="flex: 1;">
                                üñ•Ô∏è Full-Screen Karte
                            </button>
                        </div>
                        <div class="form-group">
                            <div style="display: flex; gap: 0.5rem; align-items: stretch;">
                                <input type="text" id="profile-search" placeholder="Profile durchsuchen (z.B. 'Studium', 'Fu√üball', 'Kochen')..."
                                    onkeyup="filterProfiles()" style="flex: 1;">
                                <select id="search-scope" onchange="filterProfiles()" style="min-width: 180px;" title="Suchbereich festlegen">
                                    <option value="all">üîç Alle Felder</option>
                                    <option value="name">üë§ Nur Name</option>
                                    <option value="specific">üìã Bestimmtes Feld...</option>
                                </select>
                            </div>
                            <div id="specific-field-container" style="display: none; margin-top: 0.5rem;">
                                <select id="specific-field-select" onchange="filterProfiles()" style="width: 100%;">
                                    <option value="">-- Feld ausw√§hlen --</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <select id="filter-gender" onchange="filterProfiles()" style="flex: 1; min-width: 150px;">
                                <option value="">Alle Geschlechter</option>
                                <option value="weiblich">Weiblich</option>
                                <option value="m√§nnlich">M√§nnlich</option>
                                <option value="divers">Divers</option>
                                <option value="keine angabe">Keine Angabe</option>
                            </select>

                            <select id="filter-gruppe" onchange="filterProfiles()" style="flex: 1; min-width: 150px;">
                                <option value="">Alle Gruppen</option>
                                <option value="local">Locals</option>
                                <option value="einwander">Eingewanderte</option>
                            </select>

                            <input type="number" id="filter-age-min" placeholder="Alter von"
                                onchange="filterProfiles()" style="flex: 1; min-width: 100px;" min="0" max="120">

                            <input type="number" id="filter-age-max" placeholder="Alter bis"
                                onchange="filterProfiles()" style="flex: 1; min-width: 100px;" min="0" max="120">

                            <button class="btn btn-outline btn-small" onclick="clearFilters()"
                                style="white-space: nowrap;">üîÑ Filter zur√ºcksetzen</button>
                        </div>
                        <div id="matching-status"
                            style="margin: 0.5rem 0; padding: 0.5rem; background: var(--swaf-lightest-teal); border-radius: 4px; text-align: center; font-weight: 600;">
                            0 von 2 Profilen ausgew√§hlt
                        </div>
                
                        <!-- Listenansicht -->
                        <div class="profiles-list" id="available-profiles" style="display: block;">
                            <p style="text-align: center; padding: 2rem;">Lade Profile...</p>
                        </div>
                
                        <!-- Kartenansicht -->
                        <div id="map-view-container" style="display: none;">
                            <div id="profile-map" style="height: 500px; border-radius: 8px; margin-bottom: 1rem;"></div>
                            
                            <!-- Farb-Legende -->
                            <div style="display: flex; gap: 1rem; margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; font-size: 0.9rem;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <div style="width: 20px; height: 20px; border-radius: 50%; background: #FFB000; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                                    <span><strong>Locals</strong></span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <div style="width: 20px; height: 20px; border-radius: 50%; background: #009892; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                                    <span><strong>Einwanderer*innen</strong></span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <div style="width: 20px; height: 20px; border-radius: 50%; background: #C30045; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                                    <span><strong>Ausgew√§hlt</strong></span>
                                </div>
                            </div>
                            
                            <div class="alert alert-info" style="font-size: 0.9rem;">
                                <strong>üí° Tipp:</strong> Klicke auf die Markierungen um Profile anzuzeigen und auszuw√§hlen. Profile mit derselben PLZ werden im Umkreis von ~500m verteilt dargestellt, damit sie nicht √ºbereinander liegen.
                            </div>
                        </div>

                        <div style="margin-top: 1rem;">
                            <button class="btn btn-secondary" onclick="matchSelectedProfiles()" id="match-btn" disabled>
                                ü§ù Ausgew√§hlte Profile matchen
                            </button>
                            <button class="btn btn-outline btn-small" onclick="suggestAutoMatches()">
                                üéØ Auto-Match vorschlagen
                            </button>
                            <button class="btn btn-outline btn-small" onclick="clearProfileSelection()">
                                üóëÔ∏è Auswahl l√∂schen
                            </button>
                            <button class="btn btn-outline btn-small" onclick="debugMatchingState()">
                                üîç Debug Matching
                            </button>
                            <button class="btn btn-outline btn-small" onclick="fixProfileSelection()">
                                üîß IDs reparieren
                            </button>
                            <button class="btn btn-outline btn-small" onclick="exportProfilesToExcel()">
                                üìä Profile als Excel exportieren
                            </button>
                        </div>
                    </div>

                    <div class="card">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h3>Gematchte Tandems</h3>
                            <span id="tandem-count"
                                style="background: var(--swaf-red); color: white; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.9rem;">0</span>
                        </div>

                        <ul class="matched-pairs" id="matched-pairs">
                            <li
                                style="padding: 1rem; text-align: center; color: var(--swaf-dark-gray); font-style: italic;">
                                Noch keine Tandems erstellt.
                            </li>
                        </ul>

                        <div style="margin-top: 1rem;">
                            <button class="btn btn-outline" onclick="removeSelectedPair()" id="remove-pair-btn"
                                disabled>
                                üóëÔ∏è Ausgew√§hltes Paar entfernen
                            </button>
                            <button class="btn btn-outline" onclick="clearAllTandems()">
                                üóëÔ∏è Alle Tandems l√∂schen
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tab 3: Felder ausw√§hlen -->
            <div class="tab-panel" id="tab-2">
                <h2>‚öôÔ∏è Felder f√ºr die Ausgabe ausw√§hlen</h2>

                <div class="card">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3>Verf√ºgbare Felder</h3>
                        <div>
                            <button class="btn btn-outline btn-small" onclick="selectAllFields(true)">Alle
                                ausw√§hlen</button>
                            <button class="btn btn-outline btn-small" onclick="selectAllFields(false)">Alle
                                abw√§hlen</button>
                        </div>
                    </div>

                    <div id="field-selection" class="grid grid-2"></div>
                </div>

                <div class="alert alert-info">
                    <strong>üí° Wichtig:</strong> W√§hle die Felder aus, die in der Tandem-√úbersicht in <strong>Schritt 4</strong> erscheinen sollen.
                    Nur ausgew√§hlte Felder werden in der Tandem-Gegen√ºberstellung angezeigt.
                    <br><br>
                    <strong>Tipp:</strong> Nach √Ñnderungen hier wechsle zu Schritt 4 und lade das Tandem neu.
                </div>
            </div>
            
            <!-- Tab 4: Bearbeitung & E-Mail-Template -->
            <div class="tab-panel" id="tab-3">
                <h2>üìß E-Mail-Tandem-Vorschl√§ge erstellen</h2>

                <!-- E-Mail Template Sektion -->
                <div class="email-template-section">
                    <h3>üìù E-Mail-Vorlage bearbeiten</h3>

                    <div class="grid grid-2" style="margin-bottom: 1.5rem;">
                        <div class="form-group">
                            <label>E-Mail Betreff:</label>
                            <input type="text" id="email-subject"
                                value="ü§ù Euer Tandem-Vorschlag von Start with a Friend" style="width: 100%;">
                        </div>
                        <div class="form-group">
                            <label>Tandem-Link Platzhalter:</label>
                            <input type="text" id="tandem-link" value="[HIER TANDEM-LINK EINF√úGEN]" style="width: 100%;"
                                placeholder="z.B. https://portal.startwithafriend.de/tandem/123">
                        </div>
                    </div>

                    <div class="form-group">
                        <label>E-Mail-Einleitung (mit Formatierung):</label>
                        <div class="rich-text-toolbar">
                            <button class="rich-text-btn" onclick="formatText('bold')" title="Fett"><b>B</b></button>
                            <button class="rich-text-btn" onclick="formatText('italic')"
                                title="Kursiv"><i>I</i></button>
                            <button class="rich-text-btn" onclick="formatText('underline')"
                                title="Unterstreichen"><u>U</u></button>
                            <span style="border-left: 1px solid #ddd; margin: 0 0.5rem;"></span>
                            <button class="rich-text-btn" onclick="insertText('üòä')" title="Smiley">üòä</button>
                            <button class="rich-text-btn" onclick="insertText('ü§ù')" title="Handshake">ü§ù</button>
                            <button class="rich-text-btn" onclick="insertText('‚ú®')" title="Sparkles">‚ú®</button>
                            <span style="border-left: 1px solid #ddd; margin: 0 0.5rem;"></span>
                            <button class="rich-text-btn" onclick="insertPlaceholder('[NAME1]')"
                                title="Name Person 1">[NAME1]</button>
                            <button class="rich-text-btn" onclick="insertPlaceholder('[NAME2]')"
                                title="Name Person 2">[NAME2]</button>
                            <span style="border-left: 1px solid #ddd; margin: 0 0.5rem;"></span>
                            <button class="rich-text-btn" onclick="resetEmailTemplate()"
                                title="Zur√ºcksetzen">üîÑ</button>
                        </div>
                        <div id="email-intro-editor" class="rich-text-editor" contenteditable="true">
                            Hi <strong>[NAME1]</strong> und <strong>[NAME2]</strong>,<br><br>

                            hier ist ein Tandemvorschlag f√ºr euch üòä Lest euch das gerne einmal durch ‚Äì ich finde,
                            <strong>ihr habt einige Gemeinsamkeiten und Interessen</strong>. Lest euch die Tabelle gerne
                            durch.<br><br>

                            <strong>Ihr findet:</strong> Eure Angaben, die Angaben der anderen Person, meine
                            Einsch√§tzung.<br><br>

                            <em>Auch wenn es auf den ersten Blick nicht zu 100% passt, probiert es vielleicht aus.</em>
                            Nat√ºrlich nur, wenn ihr Lust drauf habt. Wenn nicht, ist das auch okay.<br><br>

                            Unter der Tabelle findet ihr einen Link. <strong>Bitte dr√ºckt hier drauf.</strong> Dann
                            k√∂nnt ihr sagen, ob ihr das Tandem annehmen oder ablehnen wollt üòä<br><br>

                            <strong>Wichtig:</strong> Wenn ihr das Tandem ablehnt schreibt mir bitte die Gr√ºnde
                            auf.<br><br>

                            Ich freue mich √ºber eure R√ºckmeldung!<br><br>

                            <strong>Eure Gemeinsamkeiten und Profile im √úberblick</strong>
                        </div>
                    </div>

                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 1rem;">
                        <button class="btn btn-secondary" onclick="saveEmailTemplate()">üíæ Vorlage speichern</button>
                        <button class="btn btn-outline" onclick="loadEmailTemplate()">üì• Vorlage laden</button>
                        <button class="btn btn-outline" onclick="previewEmail()">üëÄ E-Mail-Vorschau</button>
                    </div>
                </div>

                <!-- Tandem Auswahl -->
                <div class="card">
                    <h3>Tandem ausw√§hlen</h3>
                    <select id="tandem-selector" onchange="loadTandemForEditing()" style="font-size: 1.1rem; padding: 0.75rem; min-height: 50px; font-weight: 600;">
                        <option value="">-- Tandem ausw√§hlen --</option>
                    </select>

                    <div class="card" style="margin-bottom: 1.5rem;">
                        <h3>üìù Textbausteine f√ºr Gemeinsamkeiten</h3>

                        <div
                            style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                            <h4>üí° Zwei Arten von Formulierungsvorschl√§gen:</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                                <div
                                    style="background: white; padding: 1rem; border-radius: 4px; border: 2px solid var(--swaf-teal);">
                                    <h5 style="color: var(--swaf-teal); margin-top: 0;">üéØ Fragespezifische Vorschl√§ge
                                    </h5>
                                    <p style="font-size: 0.9rem; margin: 0.5rem 0;">Automatisch passende Vorschl√§ge je
                                        nach Frage (Alter, Hobbys, PLZ, etc.)</p>
                                    <button class="btn btn-primary" onclick="editContextualTemplates()"
                                        style="width: 100%;">
                                        ‚öôÔ∏è Fragespezifische Templates verwalten
                                    </button>
                                </div>
                                <div
                                    style="background: white; padding: 1rem; border-radius: 4px; border: 2px solid var(--swaf-red);">
                                    <h5 style="color: var(--swaf-red); margin-top: 0;">üìã Allgemeine Vorschl√§ge</h5>
                                    <p style="font-size: 0.9rem; margin: 0.5rem 0;">Universelle Formulierungen f√ºr alle
                                        Situationen</p>
                                    <button class="btn btn-secondary" onclick="editPredefinedTemplates()"
                                        style="width: 100%;">
                                        ‚úèÔ∏è Allgemeine Templates bearbeiten
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div
                            style="background: var(--swaf-lightest-red); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                            <h4>üéØ Bearbeitungs-Tipps:</h4>
                            <ul style="margin: 0.5rem 0 0 1rem; font-size: 0.9rem;">
                                <li><strong>Doppelklick auf Textbausteine</strong> um sie in ausgew√§hlte Zellen
                                    einzuf√ºgen</li>
                                <li><strong>Gemeinsamkeiten-Spalte:</strong> Hier kannst du individuelle Texte f√ºr das
                                    Matching schreiben</li>
                                <li><strong>Floating Templates:</strong> Klick in eine Gemeinsamkeiten-Zelle f√ºr
                                    passende Vorschl√§ge</li>
                            </ul>
                        </div>
                    </div>

                    <div id="tandem-editor" class="hidden" style="margin-top: 1rem;">
                        <div
                            style="background: var(--swaf-lightest-red); padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">
                            <h4>üéØ Bearbeitungs-Tipps:</h4>
                            <ul style="margin: 0.5rem 0 0 1rem; font-size: 0.9rem;">
                                <li><strong>Doppelklick auf Textbausteine</strong> um sie in ausgew√§hlte Zellen
                                    einzuf√ºgen</li>
                                <li><strong>Gemeinsamkeiten-Spalte:</strong> Hier kannst du individuelle Texte f√ºr das
                                    Matching schreiben</li>
                                <li><strong>Floating Templates:</strong> Klick in eine Gemeinsamkeiten-Zelle f√ºr
                                    passende Vorschl√§ge</li>
                            </ul>
                        </div>

                        <table class="tandem-table" id="tandem-table">
                            <thead>
                                <tr>
                                    <th>Frage</th>
                                    <th>Antwort Person 1</th>
                                    <th>Antwort Person 2</th>
                                    <th>Gemeinsamkeiten</th>
                                    <th>Aktionen</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>

                        <div style="margin-top: 1rem;">
                            <button class="btn btn-secondary" onclick="saveTandem()">üíæ Tandem speichern</button>
                            <button class="btn btn-primary" onclick="generateCompleteEmail()">üìß Komplette E-Mail
                                erstellen</button>
                            <button class="btn btn-outline" onclick="copyTandemToClipboard()">üìã Nur Tabelle
                                kopieren</button>
                            <button class="btn btn-outline" onclick="recomputeCommonalities()">üîÑ Gemeinsamkeiten neu
                                berechnen</button>
                            <button class="btn btn-secondary" onclick="updatePLZDistancesOnly()">üó∫Ô∏è Distanz berechnen</button>
                            <button class="btn btn-secondary" onclick="generateSmartTextsLocally()" title="Generiert intelligente Texte basierend auf den Antworten">üß† Intelligente Texte</button>
                            <button class="btn btn-primary" onclick="testAdvancedPLZFeatures()" title="Teste erweiterte PLZ-Funktionen mit echten Routen">üó∫Ô∏è PLZ-Features testen</button>                                
                        </div>
                    </div>
                </div>

                <!-- E-Mail Vorschau -->
                <div id="email-preview-section" class="email-template-section hidden">
                    <h3>üìß E-Mail-Vorschau</h3>
                    <div id="email-preview-content" class="email-preview">
                        <!-- Wird dynamisch gef√ºllt -->
                    </div>
                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                        <button class="btn btn-primary" onclick="copyCompleteEmailToClipboard()">üìã Komplette E-Mail
                            kopieren</button>
                        <button class="btn btn-secondary" onclick="downloadEmailAsHTML()">üì• Als HTML-Datei
                            speichern</button>
                        <button class="btn btn-outline" onclick="hideEmailPreview()">‚ùå Vorschau schlie√üen</button>
                    </div>
                </div>
            </div>

            <!-- Tab 5: Verwaltung -->
            <div class="tab-panel" id="tab-4">
                <h2>üóÇÔ∏è Daten und Vorschl√§ge verwalten</h2>

                <div class="grid grid-2">
                    <div class="card">
                        <h3>Gespeicherte Tandems</h3>
                        <div id="saved-tandems-list" style="max-height: 300px; overflow-y: auto;"></div>
                        <div style="margin-top: 1rem;">
                            <button class="btn btn-outline" onclick="loadSavedTandems()">üîÑ Tandems laden</button>
                            <button class="btn btn-outline" onclick="exportAllTandems()">üì§ Alle exportieren</button>
                        </div>
                    </div>

                    <div class="card">
                        <h3>ü§ñ KI-Prompt Einstellungen</h3>
                        <p style="margin-bottom: 1rem;">Passe den Prompt an, der bei der KI-Unterst√ºtzung verwendet wird:</p>
                        
                        <div class="form-group">
                            <label>KI-Prompt-Vorlage:</label>
                            <textarea id="ai-prompt-template" rows="8" style="width: 100%; font-family: monospace; font-size: 0.9rem;">Schreibe hierzu einen kurzen Text. Die Frage zu den Antworten lautet {Frage}. Schreibe, wie die Antworten zusammenpassen k√∂nnten bzw. gebe Beispiele aus. Hier die Antworten: Person 1 - {Antwort1}, Person 2 - {Antwort2}. Schreibe den Text nach diesem Beispiel: "Ihr habt beide angegeben, dass ihr gerne kocht - ob mit Freund*innen oder alleine. Also los! Probiert doch einmal gemeinsam neue Rezepte. Au√üerdem geht ihr beide gerne Spazieren. "Nach dem Essen sollst du Ruhn, oder 1.000 Schritte tun." Also habt ihr ja quasi schon einen Tagesplan ;) Weil ihr beide gerne auch kulturelle Dinge macht, wie in das Theater/Museum/oder auf andere Kulturveranstaltungen geht - schaut doch mal auf rausgegangen.de was es in K√∂ln so die n√§chsten Tage gibt. Oder guckt bei uns im Eventportal: www.startwithafriend.de/events" - Nenne KEINE Namen oder andere Personenbezeichnungen.</textarea>
                        </div>
                        
                        <button class="btn btn-primary" onclick="saveAIPrompt()">üíæ Prompt speichern</button>
                        <button class="btn btn-outline" onclick="resetAIPrompt()">üîÑ Zur√ºcksetzen</button>
                    </div>                    

                    <div class="card">
                        <h3>Datenverwaltung</h3>
                        <div class="alert alert-warning">
                            <strong>Achtung:</strong> Diese Aktionen k√∂nnen nicht r√ºckg√§ngig gemacht werden!
                        </div>

                        <div style="margin: 1rem 0;">
                            <button class="btn btn-primary" onclick="exportAppData()" title="Exportiert ALLE Daten inkl. Profile, Tandems, Templates, Einstellungen">üíæ Komplettes Backup erstellen</button>
                            <button class="btn btn-secondary" onclick="createAutoBackupManual()" title="Erstellt ein tempor√§res Backup f√ºr die n√§chste Session">üîÑ Session speichern</button>
                            <button class="btn btn-outline" onclick="importAppData()">üì• Daten wiederherstellen</button>
                        </div>

                        <div style="margin: 1rem 0;">
                            <button class="btn btn-outline" onclick="clearProfiles()">üóëÔ∏è Profile l√∂schen</button>
                            <button class="btn btn-outline" onclick="clearTandems()">üóëÔ∏è Tandems l√∂schen</button>
                        </div>

                        <div style="margin-top: 2rem;">
                            <button class="btn btn-primary" onclick="resetAllData()"
                                style="background-color: var(--swaf-red);">üîÑ Alle Daten zur√ºcksetzen</button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>üìä Statistiken</h3>
                    <div class="grid grid-3">
                        <div style="text-align: center;">
                            <h4 id="stats-profiles">0</h4>
                            <p>Gesammelte Profile</p>
                        </div>
                        <div style="text-align: center;">
                            <h4 id="stats-tandems">0</h4>
                            <p>Erstellte Tandems</p>
                        </div>
                        <div style="text-align: center;">
                            <h4 id="stats-fields">0</h4>
                            <p>Durchschn. Felder/Profil</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Action Button f√ºr Schnellzugriff -->
    <button class="fab" onclick="quickSave()" title="Schnell speichern">üíæ</button>

    <!-- Status Bar -->
    <div class="status-bar">
        <div id="status-text">Bereit</div>
        <div>SwaF Tandem Matcher v2.0 - Repariert</div>
    </div>

    <!-- Floating Templates Panel -->
    <div id="floating-templates" class="floating-templates">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <h4 id="floating-templates-title">üìù Vorschl√§ge</h4>
            <button onclick="toggleFloatingTemplates()"
                style="background: none; border: none; font-size: 1.2rem; cursor: pointer; color: var(--swaf-teal);">‚úï</button>
        </div>
        <div id="floating-templates-content">
            <!-- Wird dynamisch gef√ºllt -->
        </div>
    </div>

    <button id="floating-templates-toggle" class="floating-templates-toggle" onclick="toggleFloatingTemplates()"
        title="Formulierungsvorschl√§ge">
        üìù
    </button>

    <!-- Hidden file inputs -->
    <input type="file" id="import-data-input" accept=".json" style="display: none;" onchange="handleDataImport(event)">

    <!-- Quick Actions f√ºr schnelleres Arbeiten -->
    <div class="quick-actions" id="quick-actions" style="display: none;">
        <button class="quick-action-btn quick-clear" onclick="clearAllCommonalities()" title="Strg+L: Alle Gemeinsamkeiten l√∂schen">üßπ</button>
    </div>

    <!-- Keyboard Shortcuts Info -->
    <div class="keyboard-shortcuts" id="keyboard-shortcuts">
        <strong>Shortcuts:</strong> Strg+S=Speichern | Strg+F=Schnell-Phrasen | Strg+N=Navigation (PLZ) | Strg+L=L√∂schen | Strg+B=Bulk-Edit | Esc=Schlie√üen
    </div>

    <!-- Bulk Edit Toolbar -->
    <div class="bulk-edit-toolbar" id="bulk-edit-toolbar">
        <h4 style="margin-top: 0; color: var(--swaf-red);">üöÄ Bulk-Edit Modus</h4>
        <div style="margin-bottom: 1rem;">
            <label>Schnell-Text f√ºr alle leeren Zellen:</label>
            <select id="bulk-template-select" style="width: 100%; margin-top: 0.5rem;">
                <option value="">-- Template ausw√§hlen --</option>
                <option value="Passt gut zusammen! :)">Passt gut zusammen! :)</option>
                <option value="K√∂nnt ihr euch dr√ºber austauschen">K√∂nnt ihr euch dr√ºber austauschen</option>
                <option value="Unterschiedlich - aber spannend!">Unterschiedlich - aber spannend!</option>
                <option value="Na, das wird sicher lustig! :D">Na, das wird sicher lustig! :D</option>
            </select>
        </div>
        <div style="display: flex; gap: 0.5rem;">
            <button class="btn btn-primary" onclick="applyBulkTemplate()">üìù Text anwenden</button>
            <button class="btn btn-outline" onclick="exitBulkEditMode()">‚ùå Beenden</button>
        </div>
    </div>

    <script>
        // ===============================
        // GLOBALE VARIABLEN
        // ===============================
        let profiles = JSON.parse(localStorage.getItem('swaf_profiles') || '[]');
        let tandems = JSON.parse(localStorage.getItem('swaf_tandems') || '[]');
        let selectedProfiles = [];
        let currentTandem = null;
        let selectedFields = JSON.parse(localStorage.getItem('swaf_selected_fields') || '[]');
        let textTemplates = JSON.parse(localStorage.getItem('swaf_text_templates') || '[]');
        let selectedTableCell = null;
        let floatingTemplatesVisible = false;
        let currentContextQuestion = '';
        let activeTemplateCell = null;
        let selectedTandemPairId = null;

        // ===============================
        // GAMIFICATION VARIABLEN & SYSTEM
        // ===============================
        let gamificationStats = JSON.parse(localStorage.getItem('swaf_gamification_stats') || '{"totalMatches":0,"todayMatches":0,"lastMatchDate":"","streak":0,"qualityScores":[],"achievements":[]}');
        let undoStack = [];
        let undoTimer = null;
        let dismissedSuggestions = new Set(); // IDs von abgelehnten Vorschl√§gen

        // Achievement Definitionen
        const ACHIEVEMENTS = [
            { id: 'first_steps', name: 'Erste Schritte', description: '5 Tandems erstellt', icon: 'üéØ', threshold: 5, check: (stats) => stats.totalMatches >= 5 },
            { id: 'local_hero', name: 'Lokale*r Held*in', description: '10 Locals gematcht', icon: 'üè†', threshold: 10, check: () => {
                const localMatches = tandems.filter(t => {
                    const g1 = t.profile1.fields.find(f => f.question.toLowerCase().includes('gruppe'))?.answer.toLowerCase() || '';
                    const g2 = t.profile2.fields.find(f => f.question.toLowerCase().includes('gruppe'))?.answer.toLowerCase() || '';
                    return g1.includes('local') || g2.includes('local');
                });
                return localMatches.length >= 10;
            }},
            { id: 'bridge_builder', name: 'Br√ºckenbauer*in', description: '10 interkulturelle Tandems', icon: 'üåâ', threshold: 10, check: () => {
                const interculturalMatches = tandems.filter(t => {
                    const g1 = t.profile1.fields.find(f => f.question.toLowerCase().includes('gruppe'))?.answer.toLowerCase() || '';
                    const g2 = t.profile2.fields.find(f => f.question.toLowerCase().includes('gruppe'))?.answer.toLowerCase() || '';
                    return (g1.includes('local') && g2.includes('einwander')) || (g1.includes('einwander') && g2.includes('local'));
                });
                return interculturalMatches.length >= 10;
            }},
            { id: 'speedrunner', name: 'Speedrunner', description: '10 Matches in 10 Minuten', icon: '‚ö°', threshold: 10, check: (stats) => {
                // Pr√ºfe ob die letzten 10 Matches innerhalb von 10 Minuten waren
                return false; // Wird w√§hrend des Matchings gepr√ºft
            }},
            { id: 'perfectionist', name: 'Perfektionist*in', description: '10 Matches mit 5 Sternen', icon: '‚≠ê', threshold: 10, check: (stats) => {
                const fiveStarMatches = (stats.qualityScores || []).filter(score => score >= 5);
                return fiveStarMatches.length >= 10;
            }},
            { id: 'veteran', name: 'Veteran*in', description: '50 Tandems erstellt', icon: 'üèÜ', threshold: 50, check: (stats) => stats.totalMatches >= 50 },
            { id: 'master', name: 'Matching-Master', description: '100 Tandems erstellt', icon: 'üëë', threshold: 100, check: (stats) => stats.totalMatches >= 100 }
        ];

        // ===============================
        // GLOBALE HILFSFUNKTIONEN F√úR INTELLIGENTE ANALYSE
        // ===============================

        function shouldExcludeFromMatching(question) {
            const excludeFromMatching = [
                // Namen und IDs
                'vorname', 'nachname', 'name', 'vollst√§ndiger name',
                'e-mail-adresse', 'e-mail', 'email', 'telefonnummer', 'telefon',
                'geschlecht', 'gender',
                
                // Administrative Felder
                'id', 'user-id', 'teilnehmer-id', 'profil-id',
                'gruppe', 'vermittler', 'vermittler*in', 'durchgef√ºhrt von',
                'datum/uhrzeit', 'datum', 'uhrzeit', 'termin', 'terminart',
                'status', 'bearbeitungsstatus', 'anmeldestatus',
                
                // System-/Meta-Felder
                'standort-newsletter', 'newsletter', 'dsgvo', 'einverst√§ndnis',
                'notizen', 'interne notizen', 'bemerkungen admin',
                'url', 'link', 'portal-link',
                
                // Bewertungs-/Einsch√§tzungsfelder (subjektiv)
                'wie wirkt die person auf dich', 'eindruck', 'bewertung',
                'wie sch√§tzt du ein', 'einsch√§tzung', 'beurteilung',
                
                // Prozess-/Workflow-Felder  
                'sind weitere schritte n√∂tig', 'n√§chste schritte', 'follow-up',
                'infoabend', 'aufnahmegespr√§ch datum', 'gespr√§ch datum'
            ];
            
            const normalized = question.toLowerCase().trim();
            
            return excludeFromMatching.some(excluded => {
                return normalized.includes(excluded.toLowerCase()) || 
                    excluded.toLowerCase().includes(normalized);
            });
        }

        // Cache f√ºr PLZ-Koordinaten
        let plzCache = JSON.parse(localStorage.getItem('swaf_plz_cache') || '{}');
        
        // Rate Limiting f√ºr API-Calls
        let lastApiCall = 0;
        const API_DELAY = 1000;

        // Email Template System
        let emailTemplate = {
            subject: 'ü§ù Euer Tandem-Vorschlag von Start with a Friend',
            intro: '', 
            link: '[HIER TANDEM-LINK EINF√úGEN]'
        };

        // Vordefinierte Textbausteine
        const predefinedTemplates = [
            // Sport & Bewegung - GENERISCHER
            { title: 'Sport & Bewegung', text: 'Ihr habt beide Interesse an sportlichen Aktivit√§ten' },
            { title: 'Outdoor-Aktivit√§ten', text: 'Ihr seid beide gerne drau√üen aktiv' },
            { title: 'Fitness & Gesundheit', text: 'Euch ist beiden ein aktiver Lebensstil wichtig' },

            // Kultur & Freizeit - GENERISCHER
            { title: 'Kulturelle Interessen', text: 'Ihr interessiert euch beide f√ºr Kultur und kulturelle Veranstaltungen' },
            { title: 'Unterhaltung & Medien', text: 'Ihr teilt Interessen im Bereich Unterhaltung' },
            { title: 'Veranstaltungen', text: 'Ihr geht beide gerne zu Events und Veranstaltungen' },

            // Musik & Kunst - GENERISCHER
            { title: 'Musik', text: 'Musik spielt f√ºr euch beide eine Rolle' },
            { title: 'Kreative T√§tigkeiten', text: 'Ihr habt beide kreative Interessen' },
            { title: 'K√ºnstlerische Ausdrucksformen', text: 'Euch interessieren beide verschiedene Formen der Kunst' },

            // Essen & Kochen - GENERISCHER
            { title: 'Kulinarisches', text: 'Ihr interessiert euch beide f√ºrs Essen und Kulinarisches' },
            { title: 'Gemeinsam kochen', text: 'Ihr kocht beide gerne' },

            // Sprachen & Kommunikation
            { title: 'Sprachen & Sprachenlernen', text: 'Sprachen sind f√ºr euch beide wichtig' },
            { title: 'Sprachpraxis', text: 'Ihr m√∂chtet beide eure Sprachkenntnisse √ºben' },
            { title: 'Mehrsprachigkeit', text: 'Ihr bringt beide mehrsprachige Erfahrungen mit' },

            // Soziales & Pers√∂nlichkeit - GENERISCHER
            { title: 'Soziale Aktivit√§ten', text: 'Ihr seid beide gesellig und trefft gerne Leute' },
            { title: 'Aufgeschlossenheit', text: 'Ihr seid beide offen f√ºr neue Begegnungen' },
            { title: 'Pers√∂nliche Eigenschaften', text: 'Eure Pers√∂nlichkeiten passen gut zusammen' },

            // Alter & Lebenssituation - GENERISCHER
            { title: '√Ñhnliche Lebensphase', text: 'Ihr befindet euch in √§hnlichen Lebensphasen' },
            { title: 'Bildung & Beruf', text: 'Ihr habt √§hnliche Bildungs- oder Berufshintergr√ºnde' },

            // Wohnen & Region
            { title: 'N√§he & Erreichbarkeit', text: 'Ihr wohnt gut erreichbar zueinander' },
            { title: 'Gleiche Region', text: 'Ihr kommt aus der gleichen Gegend' },
            { title: 'Kurze Wege', text: 'Ihr k√∂nnt euch unkompliziert treffen' },

            // Interessen & Hobbys - GENERISCHER
            { title: 'Gemeinsame Hobbys', text: 'Ihr habt √§hnliche Freizeitinteressen' },
            { title: 'Vielf√§ltige Interessen', text: 'Ihr habt beide vielf√§ltige Interessen' },
            { title: 'Entdeckungsfreude', text: 'Ihr seid beide offen, Neues auszuprobieren' },

            // Mobilit√§t & Verkehr - GENERISCHER
            { title: 'Mobilit√§t', text: 'Ihr seid beide mobil und flexibel' },

            // Zeitplanung - GENERISCHER
            { title: 'Zeitliche Flexibilit√§t', text: 'Eure zeitlichen M√∂glichkeiten passen gut zusammen' },

            // Unterst√ºtzend/Positiv
            { title: 'Erg√§nzende Unterschiede', text: 'Eure unterschiedlichen Hintergr√ºnde k√∂nnen euch gegenseitig bereichern' },
            { title: 'Voneinander lernen', text: 'Ihr k√∂nnt viel voneinander lernen' },
            { title: 'Neue Erfahrungen', text: 'Ihr k√∂nnt zusammen neue Erfahrungen machen' },
            { title: 'Gegenseitige Unterst√ºtzung', text: 'Ihr k√∂nnt euch gegenseitig unterst√ºtzen' },
            { title: 'Interkultureller Austausch', text: 'Ihr k√∂nnt euch kulturell bereichern' }
        ];

        // Kontextspezifische Template-Kategorien - GENERISCHER
        let contextualTemplates = {
            'alter': [
                { text: 'Ihr befindet euch in √§hnlichen Lebensphasen', priority: true },
                { text: 'Unterschiedliche Perspektiven k√∂nnen bereichernd sein', priority: false }
            ],
            'hobby': [
                { text: 'Ihr habt gemeinsame Freizeitinteressen', priority: true },
                { text: 'Eure Interessen erg√§nzen sich gut', priority: false }
            ],
            'sprache': [
                { text: 'Sprachen sind f√ºr euch beide wichtig', priority: true },
                { text: 'Ihr k√∂nnt euch beim Sprachenlernen unterst√ºtzen', priority: true },
                { text: 'Ihr bringt mehrsprachige Erfahrungen mit', priority: false }
            ],
            'postleitzahl': [
                { text: 'Ihr wohnt gut erreichbar zueinander', priority: true },
                { text: 'Kurze Wege erleichtern regelm√§√üige Treffen', priority: false }
            ],
            'wohnort': [
                { text: 'Ihr kommt aus der gleichen Gegend', priority: true },
                { text: 'Ihr habt einen gemeinsamen lokalen Bezug', priority: false }
            ],
            'beruf': [
                { text: 'Eure beruflichen Hintergr√ºnde passen zusammen', priority: true },
                { text: 'Ihr k√∂nnt euch zu euren T√§tigkeiten austauschen', priority: false }
            ],
            'studium': [
                { text: 'Ihr habt √§hnliche Bildungshintergr√ºnde', priority: true },
                { text: 'Akademische Erfahrungen verbinden euch', priority: false }
            ],
            'zeit': [
                { text: 'Eure zeitlichen M√∂glichkeiten passen zusammen', priority: true },
                { text: 'Ihr seid beide zeitlich flexibel', priority: false }
            ],
            'verkehr': [
                { text: 'Ihr seid beide mobil', priority: true },
                { text: 'Gute Verkehrsanbindung zueinander', priority: false }
            ]
        };

        let questionCategoryMapping = JSON.parse(localStorage.getItem('swaf_question_category_mapping') || '{}');

        // ===============================
        // GAMIFICATION SYSTEM
        // ===============================

        // Gamification-Datenstruktur
        let gamificationData = {
            points: 0,
            tandemsCreated: 0,
            emailsSent: 0,
            smartTextsUsed: 0,
            profilesImported: 0,
            perfectMatches: 0,
            streakDays: 0,
            lastActiveDate: null,
            statistics: {
                tandemsToday: 0,
                tandemsThisWeek: 0,
                tandemsThisMonth: 0,
                lastResetDate: new Date().toDateString()
            }
        };

        // Gamification-Daten laden
        function loadGamificationData() {
            const stored = localStorage.getItem('swaf_gamification');
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    gamificationData = { ...gamificationData, ...parsed };
                    console.log('üìä Gamification-Daten geladen:', gamificationData);
                } catch (e) {
                    console.warn('‚ö†Ô∏è Fehler beim Laden der Gamification-Daten:', e);
                }
            }
        }

        // Gamification-Daten speichern
        function saveGamificationData() {
            try {
                localStorage.setItem('swaf_gamification', JSON.stringify(gamificationData));
            } catch (e) {
                console.warn('‚ö†Ô∏è Fehler beim Speichern der Gamification-Daten:', e);
            }
        }

        // Aktivit√§t tracken
        function trackActivity(activityType, bonus = 0) {
            const pointsMap = {
                'tandem_created': 10,
                'email_sent': 5,
                'profile_imported': 3,
                'smart_text_used': 2,
                'data_saved': 1,
                'perfect_match': 15
            };

            const points = (pointsMap[activityType] || 0) + bonus;

            // Punkte hinzuf√ºgen
            gamificationData.points += points;

            // Statistiken aktualisieren
            switch (activityType) {
                case 'tandem_created':
                    gamificationData.tandemsCreated++;
                    gamificationData.statistics.tandemsToday++;
                    gamificationData.statistics.tandemsThisWeek++;
                    gamificationData.statistics.tandemsThisMonth++;
                    break;
                case 'email_sent':
                    gamificationData.emailsSent++;
                    break;
                case 'smart_text_used':
                    gamificationData.smartTextsUsed++;
                    break;
                case 'profile_imported':
                    gamificationData.profilesImported++;
                    break;
                case 'perfect_match':
                    gamificationData.perfectMatches++;
                    break;
            }

            // Streak aktualisieren
            updateStreak();

            // Speichern
            saveGamificationData();

            // UI aktualisieren
            updateGamificationUI();

            // Animation zeigen
            if (points > 0) {
                showPointsAnimation(points);
            }

            // Motivierende Nachricht bei Meilensteinen
            checkMilestones(activityType);

            console.log(`‚ú® Activity tracked: ${activityType} (+${points} Punkte)`);
        }

        // Streak aktualisieren
        function updateStreak() {
            const today = new Date().toDateString();
            const lastActive = gamificationData.lastActiveDate;

            if (lastActive === today) {
                // Bereits heute aktiv
                return;
            }

            if (lastActive) {
                const lastDate = new Date(lastActive);
                const todayDate = new Date(today);
                const diffDays = Math.floor((todayDate - lastDate) / (1000 * 60 * 60 * 24));

                if (diffDays === 1) {
                    // Streak fortsetzen
                    gamificationData.streakDays++;
                    if (gamificationData.streakDays >= 3) {
                        const bonus = 5 * gamificationData.streakDays;
                        gamificationData.points += bonus;
                        showMotivationalMessage(`üî• ${gamificationData.streakDays}-Tage-Streak! +${bonus} Bonus-Punkte!`);
                    }
                } else if (diffDays > 1) {
                    // Streak unterbrochen
                    gamificationData.streakDays = 1;
                }
            } else {
                // Erster Tag
                gamificationData.streakDays = 1;
            }

            gamificationData.lastActiveDate = today;
        }

        // T√§gliche/W√∂chentliche/Monatliche Statistiken zur√ºcksetzen
        function resetDailyStats() {
            const today = new Date().toDateString();
            if (gamificationData.statistics.lastResetDate !== today) {
                gamificationData.statistics.tandemsToday = 0;
                gamificationData.statistics.lastResetDate = today;
                saveGamificationData();
            }
        }

        // Meilensteine pr√ºfen
        function checkMilestones(activityType) {
            const { tandemsCreated, emailsSent, perfectMatches, streakDays, statistics } = gamificationData;

            // Erste Schritte
            if (tandemsCreated === 1) {
                showMotivationalMessage('üå± Dein erstes Tandem! Der Anfang einer tollen Reise!');
                triggerConfetti();
            }

            // Tages-Meilensteine
            if (statistics.tandemsToday === 5) {
                showMotivationalMessage('üî• 5 Tandems heute! Du bist on fire!');
            }
            if (statistics.tandemsToday === 10) {
                showMotivationalMessage('üöÄ 10 Tandems heute! Unglaublich produktiv!');
                triggerConfetti();
            }

            // Gesamt-Meilensteine
            if (tandemsCreated === 10) {
                showMotivationalMessage('üéØ 10 Tandems geschafft! Du rockst!');
            }
            if (tandemsCreated === 50) {
                showMotivationalMessage('üèÜ 50 Tandems! Du bist ein Profi!');
                triggerConfetti();
            }
            if (tandemsCreated === 100) {
                showMotivationalMessage('üíØ Century Club! 100 Tandems erstellt!');
                triggerConfetti();
            }

            // Perfect Matches
            if (perfectMatches === 10) {
                showMotivationalMessage('üåü 10 Perfect Matches! Quality Champion!');
            }

            // Streak
            if (streakDays === 7) {
                showMotivationalMessage('üî• 7-Tage-Streak! Du bist unaufhaltsam!');
            }
        }

        // Motivierende Nachricht anzeigen
        function showMotivationalMessage(message, duration = 5000) {
            // Erstelle Nachricht nur wenn sie nicht bereits existiert
            let messageDiv = document.getElementById('motivational-message');
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.id = 'motivational-message';
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%) translateY(-100px);
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 1rem 2rem;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    z-index: 10002;
                    font-size: 1.1rem;
                    font-weight: 600;
                    text-align: center;
                    min-width: 300px;
                    max-width: 600px;
                    opacity: 0;
                    transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                `;
                document.body.appendChild(messageDiv);
            }

            messageDiv.textContent = message;

            // Animation
            setTimeout(() => {
                messageDiv.style.transform = 'translateX(-50%) translateY(0)';
                messageDiv.style.opacity = '1';
            }, 10);

            // Ausblenden
            setTimeout(() => {
                messageDiv.style.transform = 'translateX(-50%) translateY(-100px)';
                messageDiv.style.opacity = '0';
            }, duration);
        }

        // Punkte-Animation
        function showPointsAnimation(points) {
            const statusBar = document.querySelector('.status-bar');
            if (!statusBar) return;

            const pointsDiv = document.createElement('div');
            pointsDiv.textContent = `+${points} üíé`;
            pointsDiv.style.cssText = `
                position: fixed;
                right: 20px;
                bottom: 60px;
                color: #FFD700;
                font-size: 1.5rem;
                font-weight: bold;
                z-index: 10001;
                pointer-events: none;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
                animation: pointsFly 1.5s ease-out forwards;
            `;

            document.body.appendChild(pointsDiv);

            setTimeout(() => {
                pointsDiv.remove();
            }, 1500);
        }

        // Konfetti-Animation
        function triggerConfetti() {
            const colors = ['#FF5252', '#00D1B2', '#FFD700', '#667eea', '#764ba2'];
            const confettiCount = 50;

            for (let i = 0; i < confettiCount; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.style.cssText = `
                        position: fixed;
                        width: 10px;
                        height: 10px;
                        background: ${colors[Math.floor(Math.random() * colors.length)]};
                        top: -10px;
                        left: ${Math.random() * 100}%;
                        opacity: 1;
                        z-index: 10003;
                        animation: confettiFall ${2 + Math.random() * 2}s linear forwards;
                        transform: rotate(${Math.random() * 360}deg);
                    `;
                    document.body.appendChild(confetti);

                    setTimeout(() => confetti.remove(), 4000);
                }, i * 30);
            }
        }

        // Gamification UI aktualisieren
        function updateGamificationUI() {
            // Statistik-Badge in Statusleiste
            let statsDiv = document.getElementById('gamification-stats');
            if (!statsDiv) {
                statsDiv = document.createElement('div');
                statsDiv.id = 'gamification-stats';
                statsDiv.style.cssText = `
                    display: inline-block;
                    margin-left: 15px;
                    padding: 0.25rem 0.75rem;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border-radius: 20px;
                    font-size: 0.9rem;
                    font-weight: 600;
                    cursor: pointer;
                    transition: transform 0.2s;
                `;
                statsDiv.title = 'Klicken f√ºr Details';
                statsDiv.onclick = showStatsModal;

                const statusBar = document.querySelector('.status-bar');
                if (statusBar && statusBar.firstChild) {
                    statusBar.firstChild.appendChild(statsDiv);
                }
            }

            const { points, statistics, streakDays } = gamificationData;
            statsDiv.innerHTML = `üíé ${points} Punkte | üìä ${statistics.tandemsToday} heute${streakDays > 1 ? ` | üî• ${streakDays}` : ''}`;
        }

        // Statistik-Modal anzeigen
        function showStatsModal() {
            const { points, tandemsCreated, emailsSent, smartTextsUsed, perfectMatches, streakDays, statistics } = gamificationData;

            const level = Math.floor(points / 100) + 1;
            const pointsToNextLevel = (level * 100) - points;

            const modalContent = `
                <div style="text-align: center; padding: 1rem;">
                    <h2 style="margin: 0 0 1rem 0;">üìä Deine Statistiken</h2>

                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; border-radius: 12px; margin-bottom: 1.5rem;">
                        <div style="font-size: 2rem; font-weight: bold; margin-bottom: 0.5rem;">üíé ${points} Punkte</div>
                        <div style="font-size: 1.2rem;">Level ${level}</div>
                        <div style="margin-top: 0.5rem; background: rgba(255,255,255,0.2); border-radius: 10px; height: 20px; overflow: hidden;">
                            <div style="background: rgba(255,255,255,0.8); height: 100%; width: ${((points % 100) / 100) * 100}%; transition: width 0.5s;"></div>
                        </div>
                        <div style="font-size: 0.9rem; margin-top: 0.5rem;">${pointsToNextLevel} Punkte bis Level ${level + 1}</div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; text-align: left;">
                        <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 8px;">
                            <div style="font-size: 1.5rem;">ü§ù ${tandemsCreated}</div>
                            <div>Tandems erstellt</div>
                        </div>
                        <div style="background: var(--swaf-lightest-red); padding: 1rem; border-radius: 8px;">
                            <div style="font-size: 1.5rem;">üìß ${emailsSent}</div>
                            <div>E-Mails versendet</div>
                        </div>
                        <div style="background: var(--swaf-lightest-yellow); padding: 1rem; border-radius: 8px;">
                            <div style="font-size: 1.5rem;">üéØ ${perfectMatches}</div>
                            <div>Perfect Matches</div>
                        </div>
                        <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 8px;">
                            <div style="font-size: 1.5rem;">üß† ${smartTextsUsed}</div>
                            <div>Smart Texts verwendet</div>
                        </div>
                    </div>

                    <div style="margin-top: 1.5rem; padding: 1rem; background: #f5f5f5; border-radius: 8px;">
                        <h3 style="margin: 0 0 0.5rem 0;">Diese Woche</h3>
                        <div>üìä ${statistics.tandemsThisWeek} Tandems</div>
                        ${streakDays > 1 ? `<div style="margin-top: 0.5rem; color: #FF5252; font-weight: bold;">üî• ${streakDays}-Tage-Streak!</div>` : ''}
                    </div>
                </div>
            `;

            showModal('Statistiken', modalContent, [
                {
                    text: 'Schlie√üen',
                    class: 'btn-secondary',
                    action: function () { }
                }
            ]);
        }

        // Gamification initialisieren
        function initializeGamification() {
            loadGamificationData();
            resetDailyStats();
            updateGamificationUI();

            // CSS-Animationen hinzuf√ºgen
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pointsFly {
                    0% {
                        transform: translateY(0) scale(1);
                        opacity: 1;
                    }
                    100% {
                        transform: translateY(-100px) scale(1.5);
                        opacity: 0;
                    }
                }

                @keyframes confettiFall {
                    0% {
                        transform: translateY(0) rotate(0deg);
                        opacity: 1;
                    }
                    100% {
                        transform: translateY(100vh) rotate(720deg);
                        opacity: 0;
                    }
                }

                #gamification-stats:hover {
                    transform: scale(1.05);
                }
            `;
            document.head.appendChild(style);

            console.log('üéÆ Gamification-System initialisiert');
        }

        // ===============================
        // INITIALISIERUNG
        // ===============================
        document.addEventListener('DOMContentLoaded', function () {
            console.log('üöÄ SwaF Tandem Matcher wird initialisiert...');

            // Initialisiere UI
            updateUI();

            // Starte Background-Services
            startDataChecker();
            setupClipboardDetection();

            // Gamification initialisieren
            initializeGamification();

            // Update Status
            updateStatus('SwaF Tandem Matcher bereit');
            showNotification('‚úÖ Anwendung geladen! Beginne mit dem Sammeln von Profilen.', 'success', 3000);

            // Bookmarklet-Status wiederherstellen
            const bookmarkletInstalled = localStorage.getItem('swaf_bookmarklet_installed') === 'true';
            if (bookmarkletInstalled) {
                document.getElementById('bookmarklet-installed').checked = true;
                document.getElementById('bookmarklet-install-section').style.display = 'none';
            }

            // Auto-Clipboard-Detection Status wiederherstellen
            const autoDetection = localStorage.getItem('swaf_auto_clipboard_detection') !== 'false'; // Default: true
            const autoClipboardCheckbox = document.getElementById('auto-clipboard-detection');
            if (autoClipboardCheckbox) {
                autoClipboardCheckbox.checked = autoDetection;
            }

            // Templates initialisieren
            initializeTextTemplates();
            initializeFloatingTemplates();
            loadContextualTemplatesFromStorage();
            
            // Email-Template laden
            loadEmailTemplate();
            
            // Rich-Text-Editor Events
            const editor = document.getElementById('email-intro-editor');
            if (editor) {
                editor.addEventListener('keyup', updateToolbarState);
                editor.addEventListener('mouseup', updateToolbarState);
            }
        });

        // ===============================
        // TAB-FUNKTIONEN
        // ===============================
        function switchTab(tabIndex) {
            console.log(`üîÑ Wechsle zu Tab ${tabIndex}`);

            // Entferne active Klassen
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

            // F√ºge active Klassen hinzu
            document.querySelectorAll('.tab')[tabIndex].classList.add('active');
            document.getElementById(`tab-${tabIndex}`).classList.add('active');

            // Tab-spezifische Aktionen mit Verz√∂gerung
            setTimeout(() => {
                switch (tabIndex) {
                    case 0:
                        updateCollectedProfiles();
                        updateMergeProfileLists();
                        break;

                    case 2:
                        loadFieldsWithOrder();
                        break;   
                    case 1:
                        console.log('üîÑ Initialisiere Matching-Tab...');
                        loadAvailableProfiles();
                        updateMatchedPairs();
                        updateMatchingStatus();
                        initGamification();
                        break;
                    case 2:
                        loadFieldSelection();
                        break;
                    case 3:
                        loadTandemSelector();
                        updateExportPreview();
                        initializeTextTemplates();
                        // NEU: Explizit allgemeine Templates laden
                        setTimeout(() => {
                            loadPredefinedTemplates();
                        }, 300);
                        break;
                    case 4:
                        loadSavedTandems();
                        updateStatistics();
                        break;
                    case 'i': // Strg+I f√ºr Intelligente Texte
                        e.preventDefault();
                        generateSmartTextsLocally();
                        showShortcutFeedback('üß† Intelligente Texte generiert!');
                        break;    
                }
            }, 100);
        }

        // ===============================
        // AUTO-BACKUP & RESTORE SYSTEM
        // ===============================
        function checkForAutoRestore() {
            const lastSession = localStorage.getItem('swaf_last_session_backup');
            const lastSessionTime = localStorage.getItem('swaf_last_session_time');
            
            if (lastSession && lastSessionTime) {
                const sessionTime = new Date(lastSessionTime);
                const now = new Date();
                const hoursSinceLastSession = (now - sessionTime) / (1000 * 60 * 60);
                
                // Nur anzeigen wenn die letzte Session innerhalb der letzten 24 Stunden war
                if (hoursSinceLastSession < 24) {
                    const hasCurrentData = profiles.length > 0 || tandems.length > 0;
                    
                    if (!hasCurrentData) {
                        createModal('üîÑ Session wiederherstellen?', `
                            <div class="alert alert-info">
                                <strong>Es wurde eine vorherige Session gefunden!</strong>
                                <p>Letzte Aktivit√§t: ${sessionTime.toLocaleString('de-DE')}</p>
                                <p>M√∂chtest du deine letzte Arbeitssession wiederherstellen?</p>
                            </div>
                        `, [
                            { 
                                text: 'Nein, neu starten', 
                                class: 'btn-outline', 
                                action: () => {
                                    localStorage.removeItem('swaf_last_session_backup');
                                    localStorage.removeItem('swaf_last_session_time');
                                    closeModal();
                                    showNotification('Neue Session gestartet', 'info');
                                }
                            },
                            { 
                                text: 'Ja, wiederherstellen', 
                                class: 'btn-primary', 
                                action: () => {
                                    restoreLastSession();
                                    closeModal();
                                }
                            }
                        ]);
                    }
                }
            }
        }

        function restoreLastSession() {
            try {
                const lastSession = localStorage.getItem('swaf_last_session_backup');
                if (!lastSession) {
                    showNotification('‚ùå Keine Session zum Wiederherstellen gefunden', 'error');
                    return;
                }
                
                const data = JSON.parse(lastSession);
                
                // Alle Daten wiederherstellen
                if (data.profiles) profiles = data.profiles;
                if (data.tandems) tandems = data.tandems;
                if (data.selectedFields) selectedFields = data.selectedFields;
                if (data.textTemplates) textTemplates = data.textTemplates;
                if (data.predefinedTemplates) {
                    predefinedTemplates.length = 0;
                    predefinedTemplates.push(...data.predefinedTemplates);
                }
                if (data.contextualTemplates) {
                    localStorage.setItem('swaf_contextual_templates', JSON.stringify(data.contextualTemplates));
                }
                if (data.questionCategoryMapping) {
                    localStorage.setItem('swaf_question_category_mapping', JSON.stringify(data.questionCategoryMapping));
                }
                if (data.emailTemplate) emailTemplate = data.emailTemplate;
                if (data.plzCache) {
                    plzCache = data.plzCache;
                    localStorage.setItem('swaf_plz_cache', JSON.stringify(plzCache));
                }
                
                saveAllData();
                localStorage.setItem('swaf_text_templates', JSON.stringify(textTemplates));
                localStorage.setItem('swaf_predefined_templates', JSON.stringify(predefinedTemplates));
                localStorage.setItem('swaf_email_template', JSON.stringify(emailTemplate));
                
                updateUI();
                loadEmailTemplate();
                loadPredefinedTemplates();
                
                showNotification('‚úÖ Session erfolgreich wiederhergestellt', 'success');
                
            } catch (error) {
                console.error('Fehler beim Wiederherstellen der Session:', error);
                showNotification('‚ùå Fehler beim Wiederherstellen: ' + error.message, 'error');
            }
        }

        function createAutoBackup() {
            try {
                const data = {
                    profiles: profiles,
                    tandems: tandems,
                    selectedFields: selectedFields,
                    textTemplates: textTemplates,
                    predefinedTemplates: predefinedTemplates,
                    contextualTemplates: JSON.parse(localStorage.getItem('swaf_contextual_templates') || '{}'),
                    questionCategoryMapping: JSON.parse(localStorage.getItem('swaf_question_category_mapping') || '{}'),
                    emailTemplate: emailTemplate,
                    plzCache: plzCache,
                    exported: new Date().toISOString(),
                    version: '2.1'
                };
                
                localStorage.setItem('swaf_last_session_backup', JSON.stringify(data));
                localStorage.setItem('swaf_last_session_time', new Date().toISOString());
                
                return true;
            } catch (error) {
                console.error('Fehler beim Erstellen des Auto-Backups:', error);
                return false;
            }
        }

        // ===============================
        // ZWISCHENABLAGE-ERKENNUNG
        // ===============================
        function setupClipboardDetection() {
            console.log('üìã Richte Zwischenablage-Erkennung ein...');

            // √úberwache Paste-Events (diese sind immer erlaubt)
            document.addEventListener('paste', function (e) {
                console.log('üìã Paste-Event erkannt');
                handlePasteEvent(e);
            });

            // √úberwache Fokus-Events nur wenn automatische Erkennung aktiviert ist
            window.addEventListener('focus', function () {
                const autoDetection = localStorage.getItem('swaf_auto_clipboard_detection') !== 'false';
                if (autoDetection) {
                    console.log('üîç Fenster wieder im Fokus - pr√ºfe Zwischenablage...');
                    setTimeout(() => {
                        checkClipboardForProfileDataSilently();
                    }, 1000);
                }
            });
        }

        function handlePasteEvent(e) {
            try {
                const pastedText = (e.clipboardData || window.clipboardData).getData('text');
                console.log('üìã Eingef√ºgter Text:', pastedText.substring(0, 100) + '...');

                if (pastedText.includes('SWAF_PROFILE_START') && pastedText.includes('SWAF_PROFILE_END')) {
                    e.preventDefault();
                    console.log('‚úÖ SwaF-Profildaten erkannt!');
                    
                    // üßπ KRITISCH: SOFORT Batch leeren BEVOR Import startet
                    console.log('üßπ PRE-IMPORT: Leere Batch-Speicher...');
                    localStorage.removeItem('swaf_batch_profiles');
                    
                    // Jetzt Profile importieren
                    processClipboardProfileData(pastedText);
                    
                    // Zwischenablage leeren nach Import
                    setTimeout(() => {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            navigator.clipboard.writeText('').then(() => {
                                console.log('‚úÖ Zwischenablage geleert');
                                showNotification('‚úÖ Import abgeschlossen - Batch zur√ºckgesetzt', 'success', 2000);
                            }).catch(() => {});
                        }
                    }, 300);
                }
            } catch (error) {
                console.error('‚ùå Fehler beim Verarbeiten des Paste-Events:', error);
            }
        }

        function checkClipboardForProfileDataSilently() {
            try {
                navigator.clipboard.readText().then(function (text) {
                    if (text && text.includes('SWAF_PROFILE_START') && text.includes('SWAF_PROFILE_END')) {
                        console.log('üìã SwaF-Profildaten in Zwischenablage gefunden!');
                        processClipboardProfileData(text);
                        // Leere die Zwischenablage nach Verarbeitung
                        navigator.clipboard.writeText('').catch(() => { });
                    }
                }).catch(function (error) {
                    // Stumm ignorieren - keine Benutzerbenachrichtigung
                    console.log('‚ÑπÔ∏è Zwischenablage-Zugriff nicht m√∂glich');
                });
            } catch (error) {
                // Stumm ignorieren
                console.log('‚ÑπÔ∏è Clipboard API nicht verf√ºgbar');
            }
        }

        function checkClipboardForProfileData() {
            try {
                navigator.clipboard.readText().then(function (text) {
                    if (text && text.includes('SWAF_PROFILE_START') && text.includes('SWAF_PROFILE_END')) {
                        console.log('üìã SwaF-Profildaten in Zwischenablage gefunden!');
                        processClipboardProfileData(text);
                        // Leere die Zwischenablage nach Verarbeitung
                        navigator.clipboard.writeText('').catch(() => { });
                    }
                }).catch(function (error) {
                    console.log('‚ÑπÔ∏è Zwischenablage-Zugriff nicht m√∂glich (normal in manchen Browsern)');
                });
            } catch (error) {
                console.log('‚ÑπÔ∏è Clipboard API nicht verf√ºgbar');
            }
        }


        function processClipboardProfileData(text) {
            try {
                console.log('üîç Verarbeite Zwischenablage-Daten...');
                
                const startMarker = 'SWAF_PROFILE_START';
                const endMarker = 'SWAF_PROFILE_END';
                
                // Pr√ºfe ob mehrere Profile vorhanden sind
                const matches = text.match(/SWAF_PROFILE_START(.*?)SWAF_PROFILE_END/gs);
                
                if (!matches || matches.length === 0) {
                    throw new Error('Keine g√ºltigen SWAF-Profildaten gefunden');
                }
                
                console.log(`üì¶ ${matches.length} Profil(e) gefunden`);
                
                let imported = 0;
                
                matches.forEach((match, index) => {
                    try {
                        const jsonStr = match.replace(startMarker, '').replace(endMarker, '');
                        const profileData = JSON.parse(jsonStr);
                        
                        console.log(`üì• Importiere Profil ${index + 1}:`, profileData.name);
                        receiveProfileData(profileData);
                        imported++;
                    } catch (err) {
                        console.error(`‚ùå Fehler bei Profil ${index + 1}:`, err);
                    }
                });
                
                showNotification(
                    `‚úÖ ${imported} von ${matches.length} Profil(en) erfolgreich importiert!`,
                    'success',
                    5000
                );
                                
                // Leere die Zwischenablage
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText('').then(() => {
                            console.log('‚úÖ Zwischenablage geleert');
                        }).catch((err) => {
                            console.log('‚ö†Ô∏è Zwischenablage konnte nicht geleert werden:', err);
                        });
                    }
                } catch (e) {
                    console.log('‚ÑπÔ∏è Zwischenablage konnte nicht geleert werden');
                }
                
            } catch (error) {
                console.error('‚ùå Fehler beim Verarbeiten der Profildaten:', error);
                showDebugClipboardData(text, error.message);
            }
        }

        function clearBatchOnFocus() {
            console.log('üëÅÔ∏è App erh√§lt Fokus - pr√ºfe Batch...');
            
            const batch = localStorage.getItem('swaf_batch_profiles');
            console.log('üì¶ Batch-Inhalt:', batch ? batch.substring(0, 100) + '...' : 'LEER');
            
            if (batch) {
                try {
                    const parsed = JSON.parse(batch);
                    const count = Array.isArray(parsed) ? parsed.length : 1;
                    console.log(`üßπ Batch gefunden: ${count} Profile - leere SOFORT`);
                    
                    localStorage.removeItem('swaf_batch_profiles');
                    console.log('‚úÖ Batch gel√∂scht');
                    
                    showNotification(`üßπ Batch zur√ºckgesetzt (${count} Profile entfernt)`, 'success', 2000);
                } catch (e) {
                    console.error('‚ùå Fehler beim Parsen:', e);
                    localStorage.removeItem('swaf_batch_profiles');
                }
            } else {
                console.log('‚ÑπÔ∏è Kein Batch vorhanden');
            }
        }

        function clearBatchAndClipboard() {
            console.log('üßπ Leere Batch-Speicher und Zwischenablage...');
            try {
                // Leere den localStorage Batch
                localStorage.removeItem('swaf_batch_profiles');
                console.log('‚úÖ Batch-Speicher (localStorage) geleert');
                
                // Leere die Zwischenablage
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText('').then(() => {
                        console.log('‚úÖ Zwischenablage geleert');
                        showNotification('‚úÖ Batch & Zwischenablage geleert', 'success', 2000);
                    }).catch((err) => {
                        console.log('‚ö†Ô∏è Zwischenablage konnte nicht geleert werden:', err);
                    });
                }
            } catch (e) {
                console.error('‚ùå Fehler beim Leeren:', e);
            }
        }


        // ===============================
        // PROFIL-SAMMLUNG
        // ===============================
        function startDataChecker() {
            console.log('üîç Starte Daten-Checker...');
            
            // Pr√ºfe sofort beim Start auf Batch-Daten
            checkForBatchData();

            // Pr√ºfe localStorage f√ºr Batch-Daten (weniger h√§ufig)
            setInterval(() => {
                try {
                    // Pr√ºfe localStorage f√ºr Fallback-Unterst√ºtzung
                    const data = localStorage.getItem('swaf_bookmarklet_data');
                    if (data) {
                        console.log('üì• Fallback: Bookmarklet-Daten in localStorage gefunden');
                        try {
                            const profileData = JSON.parse(data);
                            console.log('üìä localStorage Profil:', profileData.name, 'mit', profileData.fields.length, 'Feldern');
                            receiveProfileData(profileData);
                            localStorage.removeItem('swaf_bookmarklet_data');
                            showNotification('üì• Profil √ºber localStorage empfangen: ' + profileData.name, 'success');
                        } catch (error) {
                            console.error('‚ùå Fehler beim Parsen der localStorage-Daten:', error);
                            localStorage.removeItem('swaf_bookmarklet_data');
                        }
                    }
                } catch (e) {
                    // Ignoriere Fehler
                }
            }, 3000); // Reduziert von 1000ms auf 3000ms
        }

        function transferBatchToClipboard() {
            const batchJSON = localStorage.getItem('swaf_batch_profiles');
            
            if (!batchJSON) {
                showNotification('‚ÑπÔ∏è Kein Batch vorhanden', 'info');
                return;
            }
            
            const profiles = JSON.parse(batchJSON);
            
            if (profiles.length === 0) {
                showNotification('‚ÑπÔ∏è Batch ist leer', 'info');
                return;
            }
            
            // Erstelle f√ºr jedes Profil einen SWAF_PROFILE_START/END Block
            let clipboardContent = '';
            profiles.forEach(profile => {
                clipboardContent += 'SWAF_PROFILE_START' + JSON.stringify(profile) + 'SWAF_PROFILE_END\n';
            });
            
            // Kopiere in Zwischenablage
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(clipboardContent).then(() => {
                    showNotification(
                        `‚úÖ ${profiles.length} Profile in Zwischenablage kopiert!\n\n` +
                        `Jetzt STRG+V dr√ºcken um zu importieren.`,
                        'success',
                        5000
                    );
                    
                    // Leere den Batch nach erfolgreicher √úbertragung
                    localStorage.removeItem('swaf_batch_profiles');
                }).catch(err => {
                    console.error('Fehler beim Kopieren:', err);
                    showNotification('‚ùå Fehler beim Kopieren in Zwischenablage', 'error');
                });
            } else {
                showNotification('‚ùå Zwischenablage nicht verf√ºgbar', 'error');
            }
        }

        function showBatchStatus() {
            const batchJSON = localStorage.getItem('swaf_batch_profiles');
            
            if (!batchJSON) {
                createModal('üìä Batch-Status', `
                    <div style="text-align: center; padding: 2rem;">
                        <p style="font-size: 1.2rem;">‚ÑπÔ∏è Kein aktiver Batch</p>
                        <p style="color: #666; margin-top: 1rem;">
                            Verwende das Bookmarklet im Portal, um Profile zu sammeln.
                        </p>
                    </div>
                `, [
                    { text: 'OK', class: 'btn-primary', action: 'closeModal' }
                ]);
                return;
            }
            
            const profiles = JSON.parse(batchJSON);
            
            let profileList = '';
            profiles.forEach((p, i) => {
                profileList += `
                    <div style="background: var(--swaf-lightest-teal); padding: 0.5rem; margin: 0.5rem 0; border-radius: 4px;">
                        <strong>${i + 1}. ${p.name}</strong>
                        <span style="color: #666; margin-left: 0.5rem;">(${p.pageType}, ${p.fields.length} Felder)</span>
                    </div>
                `;
            });
            
            createModal('üìä Batch-Status', `
                <div style="text-align: left;">
                    <h3>Gesammelte Profile: ${profiles.length}</h3>
                    
                    <div style="margin: 1rem 0;">
                        ${profileList}
                    </div>
                    
                    <div style="background: #e3f2fd; padding: 1rem; border-radius: 4px; margin-top: 1rem;">
                        <p><strong>üí° N√§chste Schritte:</strong></p>
                        <ol style="margin: 0.5rem 0 0 1.5rem;">
                            <li>Klicke "üìã Batch √ºbertragen"</li>
                            <li>Dr√ºcke STRG+V (oder CMD+V)</li>
                            <li>Alle Profile werden importiert</li>
                        </ol>
                    </div>
                </div>
            `, [
                { text: 'Batch √ºbertragen', class: 'btn-primary', action: 'transferBatchToClipboard' },
                { text: 'Schlie√üen', class: 'btn-outline', action: 'closeModal' }
            ]);
        }

        function resetBatch() {
            console.log('üîç Reset Batch aufgerufen...');
            
            const batchJSON = localStorage.getItem('swaf_batch_profiles');
            
            if (!batchJSON) {
                showNotification('‚úÖ Batch ist bereits leer', 'success', 2000);
                console.log('‚ÑπÔ∏è Kein Batch vorhanden');
                return;
            }
            
            try {
                let profiles;
                const parsed = JSON.parse(batchJSON);
                
                if (Array.isArray(parsed)) {
                    profiles = parsed;
                } else if (parsed.profiles && Array.isArray(parsed.profiles)) {
                    profiles = parsed.profiles;
                } else {
                    profiles = [parsed];
                }
                
                console.log(`üìä Batch enth√§lt ${profiles.length} Profile`);
                
                localStorage.removeItem('swaf_batch_profiles');
                console.log('‚úÖ Batch geleert');
                
                showNotification(
                    `‚úÖ Batch geleert!\n\n${profiles.length} Profile entfernt.\n\nBookmarklet startet jetzt wieder bei 1.`, 
                    'success', 
                    4000
                );
                
            } catch (e) {
                console.error('‚ùå Fehler beim Parsen:', e);
                localStorage.removeItem('swaf_batch_profiles');
                showNotification('‚úÖ Korrupter Batch entfernt', 'success', 2000);
            }
        }

        function countUniquePersons(profiles) {
            const names = new Set();
            profiles.forEach(p => {
                const baseName = p.name.replace(/\s*\(.*?\)\s*/g, '').trim();
                names.add(baseName);
            });
            return names.size;
        }
        
        function transferBatchToClipboard() {
            const batchJSON = localStorage.getItem('swaf_batch_profiles');
            
            if (!batchJSON) {
                showNotification('‚ÑπÔ∏è Kein Batch vorhanden', 'info');
                return;
            }
            
            try {
                const batch = JSON.parse(batchJSON);
                
                // Pr√ºfe ob batch.profiles existiert
                const profiles = batch.profiles || (Array.isArray(batch) ? batch : []);
                
                if (profiles.length === 0) {
                    showNotification('‚ÑπÔ∏è Batch ist leer', 'info');
                    return;
                }
                
                // Erstelle f√ºr jedes Profil einen SWAF_PROFILE_START/END Block
                let clipboardContent = '';
                profiles.forEach(profile => {
                    clipboardContent += 'SWAF_PROFILE_START' + JSON.stringify(profile) + 'SWAF_PROFILE_END\n';
                });
                
                // Kopiere in Zwischenablage
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(clipboardContent).then(() => {
                        showNotification(
                            `‚úÖ ${profiles.length} Profile in Zwischenablage kopiert!\n\n` +
                            `Jetzt STRG+V dr√ºcken um zu importieren.`,
                            'success',
                            5000
                        );
                        
                        // Leere den Batch nach erfolgreicher √úbertragung
                        localStorage.removeItem('swaf_batch_profiles');
                    }).catch(err => {
                        console.error('Fehler beim Kopieren:', err);
                        showNotification('‚ùå Fehler beim Kopieren in Zwischenablage', 'error');
                    });
                } else {
                    showNotification('‚ùå Zwischenablage nicht verf√ºgbar', 'error');
                }
            } catch (e) {
                console.error('Fehler beim Verarbeiten:', e);
                showNotification('‚ùå Fehler: ' + e.message, 'error');
            }
        }

        function cleanupBatchStorage() {
            try {
                localStorage.removeItem('swaf_batch_profiles');
                showNotification('‚úÖ Batch-Speicher bereinigt', 'success');
                console.log('üßπ localStorage bereinigt');
            } catch (e) {
                showNotification('‚ùå Fehler beim Bereinigen', 'error');
            }
        }

        function clearClipboard() {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText('').then(() => {
                    showNotification('‚úÖ Zwischenablage geleert', 'success', 2000);
                    console.log('üóëÔ∏è Zwischenablage wurde manuell geleert');
                }).catch((err) => {
                    showNotification('‚ùå Fehler beim Leeren der Zwischenablage', 'error', 3000);
                    console.error('‚ùå Fehler:', err);
                });
            } else {
                showNotification('‚ö†Ô∏è Zwischenablage-API nicht verf√ºgbar', 'warning', 3000);
            }
        }

        function importCurrentBatch() {
            const batchData = localStorage.getItem('swaf_batch_profiles');
            if (batchData) {
                const batch = JSON.parse(batchData);
                importBatchProfiles(batch.profiles);
                localStorage.removeItem('swaf_batch_profiles');
                closeModal();
            }
        }
        
        function countUniquePersons(profiles) {
            const names = new Set();
            profiles.forEach(p => {
                const baseName = p.name.replace(/\s*\(.*?\)\s*/g, '').trim();
                names.add(baseName);
            });
            return names.size;
        }

        function importBatchProfiles(batchProfiles) {
            console.log('üì• Importiere Batch:', batchProfiles.length, 'Profile');
            
            let imported = 0;
            let merged = 0;
            let skipped = 0;
            
            // Gruppiere Profile nach Person (Name ohne Klammern)
            const personGroups = {};
            batchProfiles.forEach(profile => {
                const baseName = profile.name.replace(/\s*\(.*?\)\s*/g, '').trim();
                if (!personGroups[baseName]) {
                    personGroups[baseName] = [];
                }
                personGroups[baseName].push(profile);
            });
            
            console.log('üë• Gruppiert in', Object.keys(personGroups).length, 'Personen');
            
            // Verarbeite jede Person
            Object.entries(personGroups).forEach(([baseName, personProfiles]) => {
                console.log('üîÑ Verarbeite Person:', baseName, '(', personProfiles.length, 'Profile)');
                
                if (personProfiles.length === 1) {
                    // Nur ein Profil - direkt importieren
                    receiveProfileData(personProfiles[0]);
                    imported++;
                } else {
                    // Mehrere Profile - merge Hauptprofil + Interview
                    const hauptprofil = personProfiles.find(p => p.pageType === 'Hauptprofil');
                    const interview = personProfiles.find(p => p.pageType === 'Interview');
                    
                    if (hauptprofil && interview) {
                        // Merge beide Profile
                        const mergedProfile = {
                            url: hauptprofil.url,
                            name: baseName,
                            pageType: 'Merged',
                            timestamp: Date.now(),
                            fields: []
                        };
                        
                        // Sammle alle Felder (ohne Duplikate)
                        const fieldMap = new Map();
                        
                        hauptprofil.fields.forEach(f => {
                            fieldMap.set(f.question, f.answer);
                        });
                        
                        interview.fields.forEach(f => {
                            if (!fieldMap.has(f.question)) {
                                fieldMap.set(f.question, f.answer);
                            } else {
                                // Wenn beide Antworten haben, kombiniere sie
                                const existing = fieldMap.get(f.question);
                                if (existing !== f.answer) {
                                    fieldMap.set(f.question, existing + ', ' + f.answer);
                                }
                            }
                        });
                        
                        fieldMap.forEach((answer, question) => {
                            mergedProfile.fields.push({ question, answer });
                        });
                        
                        console.log('üîó Merged:', hauptprofil.name, '+', interview.name, '‚Üí', mergedProfile.fields.length, 'Felder');
                        receiveProfileData(mergedProfile);
                        merged++;
                    } else {
                        // Keine vollst√§ndige Paarung - importiere einzeln
                        personProfiles.forEach(p => {
                            receiveProfileData(p);
                            imported++;
                        });
                    }
                }
            });
            
            // Gamification: Profile importiert (max 50 Punkte pro Import-Vorgang)
            const totalPersons = Object.keys(personGroups).length;
            const pointsToAward = Math.min(totalPersons, 50 / 3); // 3 Punkte pro Person, max 50
            for (let i = 0; i < pointsToAward; i++) {
                trackActivity('profile_imported');
            }

            showNotification(
                `‚úÖ Batch importiert!\n\n` +
                `üìä ${Object.keys(personGroups).length} Person(en)\n` +
                `üîó ${merged} zusammengef√ºhrt\n` +
                `üìÑ ${imported} einzeln importiert`,
                'success',
                5000
            );

            renderProfiles();
        }

        function receiveProfileData(data) {
            console.log('üì• Empfange Profildaten:', data);

            if (!data || !data.name) {
                console.error('‚ùå Ung√ºltige Profildaten');
                showNotification('‚ùå Ung√ºltige Profildaten empfangen', 'error');
                return;
            }

            // Erweiterte Information √ºber Seitentyp
            const pageType = data.pageType || 'Unbekannt';
            console.log('üìÑ Seitentyp:', pageType);

            // Definiere erlaubte Fragen (erweiterte Liste)
            const validInterviewQuestions = [
                // Urspr√ºngliche Fragen
                'Welche Sprachen sprichst du?', 'Warum m√∂chtest du bei SwaF mitmachen?',
                'Woher kennst du SwaF?', 'Was machst du gerade im Leben?', 'Branche',
                'Hast du schonmal ein Studium angefangen?', 'Welches Abschluss-Zeugnis ist das h√∂chste, das du bekommen hast?',
                'Wann hast du Zeit dich mit deinem Tandem zu treffen?', 'In welchem Land bist du geboren?',
                'Bist du in Deutschland geboren?', 'Seit wann lebst du in Deutschland?',
                'M√∂chtest du dich mit deinen Kindern anmelden?', 'Hobbys',
                'Was ist dir in einer Freundschaft besonders wichtig?', 'Gibt es einen zus√§tzlichen Schwerpunkt im Tandem?',
                'Wie kann man dich gut erreichen?', 'Wie gro√ü darf der Altersunterschied sein?',
                'Geschlecht der Tandempartner*in', 'Wie lange kannst du anreisen um dich mit deinem Tandem zu treffen?',
                'Wie bewegst du dich in der Stadt?',
                
                // Neue/fehlende Interview-Fragen hinzuf√ºgen
                'Was machst du gerne in deiner Freizeit?',
                'Was hast du vorher gemacht? Was hast du gelernt?',
                'Was m√∂chtest du in Zukunft gerne machen?',
                'Gibt es etwas Neues, was du gerne einmal ausprobieren m√∂chtest?',
                'Gibt es Themen, die dich besonders interessieren?',
                'Was w√ºrdest du gerne bei einem Community-Event unternehmen?',
                'Wie stellst du dir dein Tandem vor?',
                
                // Weitere h√§ufige Fragen
                'Was sind deine Hobbys?',
                'Welche Interessen hast du?',
                'Was machst du beruflich?',
                'Wo wohnst du?',
                'Wie alt bist du?',
                'Was studierst du?',
                'Welche Musik h√∂rst du gerne?',
                'Welchen Sport machst du gerne?',
                'Was liest du gerne?',
                'Kochst du gerne?',
                'Reist du gerne?',
                'Gehst du gerne ins Kino?',
                'Welche Filme/Serien schaust du gerne?',
                'Machst du gerne Ausfl√ºge?',
                'Gehst du gerne in Museen?',
                'Machst du gerne Musik?',
                'Tanzt du gerne?',
                'Spielst du gerne Spiele?',
                'Wie verbringst du deine Freizeit?',
                'Was machst du am Wochenende?',
                'Hast du Haustiere?',
                'Welche Farbe magst du?',
                'Was ist dein Lieblings...?',
                'Magst du...?',
                'Hast du schon mal...?',
                'Warst du schon mal...?',
                'Kennst du...?',
                'Kannst du...?'
            ];

            const validMainProfileQuestions = [
                'Vorname', 'Nachname', 'Gruppe', 'Standort', 'Region', 'Vermittler*in',
                'E-Mail-Adresse', 'Telefonnummer', 'Postleitzahl', 'Geburtstag', 'Alter',
                'Geschlecht', 'Standort-Newsletter', 'Terminart', 'Status', 'Durchgef√ºhrt von',
                'Datum/Uhrzeit', 'Infoabend', 'Wie wirkt die Person auf dich?',
                'Wie wirkt die Person auf dich? (Freitext)', 'Wie sch√§tzt du die Deutschkenntnisse ein?',
                'Wie sch√§tzt du die Deutschkenntnisse ein? (Freitext)',
                'Worauf sollte bei der Auswahl der Tandempartner*in geachtet werden?',
                'Gibt es besondere Herausforderungen?', 'Sind weitere Schritte n√∂tig? Wenn ja welche?',
                'PLZ', 'Wohnort', 'Land', 'Nationalit√§t', 'Geburtsdatum'
            ];

            // Bereinige und validiere Felder
            if (!Array.isArray(data.fields)) {
                data.fields = [];
            }

            function normalizeQuestion(question) {
                let normalized = question.trim()
                    // Entferne Satzzeichen am Ende
                    .replace(/[:\?\.!]*$/, '')
                    // Normalisiere Leerzeichen
                    .replace(/\s+/g, ' ')
                    // Kleinschreibung f√ºr Vergleiche
                    .toLowerCase()
                    // Normalisiere h√§ufige Variationen
                    .replace(/\bm√∂chtest\b/g, 'willst')
                    .replace(/\bw√ºrdest\b/g, 'willst') 
                    .replace(/\bw√ºrden\b/g, 'wollen')
                    .replace(/\bm√∂chten\b/g, 'wollen')
                    .replace(/\bm√∂chte\b/g, 'will')
                    .replace(/\bw√ºrde\b/g, 'will')
                    // Normalisiere Du/du Variationen
                    .replace(/\bdu\b/g, 'du')
                    .replace(/\bdich\b/g, 'dich')
                    .replace(/\bdir\b/g, 'dir')
                    // Entferne √ºberfl√ºssige W√∂rter
                    .replace(/\bgerne\b/g, '')
                    .replace(/\beinmal\b/g, '')
                    .replace(/\bmal\b/g, '')
                    // Normalisiere Leerzeichen erneut
                    .replace(/\s+/g, ' ')
                    .trim();
                
                return normalized;
            }

            function isValidQuestion(question, pageType) {
                const normalized = normalizeQuestion(question);
                
                // Blacklist statt Whitelist - nur offensichtlich irrelevante Fragen ausschlie√üen
                const excludePatterns = [
                    // Technische/System-Felder
                    /^(id|uid|token|csrf|session|cookie)/i,
                    /^(submit|button|hidden|temp)/i,
                    
                    // Leere oder zu kurze Fragen
                    /^.{0,2}$/,
                    
                    // Nur Zahlen oder Sonderzeichen
                    /^[\d\s\-_.,:;!?()[\]{}]+$/,
                    
                    // Offensichtliche Platzhalter
                    /^(test|example|sample|placeholder|dummy)/i,
                    
                    // Admin-Felder
                    /^(admin|moderator|staff|internal)/i
                ];
                
                // Pr√ºfe Blacklist
                if (excludePatterns.some(pattern => pattern.test(normalized))) {
                    console.log(`‚ùå Frage durch Blacklist ausgeschlossen: "${question}"`);
                    return false;
                }
                
                // F√ºr Interview-Fragen: Akzeptiere alle sinnvollen Fragen
                if (pageType === 'Interview') {
                    // Akzeptiere Fragen die wie echte Fragen aussehen
                    const looksLikeQuestion = /^.{3,200}$/.test(normalized) && // Angemessene L√§nge
                                            !/^[\d\s\-_.,:;!?()[\]{}]+$/.test(normalized); // Nicht nur Sonderzeichen
                    
                    if (looksLikeQuestion) {
                        console.log(`‚úÖ Interview-Frage akzeptiert: "${question}"`);
                        return true;
                    }
                }
                
                // F√ºr Hauptprofile: Verwende die bekannte Liste
                const validQuestions = pageType === 'Interview' ? validInterviewQuestions : validMainProfileQuestions;

                const isInWhitelist = validQuestions.some(validQ => {
                    const normalizedValid = normalizeQuestion(validQ);
                    return normalizedValid.toLowerCase() === normalized.toLowerCase() ||
                        normalized.toLowerCase().includes(normalizedValid.toLowerCase()) ||
                        normalizedValid.toLowerCase().includes(normalized.toLowerCase());
                });
                
                if (isInWhitelist) {
                    console.log(`‚úÖ Frage in Whitelist gefunden: "${question}"`);
                    return true;
                }
                
                console.log(`‚ùì Frage nicht in Whitelist, aber m√∂glicherweise g√ºltig: "${question}"`);
                return pageType === 'Interview'; // Bei Interviews: Im Zweifel akzeptieren
            }

            data.fields = data.fields.filter(f => {
                if (!f || !f.question || !f.answer) return false;

                const question = f.question.trim();
                let answer = f.answer.trim();

                if (question === '' || answer === '') return false;

                // Validierung gegen bekannte Fragen
                if (!isValidQuestion(question, data.pageType)) {
                    console.log(`‚ùå Unbekannte Frage ignoriert: "${question}"`);
                    return false;
                }

                // WICHTIG: Bereinige die Antwort von st√∂renden Formulierungen
                answer = cleanProfileAnswer(answer);

                // Nach Bereinigung pr√ºfen ob noch Inhalt vorhanden
                if (!answer || answer.length === 0) {
                    console.log(`‚ùå Antwort nach Bereinigung leer: "${f.answer}" ‚Üí "${answer}"`);
                    return false;
                }

                // Normalisiere Frage
                f.question = normalizeQuestion(question);
                f.answer = answer; // Verwende bereinigte Antwort

                return true;
            }).map(f => ({
                question: normalizeQuestion(f.question),
                answer: f.answer // Bereits bereinigt
            }));

            console.log(`‚úÖ ${data.fields.length} validierte Felder f√ºr ${data.pageType}`);

            // Erweiterte Duplikatserkennung f√ºr Profile-Kombination
            let existingProfile = null;
            let existingIndex = -1;

            // Hilfsfunktion f√ºr Namen-Normalisierung
            function normalizeNameForComparison(name) {
                const normalized = name.toLowerCase()
                    .trim()
                    // Normalisiere Umlaute
                    .replace(/√§/g, 'ae').replace(/√∂/g, 'oe').replace(/√º/g, 'ue').replace(/√ü/g, 'ss')
                    // Entferne Sonderzeichen au√üer Leerzeichen und Bindestriche
                    .replace(/[^a-z0-9\s\-]/g, '')
                    // Normalisiere Leerzeichen
                    .replace(/\s+/g, ' ')
                    .trim();
                
                // Sicherheit: Blockiere offensichtlich generische Namen
                if (normalized.match(/^(aufnahmegespraech|interview|gespr√§ch|locals?|einwander)/)) {
                    console.log(`‚ö†Ô∏è Generischer Name blockiert: "${normalized}"`);
                    return ''; // Leerer String wird nicht gematcht
                }
                
                return normalized;
            }

            // Hilfsfunktion f√ºr erweiterte Namensextraktion
            function extractCoreNames(name) {
                const names = [];
                
                // 1. Name aus Klammern extrahieren (PRIORIT√ÑT!)
                const bracketMatch = name.match(/\(([^)]+)\)/);
                if (bracketMatch) {
                    const nameInBrackets = bracketMatch[1].trim();
                    // Nur echte Personennamen, keine generischen Begriffe
                    if (nameInBrackets.length > 2 && !nameInBrackets.match(/^(locals?|einwander|interview|gespr√§ch|aufnahme)/i)) {
                        names.push(nameInBrackets);
                        console.log(`üìõ Hauptname aus Klammern: "${nameInBrackets}"`);
                    }
                }
                
                // 2. Wenn KEIN Name in Klammern vorhanden ist, dann vorsichtig andere Namen extrahieren
                if (names.length === 0) {
                    // Pr√ºfe ob es ein "nackter" Name ohne Pr√§fix ist
                    const withoutPrefix = name.replace(/^(aufnahmegespr√§ch\s+locals?\s*|aufnahmegespr√§ch\s+einwander\*innen\s*|interview\s+|gespr√§ch\s+)/i, '').trim();
                    
                    // Nur wenn der bereinigte Name deutlich k√ºrzer ist als der Original UND mindestens 3 Zeichen hat
                    if (withoutPrefix && withoutPrefix.length >= 3 && withoutPrefix.length < name.length * 0.6) {
                        names.push(withoutPrefix);
                        console.log(`üìõ Name ohne Pr√§fix: "${withoutPrefix}"`);
                    }
                    
                    // Als letzter Fallback: Original Name, aber nur wenn er nicht rein generisch ist
                    if (names.length === 0 && !name.match(/^(aufnahmegespr√§ch|interview|gespr√§ch)/i)) {
                        names.push(name);
                        console.log(`üìõ Original Name als Fallback: "${name}"`);
                    }
                }
                
                // Filtere nochmals generische/problematische Namen heraus
                const filteredNames = names.filter(n => {
                    if (!n || n.length < 3) return false;
                    
                    // Entferne explizit generische Begriffe
                    const isGeneric = n.match(/^(aufnahmegespr√§ch|interview|gespr√§ch|locals?|einwander)/i);
                    if (isGeneric) {
                        console.log(`‚ùå Generischer Name ignoriert: "${n}"`);
                        return false;
                    }
                    
                    return true;
                });
                
                console.log(`üìù Finale extrahierte Namen f√ºr "${name}":`, filteredNames);
                return filteredNames;
            }

            // 1. Erweiterte Namens√ºbereinstimmung mit Normalisierung
            const incomingNames = extractCoreNames(data.name);
            const normalizedIncomingNames = incomingNames.map(normalizeNameForComparison);

            console.log('üîç Suche Duplikate f√ºr:', data.name);
            console.log('üìù Extrahierte Namen:', incomingNames);
            console.log('üîß Normalisierte Namen:', normalizedIncomingNames);

            for (let i = 0; i < profiles.length; i++) {
                const profile = profiles[i];
                const existingNames = extractCoreNames(profile.name);
                const normalizedExistingNames = existingNames.map(normalizeNameForComparison);
                
                // Pr√ºfe alle Kombinationen mit SEHR strengen Kriterien
                let matchFound = false;
                for (const normIncoming of normalizedIncomingNames) {
                    for (const normExisting of normalizedExistingNames) {
                        // Sehr strenge √úberpr√ºfung: Namen m√ºssen identisch und echte Personennamen sein
                        if (normIncoming === normExisting && normIncoming.length >= 3) {
                            
                            // KRITISCH: √úberpr√ºfe ob es ein echter Personenname ist (enth√§lt Vor- und Nachname)
                            const hasSpaceOrHyphen = normIncoming.includes(' ') || normIncoming.includes('-');
                            const isNotGeneric = !normIncoming.match(/^(aufnahmegespraech|interview|gespr√§ch|locals?|einwander|profile|person|teilnehmer)/);
                            const isLongEnough = normIncoming.length >= 6; // Mindestens "max schmidt" = 11 Zeichen normalisiert
                            
                            if (hasSpaceOrHyphen && isNotGeneric && isLongEnough) {
                                console.log(`‚úÖ Duplikat gefunden (Personenname): "${data.name}" ‚Üî "${profile.name}" (${normIncoming})`);
                                existingProfile = profile;
                                existingIndex = i;
                                matchFound = true;
                                break;
                            } else {
                                console.log(`üö´ Potentielles Duplikat ABGELEHNT: "${normIncoming}" (hasSpace:${hasSpaceOrHyphen}, notGeneric:${isNotGeneric}, longEnough:${isLongEnough})`);
                            }
                        }
                    }
                    if (matchFound) break;
                }
                if (matchFound) break;
            }

            // 2. URL-basierte Erkennung (Fallback)
            if (!existingProfile && data.url) {
                existingIndex = profiles.findIndex(p => p.url === data.url);
                if (existingIndex !== -1) {
                    existingProfile = profiles[existingIndex];
                    console.log('‚úÖ Duplikat √ºber URL gefunden:', data.url);
                }
            }

            // 2.5 Zus√§tzliche Sicherheitspr√ºfung bei Interview-Profilen
            if (!existingProfile && data.pageType === 'Interview') {
                // Bei Interview-Profilen: Pr√ºfe ob bereits ein Hauptprofil mit gleichem Namen existiert
                const personNameFromBrackets = data.name.match(/\(([^)]+)\)/)?.[1]?.trim();
                if (personNameFromBrackets) {
                    existingIndex = profiles.findIndex(p => {
                        // Suche nach exakter Namens√ºbereinstimmung
                        const existingPersonName = p.name.match(/\(([^)]+)\)/)?.[1]?.trim() || p.name.trim();
                        return existingPersonName.toLowerCase() === personNameFromBrackets.toLowerCase();
                    });
                    
                    if (existingIndex !== -1) {
                        existingProfile = profiles[existingIndex];
                        console.log(`‚úÖ Interview-Profil zu Hauptprofil zugeordnet: "${personNameFromBrackets}"`);
                    }
                }
            }

            // 3. Manuelle Duplikatspr√ºfung f√ºr unklare F√§lle
            if (!existingProfile) {
                // Zeige potentielle Duplikate zur manuellen Pr√ºfung
                const possibleDuplicates = profiles.filter(p => {
                    const pNames = extractCoreNames(p.name);
                    const pNormalized = pNames.map(normalizeNameForComparison);
                    
                    // Pr√ºfe ob ein eingehender Name mit einem Profil-Namen √§hnlich ist
                    for (const inName of normalizedIncomingNames) {
                        for (const pName of pNormalized) {
                            // Pr√ºfe auf Teilstring-√úbereinstimmung bei ausreichender L√§nge
                            if ((inName.includes(pName) || pName.includes(inName)) && 
                                Math.min(inName.length, pName.length) > 2) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
                
                if (possibleDuplicates.length > 0) {
                    console.log('ü§î M√∂gliche Duplikate gefunden:', possibleDuplicates.map(p => p.name));
                    
                    // Zeige Merge-Dialog
                    setTimeout(() => showPossibleDuplicatesDialog(data, possibleDuplicates), 500);
                }
            }

            if (existingProfile) {
                console.log('üîÑ Kombiniere Daten mit bestehendem Profil:', existingProfile.name);

                // Kombiniere Felder und entferne Duplikate
                const combinedFields = [...existingProfile.fields];

                data.fields.forEach(newField => {
                    const normalizedNewQuestion = normalizeQuestion(newField.question);

                    const existingFieldIndex = combinedFields.findIndex(f =>
                        normalizeQuestion(f.question).toLowerCase() === normalizedNewQuestion.toLowerCase()
                    );

                    if (existingFieldIndex !== -1) {
                        const existingField = combinedFields[existingFieldIndex];
                        console.log(`üîÑ Duplikat gefunden: "${normalizedNewQuestion}"`);

                        // Kombiniere oder aktualisiere Antworten
                        if (newField.answer.length > existingField.answer.length) {
                            console.log(`  ‚Üí L√§ngere Antwort √ºbernommen: "${newField.answer}"`);
                            combinedFields[existingFieldIndex].answer = newField.answer;
                        }
                    } else {
                        // F√ºge neues Feld hinzu
                        console.log(`‚ûï Neues Feld: "${normalizedNewQuestion}" = "${newField.answer}"`);
                        combinedFields.push({
                            question: normalizedNewQuestion,
                            answer: newField.answer
                        });
                    }
                });

                // Aktualisiere bestehendes Profil
                profiles[existingIndex] = {
                    ...existingProfile,
                    fields: combinedFields,
                    pageType: existingProfile.pageType && data.pageType ?
                        `${existingProfile.pageType} + ${data.pageType}` :
                        (data.pageType || existingProfile.pageType),
                    lastUpdated: new Date().toISOString(),
                    url: data.url || existingProfile.url
                };

                saveProfiles();
                updateUI();

                const addedFields = data.fields.length;
                const totalFields = combinedFields.length;
                showNotification(
                    `üîÑ Profil "${data.name}" aktualisiert: +${addedFields} neue Felder (${pageType}) ‚Üí Total: ${totalFields} Felder`,
                    'success',
                    4000
                );

                updateStatus(`Profil "${data.name}" kombiniert ‚Ä¢ ${addedFields} neue Felder hinzugef√ºgt ‚Ä¢ Gesamt: ${profiles.length}`);
                return;
            }

            // Pr√ºfe auf andere Duplikate
            existingIndex = profiles.findIndex(p =>
                (p.url && data.url && p.url === data.url && p.name === data.name)
            );

            if (existingIndex !== -1) {
                if (confirm(`Profil "${data.name}" existiert bereits. √úberschreiben?`)) {
                    profiles.splice(existingIndex, 1);
                } else {
                    showNotification('‚ö†Ô∏è Profil nicht hinzugef√ºgt (Duplikat)', 'warning');
                    return;
                }
            }

            // Erstelle neues Profil
            const newProfile = {
                id: Date.now() + Math.random(),
                name: data.name,
                url: data.url || 'unknown',
                fields: data.fields,
                pageType: data.pageType,
                timestamp: new Date().toISOString()
            };

            profiles.push(newProfile);
            saveProfiles();
            updateUI();

            const pageInfo = data.pageType ? ` (${data.pageType})` : '';
            showNotification(
                `‚úÖ Neues Profil "${data.name}" hinzugef√ºgt${pageInfo} (${data.fields.length} Felder)`,
                'success',
                4000
            );

            updateStatus(`Profil "${data.name}" erfolgreich hinzugef√ºgt ‚Ä¢ Gesamt: ${profiles.length}`);
        }

        function showPossibleDuplicatesDialog(newProfile, possibleDuplicates) {
            if (possibleDuplicates.length === 0) return;
            
            const modal = createModal('üîç M√∂gliche Duplikate erkannt', `
                <div style="margin-bottom: 1rem;">
                    <h4>Neues Profil: <strong style="color: var(--swaf-red);">${newProfile.name}</strong></h4>
                    <p>Die folgenden Profile k√∂nnten dieselbe Person sein:</p>
                </div>
                
                <div style="max-height: 300px; overflow-y: auto;">
                    ${possibleDuplicates.map((profile, index) => `
                        <div style="border: 2px solid #ddd; padding: 1rem; margin: 0.5rem 0; border-radius: 6px;">
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="merge-choice" value="${index}" style="margin-right: 1rem; margin-top: 0.2rem;">
                                <div style="flex: 1;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                        <strong>${profile.name}</strong>
                                        <span style="background: var(--swaf-teal); color: white; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.9rem;">
                                            ${profile.fields.length} Felder
                                        </span>
                                    </div>
                                    <div style="font-size: 0.9rem; color: var(--swaf-dark-gray);">
                                        URL: ${profile.url}<br>
                                        Erstellt: ${new Date(profile.timestamp).toLocaleString('de-DE')}
                                    </div>
                                </div>
                            </label>
                        </div>
                    `).join('')}
                </div>
                
                <div style="margin-top: 1rem;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio" name="merge-choice" value="new" style="margin-right: 0.5rem;">
                        <span><strong>Als neues Profil hinzuf√ºgen</strong> (nicht zusammenf√ºhren)</span>
                    </label>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Zusammenf√ºhren', class: 'btn-primary', action: function() { processDuplicateChoice(newProfile, possibleDuplicates); } }
            ]);
        }

        function processDuplicateChoice(newProfile, possibleDuplicates) {
            console.log('üîÑ Verarbeite Duplikat-Wahl...');
            
            const selectedRadio = document.querySelector('input[name="merge-choice"]:checked');
            
            if (!selectedRadio) {
                alert('Bitte w√§hle eine Option aus.');
                return;
            }
            
            closeModal();
            
            if (selectedRadio.value === 'new') {
                // Als neues Profil hinzuf√ºgen
                console.log('üë§ Profil als neu markiert:', newProfile.name);
                addNewProfile(newProfile);
            } else {
                // Mit ausgew√§hltem Profil zusammenf√ºhren
                const selectedIndex = parseInt(selectedRadio.value);
                
                if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= possibleDuplicates.length) {
                    console.error('‚ùå Ung√ºltiger Index:', selectedIndex);
                    alert('Fehler bei der Auswahl. Bitte versuche es erneut.');
                    return;
                }
                
                const existingProfile = possibleDuplicates[selectedIndex];
                
                if (!existingProfile) {
                    console.error('‚ùå Ausgew√§hltes Profil nicht gefunden');
                    alert('Profil nicht gefunden. Bitte versuche es erneut.');
                    return;
                }
                
                console.log('üîÑ F√ºhre Profile zusammen:', newProfile.name, '‚Üí', existingProfile.name);
                mergeProfiles(existingProfile, newProfile);
            }
        }

        function addNewProfile(profileData) {
            // Erstelle neues Profil (Originaler Code)
            const newProfile = {
                id: Date.now() + Math.random(),
                name: profileData.name,
                url: profileData.url || 'unknown',
                fields: profileData.fields,
                pageType: profileData.pageType,
                timestamp: new Date().toISOString()
            };

            profiles.push(newProfile);
            saveProfiles();
            updateUI();

            const pageInfo = profileData.pageType ? ` (${profileData.pageType})` : '';
            showNotification(
                `‚úÖ Neues Profil "${profileData.name}" hinzugef√ºgt${pageInfo} (${profileData.fields.length} Felder)`,
                'success',
                4000
            );

            updateStatus(`Profil "${profileData.name}" erfolgreich hinzugef√ºgt ‚Ä¢ Gesamt: ${profiles.length}`);
        }

        function mergeProfiles(existingProfile, newProfileData) {
            console.log('üîÑ Kombiniere Daten mit bestehendem Profil:', existingProfile.name);

            const existingIndex = profiles.findIndex(p => p.id === existingProfile.id);
            if (existingIndex === -1) {
                console.error('‚ùå Bestehendes Profil nicht gefunden');
                return;
            }

            // Kombiniere Felder und entferne Duplikate
            const combinedFields = [...existingProfile.fields];

            newProfileData.fields.forEach(newField => {
                const normalizedNewQuestion = normalizeQuestion(newField.question);

                const existingFieldIndex = combinedFields.findIndex(f =>
                    normalizeQuestion(f.question).toLowerCase() === normalizedNewQuestion.toLowerCase()
                );

                if (existingFieldIndex !== -1) {
                    const existingField = combinedFields[existingFieldIndex];
                    console.log(`üîÑ Duplikat gefunden: "${normalizedNewQuestion}"`);

                    // Kombiniere oder aktualisiere Antworten
                    if (newField.answer.length > existingField.answer.length) {
                        console.log(`  ‚Üí L√§ngere Antwort √ºbernommen: "${newField.answer}"`);
                        combinedFields[existingFieldIndex].answer = newField.answer;
                    }
                } else {
                    // F√ºge neues Feld hinzu
                    console.log(`‚ûï Neues Feld: "${normalizedNewQuestion}" = "${newField.answer}"`);
                    combinedFields.push({
                        question: normalizedNewQuestion,
                        answer: newField.answer
                    });
                }
            });

            // Aktualisiere bestehendes Profil
            profiles[existingIndex] = {
                ...existingProfile,
                fields: combinedFields,
                pageType: existingProfile.pageType && newProfileData.pageType ?
                    `${existingProfile.pageType} + ${newProfileData.pageType}` :
                    (newProfileData.pageType || existingProfile.pageType),
                lastUpdated: new Date().toISOString(),
                url: newProfileData.url || existingProfile.url
            };

            saveProfiles();
            updateUI();

            const addedFields = newProfileData.fields.length;
            const totalFields = combinedFields.length;
            showNotification(
                `üîÑ Profil "${existingProfile.name}" aktualisiert: +${addedFields} neue Felder (${newProfileData.pageType}) ‚Üí Total: ${totalFields} Felder`,
                'success',
                4000
            );

            updateStatus(`Profil "${existingProfile.name}" kombiniert ‚Ä¢ ${addedFields} neue Felder hinzugef√ºgt ‚Ä¢ Gesamt: ${profiles.length}`);
        }

        function updateMergeProfileLists() {
            const select1 = document.getElementById('merge-profile-1');
            const select2 = document.getElementById('merge-profile-2');
            
            if (!select1 || !select2) return;
            
            const options = profiles.map(p => 
                `<option value="${p.id}">${p.name} (${p.fields.length} Felder)</option>`
            ).join('');
            
            select1.innerHTML = '<option value="">-- Profil ausw√§hlen --</option>' + options;
            select2.innerHTML = '<option value="">-- Profil ausw√§hlen --</option>' + options;
            
            console.log('üîÑ Merge-Listen aktualisiert mit', profiles.length, 'Profilen');
        }

        function showMergePreview() {
            const id1 = document.getElementById('merge-profile-1').value;
            const id2 = document.getElementById('merge-profile-2').value;
            
            if (!id1 || !id2) {
                alert('Bitte w√§hle beide Profile aus.');
                return;
            }
            
            if (id1 === id2) {
                alert('Bitte w√§hle zwei verschiedene Profile aus.');
                return;
            }
            
            const profile1 = profiles.find(p => p.id == id1);
            const profile2 = profiles.find(p => p.id == id2);
            
            if (!profile1 || !profile2) {
                alert('Profile nicht gefunden.');
                return;
            }
            
            const modal = createModal('üëÄ Merge-Vorschau', `
                <div style="margin-bottom: 1rem;">
                    <h4>Profile werden zusammengef√ºhrt:</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
                        <div style="border: 2px solid var(--swaf-red); padding: 1rem; border-radius: 6px;">
                            <h5 style="color: var(--swaf-red); margin-top: 0;">Hauptprofil (bleibt erhalten)</h5>
                            <strong>${profile1.name}</strong><br>
                            <small>${profile1.fields.length} Felder</small>
                        </div>
                        <div style="border: 2px solid var(--swaf-teal); padding: 1rem; border-radius: 6px;">
                            <h5 style="color: var(--swaf-teal); margin-top: 0;">Zusatzprofil (wird eingemischt)</h5>
                            <strong>${profile2.name}</strong><br>
                            <small>${profile2.fields.length} Felder</small>
                        </div>
                    </div>
                </div>
                
                <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px;">
                    <h4>Was passiert:</h4>
                    <ul style="margin: 0.5rem 0 0 1rem;">
                        <li><strong>Felder werden kombiniert:</strong> Alle einzigartigen Felder aus beiden Profilen</li>
                        <li><strong>Bei Duplikaten:</strong> L√§ngere/vollst√§ndigere Antwort wird behalten</li>
                        <li><strong>Profil 2 wird gel√∂scht</strong> nach dem Zusammenf√ºhren</li>
                        <li><strong>Alle Tandems bleiben erhalten</strong> (Referenzen werden aktualisiert)</li>
                    </ul>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Jetzt zusammenf√ºhren', class: 'btn-primary', action: function() { confirmManualMerge(profile1, profile2); } }
            ]);
        }

        function confirmManualMerge(profile1, profile2) {
            closeModal();
            
            if (!confirm(`Wirklich "${profile2.name}" in "${profile1.name}" einmischen?\n\nProfile 2 wird danach gel√∂scht!`)) {
                return;
            }
            
            // F√ºhre Merge durch
            const profile2Data = {
                name: profile2.name,
                fields: profile2.fields,
                pageType: profile2.pageType,
                url: profile2.url
            };
            
            mergeProfiles(profile1, profile2Data);
            
            // L√∂sche das zweite Profil
            const index2 = profiles.findIndex(p => p.id === profile2.id);
            if (index2 !== -1) {
                profiles.splice(index2, 1);
                saveProfiles();
            }
            
            // Aktualisiere Tandem-Referenzen
            updateTandemReferences(profile2.id, profile1.id);
            
            // UI aktualisieren
            updateUI();
            updateMergeProfileLists();
            
            showNotification(`‚úÖ Profile erfolgreich zusammengef√ºhrt: "${profile2.name}" ‚Üí "${profile1.name}"`, 'success', 5000);
        }

        function manualMergeProfiles() {
            const id1 = document.getElementById('merge-profile-1').value;
            const id2 = document.getElementById('merge-profile-2').value;
            
            if (!id1 || !id2) {
                alert('Bitte w√§hle beide Profile aus.');
                return;
            }
            
            if (id1 === id2) {
                alert('Bitte w√§hle zwei verschiedene Profile aus.');
                return;
            }
            
            showMergePreview();
        }

        function updateTandemReferences(oldProfileId, newProfileId) {
            let updatedTandems = 0;
            
            tandems.forEach(tandem => {
                if (tandem.profile1.id == oldProfileId) {
                    const newProfile = profiles.find(p => p.id == newProfileId);
                    if (newProfile) {
                        tandem.profile1 = newProfile;
                        tandem.name = `${tandem.profile1.name} & ${tandem.profile2.name}`;
                        updatedTandems++;
                    }
                }
                if (tandem.profile2.id == oldProfileId) {
                    const newProfile = profiles.find(p => p.id == newProfileId);
                    if (newProfile) {
                        tandem.profile2 = newProfile;
                        tandem.name = `${tandem.profile1.name} & ${tandem.profile2.name}`;
                        updatedTandems++;
                    }
                }
            });
            
            if (updatedTandems > 0) {
                saveTandems();
                console.log(`‚úÖ ${updatedTandems} Tandem-Referenzen aktualisiert`);
            }
        }

        function normalizeQuestion(question) {
            return question.trim().replace(/[:\?\.]*$/, '').replace(/\s+/g, ' ');
        }

        // ===============================
        // KARTENANSICHT
        // ===============================
        let profileMap = null;
        let profileMarkers = [];
        let currentView = 'list';
        
        function switchProfileView(view) {
            currentView = view;
            const listView = document.getElementById('available-profiles');
            const mapView = document.getElementById('map-view-container');
            const listBtn = document.getElementById('list-view-btn');
            const mapBtn = document.getElementById('map-view-btn');
        
            if (view === 'list') {
                listView.style.display = 'block';
                mapView.style.display = 'none';
                listBtn.style.background = 'var(--swaf-teal)';
                listBtn.style.color = 'white';
                mapBtn.style.background = '';
                mapBtn.style.color = '';
            } else {
                listView.style.display = 'none';
                mapView.style.display = 'block';
                listBtn.style.background = '';
                listBtn.style.color = '';
                mapBtn.style.background = 'var(--swaf-teal)';
                mapBtn.style.color = 'white';
                loadProfileMap();
            }
        }
        
        async function loadProfileMap() {
            console.log('üó∫Ô∏è Lade Kartenansicht...');

            // Hole Filter-Werte
            const search = document.getElementById('profile-search').value.toLowerCase().trim();
            const searchScope = document.getElementById('search-scope').value;
            const specificField = document.getElementById('specific-field-select')?.value || '';
            const genderFilter = document.getElementById('filter-gender').value.toLowerCase();
            const gruppeFilter = document.getElementById('filter-gruppe').value.toLowerCase();
            const ageMin = parseInt(document.getElementById('filter-age-min').value) || 0;
            const ageMax = parseInt(document.getElementById('filter-age-max').value) || 999;

            // Initialisiere Karte wenn noch nicht vorhanden
            if (!profileMap) {
                profileMap = L.map('profile-map').setView([51.1657, 10.4515], 6); // Deutschland Zentrum
        
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(profileMap);
            }
        
            // L√∂sche alte Marker
            profileMarkers.forEach(marker => profileMap.removeLayer(marker));
            profileMarkers = [];
        
            // Filtere verf√ºgbare Profile
            const matchedProfileIds = new Set();
            tandems.forEach(tandem => {
                matchedProfileIds.add(tandem.profile1.id);
                matchedProfileIds.add(tandem.profile2.id);
            });
        
            const availableProfiles = profiles.filter(profile => !matchedProfileIds.has(profile.id));
        
            if (availableProfiles.length === 0) {
                showNotification('Keine verf√ºgbaren Profile zum Anzeigen', 'info');
                return;
            }
        
            const bounds = [];
            const plzOffsets = {}; // Tracking f√ºr PLZ-Duplikate
        
            // Erstelle Marker f√ºr jedes Profil
            for (const profile of availableProfiles) {

                // Anwenden der Filter
                // 1. Erweiterte Suche durch Profile
                const matchesSearch = searchInProfile(profile, search, searchScope, specificField);

                // 2. Geschlecht-Filter
                const genderField = profile.fields.find(f =>
                    f.question.toLowerCase().includes('geschlecht') &&
                    !f.question.toLowerCase().includes('tandem') &&
                    !f.question.toLowerCase().includes('partner')
                );
                const profileGender = genderField ? genderField.answer.toLowerCase() : '';
                const matchesGender = !genderFilter || profileGender.includes(genderFilter);

                // 3. Gruppen-Filter
                const gruppeField = profile.fields.find(f =>
                    f.question.toLowerCase().includes('gruppe') ||
                    f.question.toLowerCase().includes('local') ||
                    f.question.toLowerCase().includes('einwander')
                );
                const profileGruppe = gruppeField ? gruppeField.answer.toLowerCase() : '';
                const matchesGruppe = !gruppeFilter || profileGruppe.includes(gruppeFilter);

                // 4. Alter-Filter
                const ageField = profile.fields.find(f =>
                    f.question.toLowerCase() === 'alter' ||
                    f.question.toLowerCase().includes('geburtstag')
                );
                let profileAge = 0;
                if (ageField) {
                    profileAge = parseInt(ageField.answer) || 0;
                    if (profileAge === 0 && ageField.answer.includes('/')) {
                        const parts = ageField.answer.split(/[\/\.]/);
                        if (parts.length === 3) {
                            const year = parseInt(parts[2]);
                            const currentYear = new Date().getFullYear();
                            profileAge = currentYear - year;
                        }
                    }
                }
                const matchesAge = (profileAge === 0) || (profileAge >= ageMin && profileAge <= ageMax);

                // √úberspringe Profile, die nicht den Filtern entsprechen
                if (!matchesSearch || !matchesGender || !matchesGruppe || !matchesAge) {
                    continue;
                }

                const plzField = profile.fields.find(f => 
                    f.question.toLowerCase().includes('postleitzahl') || 
                    f.question.toLowerCase().includes('plz')
                );
        
                if (!plzField) continue;
        
                const plz = extractPLZ(plzField.answer);
                if (!plz) continue;
        
                 // Hole Koordinaten
                let coords = await getPLZCoordinates(plz);
                if (!coords) continue;

                // Behandle PLZ-Duplikate: Verschiebe Marker deutlich sichtbar
                if (!plzOffsets[plz]) {
                    plzOffsets[plz] = 0;
                } else {
                    // Verschiebe jeden weiteren Marker um ~500 Meter in verschiedene Richtungen (8 Richtungen)
                    const offsetCount = plzOffsets[plz];
                    const angle = (offsetCount * 45) % 360; // 0¬∞, 45¬∞, 90¬∞, 135¬∞, 180¬∞, 225¬∞, 270¬∞, 315¬∞
                    const distance = 0.005; // ~500 Meter (deutlich sichtbarer)

                    const latOffset = distance * Math.cos(angle * Math.PI / 180);
                    const lngOffset = distance * Math.sin(angle * Math.PI / 180);

                    coords = [coords[0] + latOffset, coords[1] + lngOffset];

                    console.log(`üìç PLZ ${plz} Duplikat #${offsetCount + 1} - verschoben um ${angle}¬∞ (~500m)`);
                }
                plzOffsets[plz]++;
        
                // Extrahiere Profilinformationen
                const alter = profile.fields.find(f =>
                    f.question.toLowerCase() === 'alter' ||
                    (f.question.toLowerCase().includes('alter') &&
                     !f.question.toLowerCase().includes('unterschied') &&
                     !f.question.toLowerCase().includes('gro√ü'))
                )?.answer || 'N/A';
                const geschlecht = profile.fields.find(f =>
                    f.question.toLowerCase().includes('geschlecht') &&
                    !f.question.toLowerCase().includes('tandem') &&
                    !f.question.toLowerCase().includes('partner')
                )?.answer || 'N/A';
                const gruppe = profile.fields.find(f =>
                    f.question.toLowerCase().includes('gruppe') ||
                    f.question.toLowerCase().includes('local') ||
                    f.question.toLowerCase().includes('einwander') ||
                    f.question.toLowerCase().includes('newcom')
                )?.answer || 'N/A';
                const maxAltersdiff = profile.fields.find(f => 
                    f.question.toLowerCase().includes('maximale altersdifferenz') ||
                    f.question.toLowerCase().includes('altersunterschied')
                )?.answer || 'N/A';
                const geschlechtTandem = profile.fields.find(f => 
                    f.question.toLowerCase().includes('geschlecht') && 
                    f.question.toLowerCase().includes('tandem')
                )?.answer || 'N/A';
        
                 // Bestimme Marker-Farbe basierend auf Gruppe und Auswahl
                const isSelected = selectedProfiles.some(id => id == profile.id);
                
                // Bestimme Grundfarbe nach Gruppe
                let baseColor = '#009892'; // Standard: Teal
                if (gruppe.toLowerCase().includes('local')) {
                    baseColor = '#FFB000'; // Gelb/Gold f√ºr Locals
                } else if (gruppe.toLowerCase().includes('einwander')) {
                    baseColor = '#009892'; // Teal f√ºr Einwanderer*innen
                }
                
                // Wenn ausgew√§hlt, nutze Rot
                const markerColor = isSelected ? '#C30045' : baseColor;
        
                // Erstelle Custom Icon
                const customIcon = L.divIcon({
                    className: 'custom-marker',
                    html: `<div style="background-color: ${markerColor}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">${profile.name.substring(0, 1).toUpperCase()}</div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });
        
                // Erstelle Marker
                const marker = L.marker(coords, { icon: customIcon }).addTo(profileMap);
        
                // Erstelle vollst√§ndige Profil-Details f√ºr das Popup
                const allFieldsHTML = profile.fields.map(field => `
                    <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: #f5f5f5; border-radius: 4px;">
                        <strong style="color: var(--swaf-teal); font-size: 0.85rem;">${field.question}</strong>
                        <div style="margin-top: 0.25rem; font-size: 0.9rem;">${field.answer}</div>
                    </div>
                `).join('');

                // Popup-Inhalt mit aufklappbaren Details
                const popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                        <h4 style="margin: 0 0 0.5rem 0; color: var(--swaf-red);">${profile.name}</h4>
                        <table style="width: 100%; font-size: 0.9rem; margin-bottom: 0.5rem;">
                            <tr><td><strong>Alter:</strong></td><td>${alter}</td></tr>
                            <tr><td><strong>Geschlecht:</strong></td><td>${geschlecht}</td></tr>
                            <tr><td><strong>Gruppe:</strong></td><td>${gruppe}</td></tr>
                            <tr><td><strong>PLZ:</strong></td><td>${plz}</td></tr>
                            <tr><td><strong>Max. Altersdiff.:</strong></td><td>${maxAltersdiff}</td></tr>
                            <tr><td><strong>Geschlecht Tandem:</strong></td><td>${geschlechtTandem}</td></tr>
                        </table>

                        <button class="btn btn-outline btn-small"
                            onclick="toggleMapPopupDetails('${profile.id}')"
                            id="toggle-details-${profile.id}"
                            style="width: 100%; margin-bottom: 0.5rem; font-size: 0.85rem;">
                            üìã Alle Felder anzeigen
                        </button>

                        <div id="popup-details-${profile.id}" style="display: none; max-height: 400px; overflow-y: auto; margin-bottom: 0.5rem; padding: 0.5rem; background: white; border: 1px solid #ddd; border-radius: 4px;">
                            ${allFieldsHTML}
                        </div>

                        <button class="btn btn-primary" onclick="toggleProfileSelectionFromMap('${profile.id}')" style="width: 100%;">
                            ${isSelected ? '‚úì Ausgew√§hlt' : 'Ausw√§hlen'}
                        </button>
                    </div>
                `;

                marker.bindPopup(popupContent, { maxWidth: 450 });
                profileMarkers.push(marker);
                bounds.push(coords);
            }
        
            // Passe Kartenansicht an alle Marker an
            if (bounds.length > 0) {
                profileMap.fitBounds(bounds, { padding: [50, 50] });
            }
        
            console.log(`‚úÖ ${profileMarkers.length} Profile auf Karte angezeigt`);
        }
        
        function toggleMapPopupDetails(profileId) {
            const detailsDiv = document.getElementById(`popup-details-${profileId}`);
            const toggleBtn = document.getElementById(`toggle-details-${profileId}`);

            if (detailsDiv && toggleBtn) {
                if (detailsDiv.style.display === 'none' || detailsDiv.style.display === '') {
                    detailsDiv.style.display = 'block';
                    toggleBtn.textContent = 'üìã Alle Felder verbergen';
                } else {
                    detailsDiv.style.display = 'none';
                    toggleBtn.textContent = 'üìã Alle Felder anzeigen';
                }
            }
        }

        function toggleProfileSelectionFromMap(profileId) {
            // Konvertiere zu Number f√ºr konsistenten Vergleich
            const numericId = typeof profileId === 'string' ? parseFloat(profileId) : profileId;

            const index = selectedProfiles.findIndex(id => {
                const numericSelectedId = typeof id === 'string' ? parseFloat(id) : id;
                return numericSelectedId === numericId;
            });

            if (index > -1) {
                selectedProfiles.splice(index, 1);
            } else {
                if (selectedProfiles.length >= 2) {
                    showNotification('Maximal 2 Profile k√∂nnen ausgew√§hlt werden', 'warning');
                    return;
                }
                selectedProfiles.push(numericId);
            }

            updateMatchingStatus();

            // Aktualisiere Karte
            loadProfileMap();

            console.log('üìä Ausgew√§hlte Profile nach Karten-Toggle:', selectedProfiles);
        }

        // ===============================
        // GAMIFICATION FUNKTIONEN
        // ===============================

        function initGamification() {
            updateGamificationUI();
            updateSmartMatches();
            checkAchievements();
        }

        function updateGamificationUI() {
            // Aktualisiere Fortschrittsbalken
            const totalProfiles = profiles.length;
            const matchedProfiles = tandems.length * 2;
            const progress = totalProfiles > 0 ? Math.round((matchedProfiles / totalProfiles) * 100) : 0;

            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            if (progressBar && progressText) {
                progressBar.style.width = `${progress}%`;
                progressBar.textContent = `${progress}%`;
                progressText.textContent = `${matchedProfiles} von ${totalProfiles} Profilen gematcht`;
            }

            // Aktualisiere Stats
            const today = new Date().toDateString();
            if (gamificationStats.lastMatchDate !== today) {
                gamificationStats.todayMatches = 0;
                gamificationStats.lastMatchDate = today;
            }

            document.getElementById('stat-today').textContent = gamificationStats.todayMatches || 0;
            document.getElementById('stat-streak').textContent = gamificationStats.streak || 0;

            const avgQuality = gamificationStats.qualityScores && gamificationStats.qualityScores.length > 0
                ? (gamificationStats.qualityScores.reduce((a, b) => a + b, 0) / gamificationStats.qualityScores.length).toFixed(1)
                : '-';
            document.getElementById('stat-quality').textContent = avgQuality !== '-' ? `${avgQuality}‚≠ê` : '-';

            saveGamificationStats();
        }

        // Hobby- und Interessens-Normalisierung f√ºr besseres Matching
        function normalizeHobbyInterest(text) {
            if (!text) return [];

            const normalized = text.toLowerCase()
                .replace(/√ü/g, 'ss')
                .replace(/√§/g, 'ae')
                .replace(/√∂/g, 'oe')
                .replace(/√º/g, 'ue');

            // Mapping von Varianten zu Hauptkategorien
            const hobbyMapping = {
                // Sport allgemein
                'sport': ['sport', 'sportlich', 'bewegung', 'fitness', 'training', 'trainieren'],
                'fussball': ['fussball', 'fu√üball', 'soccer', 'kicken'],
                'laufen': ['laufen', 'joggen', 'jogging', 'rennen', 'running'],
                'wandern': ['wandern', 'hiking', 'spazieren', 'spaziergang', 'walken'],
                'schwimmen': ['schwimmen', 'swimming', 'baden'],
                'radfahren': ['radfahren', 'fahrrad', 'cycling', 'biken', 'radeln'],
                'yoga': ['yoga', 'meditation', 'entspannung'],
                'tanzen': ['tanzen', 'dancing', 'tanz'],
                'kraftsport': ['kraftsport', 'fitnessstudio', 'gym', 'krafttraining', 'bodybuilding'],

                // Kultur & Unterhaltung
                'kino': ['kino', 'film', 'filme', 'movie', 'movies', 'serien'],
                'theater': ['theater', 'schauspiel', 'buehne'],
                'museum': ['museum', 'ausstellung', 'galerie', 'kunst'],
                'konzert': ['konzert', 'konzerte', 'livemusik', 'live-musik'],
                'festival': ['festival', 'festivals', 'veranstaltung', 'events'],

                // Musik
                'musik': ['musik', 'music', 'musikhoeren', 'musik hoeren'],
                'instrument': ['instrument', 'gitarre', 'klavier', 'schlagzeug', 'geige', 'spielen'],
                'singen': ['singen', 'gesang', 'chor'],

                // Essen & Kochen
                'kochen': ['kochen', 'cooking', 'rezepte', 'kueche'],
                'backen': ['backen', 'baking', 'kuchen'],
                'restaurant': ['restaurant', 'essen gehen', 'ausgehen'],
                'essen': ['essen', 'food', 'kulinarisch', 'gourmet'],

                // Soziales
                'freunde': ['freunde', 'freunde treffen', 'leute treffen', 'socializing', 'gesellig'],
                'reisen': ['reisen', 'travel', 'urlaub', 'reise', 'entdecken'],
                'fotografie': ['fotografie', 'fotografieren', 'photo', 'foto', 'camera'],

                // Natur
                'natur': ['natur', 'nature', 'draussen', 'outdoor', 'umwelt'],
                'gaertnern': ['gaertnern', 'garten', 'pflanzen', 'gardening'],

                // Kreatives
                'lesen': ['lesen', 'buch', 'buecher', 'reading', 'literatur'],
                'schreiben': ['schreiben', 'writing', 'blog', 'texte'],
                'malen': ['malen', 'zeichnen', 'painting', 'drawing', 'kunst'],
                'handwerk': ['handwerk', 'basteln', 'diy', 'werken', 'handarbeit'],

                // Technologie
                'gaming': ['gaming', 'games', 'computerspiele', 'videospiele', 'zocken'],
                'technologie': ['technologie', 'tech', 'computer', 'programmieren', 'coding'],

                // Lernen
                'sprachen': ['sprachen', 'language', 'languages', 'sprachenlernen']
            };

            const foundCategories = [];

            // Finde alle passenden Kategorien
            for (const [category, variants] of Object.entries(hobbyMapping)) {
                for (const variant of variants) {
                    if (normalized.includes(variant)) {
                        if (!foundCategories.includes(category)) {
                            foundCategories.push(category);
                        }
                        break;
                    }
                }
            }

            return foundCategories;
        }

        function calculateMatchQuality(profile1, profile2) {
            let score = 0;
            let maxScore = 0;
            const details = {
                age: null,
                ageDiff: null,
                plz1: null,
                plz2: null,
                plzDistance: null,
                intercultural: false,
                genderPreference: null,
                reasons: []
            };

            // 1. PLZ-Distanz (max 3 Punkte - H√ñCHSTE PRIORIT√ÑT!)
            maxScore += 3;
            const plz1Field = profile1.fields.find(f => f.question.toLowerCase().includes('plz') || f.question.toLowerCase().includes('postleitzahl'));
            const plz2Field = profile2.fields.find(f => f.question.toLowerCase().includes('plz') || f.question.toLowerCase().includes('postleitzahl'));
            if (plz1Field && plz2Field) {
                const plz1 = plz1Field.answer.match(/\d{5}/)?.[0] || '';
                const plz2 = plz2Field.answer.match(/\d{5}/)?.[0] || '';
                if (plz1 && plz2) {
                    details.plz1 = plz1;
                    details.plz2 = plz2;

                    // Berechne gesch√§tzte Distanz basierend auf PLZ
                    const plz1First2 = parseInt(plz1.substring(0, 2));
                    const plz2First2 = parseInt(plz2.substring(0, 2));
                    const plzDiff = Math.abs(plz1First2 - plz2First2);

                    // Sch√§tze Distanz (sehr grob)
                    let estimatedKm = plzDiff * 50; // Ca. 50km pro PLZ-Region-Differenz

                    if (plz1 === plz2) {
                        score += 3;
                        details.plzDistance = 0;
                        details.reasons.push('Gleiche PLZ');
                    } else if (plzDiff === 0) {
                        score += 2.5;
                        estimatedKm = 10;
                        details.plzDistance = estimatedKm;
                        details.reasons.push('Gleiche Region (< 10 km)');
                    } else if (plzDiff === 1) {
                        score += 2;
                        details.plzDistance = estimatedKm;
                        details.reasons.push(`Benachbarte Region (~${estimatedKm} km)`);
                    } else if (plzDiff <= 3) {
                        score += 1.5;
                        details.plzDistance = estimatedKm;
                        details.reasons.push(`Nahe Region (~${estimatedKm} km)`);
                    } else if (plzDiff <= 5) {
                        score += 1;
                        details.plzDistance = estimatedKm;
                        details.reasons.push(`Mittlere Distanz (~${estimatedKm} km)`);
                    } else {
                        score += 0.5;
                        details.plzDistance = estimatedKm;
                        details.reasons.push(`Weite Distanz (~${estimatedKm} km)`);
                    }
                }
            }

            // 2. Altersdifferenz (max 2 Punkte)
            maxScore += 2;
            const age1Field = profile1.fields.find(f =>
                f.question.toLowerCase() === 'alter' ||
                (f.question.toLowerCase().includes('alter') &&
                 !f.question.toLowerCase().includes('unterschied') &&
                 !f.question.toLowerCase().includes('gro√ü'))
            );
            const age2Field = profile2.fields.find(f =>
                f.question.toLowerCase() === 'alter' ||
                (f.question.toLowerCase().includes('alter') &&
                 !f.question.toLowerCase().includes('unterschied') &&
                 !f.question.toLowerCase().includes('gro√ü'))
            );
            if (age1Field && age2Field) {
                const age1 = parseInt(age1Field.answer) || 0;
                const age2 = parseInt(age2Field.answer) || 0;
                const ageDiff = Math.abs(age1 - age2);
                details.age = { age1, age2 };
                details.ageDiff = ageDiff;

                if (ageDiff <= 3) {
                    score += 2;
                    details.reasons.push(`Sehr √§hnliches Alter (¬±${ageDiff} Jahre)`);
                } else if (ageDiff <= 5) {
                    score += 1.8;
                    details.reasons.push(`√Ñhnliches Alter (¬±${ageDiff} Jahre)`);
                } else if (ageDiff <= 10) {
                    score += 1.5;
                    details.reasons.push(`Nahes Alter (¬±${ageDiff} Jahre)`);
                } else if (ageDiff <= 15) {
                    score += 1;
                    details.reasons.push(`Moderate Altersdifferenz (¬±${ageDiff} Jahre)`);
                } else if (ageDiff <= 20) {
                    score += 0.5;
                } else {
                    details.reasons.push(`Gro√üe Altersdifferenz (¬±${ageDiff} Jahre)`);
                }
            }

            // 3. Geschlechtspr√§ferenz (max 1 Punkt)
            maxScore += 1;
            const genderPref1 = profile1.fields.find(f =>
                f.question.toLowerCase().includes('geschlecht') &&
                (f.question.toLowerCase().includes('tandem') || f.question.toLowerCase().includes('partner'))
            );
            const genderPref2 = profile2.fields.find(f =>
                f.question.toLowerCase().includes('geschlecht') &&
                (f.question.toLowerCase().includes('tandem') || f.question.toLowerCase().includes('partner'))
            );

            const gender1 = profile1.fields.find(f => f.question.toLowerCase().includes('geschlecht') && !f.question.toLowerCase().includes('tandem') && !f.question.toLowerCase().includes('partner'));
            const gender2 = profile2.fields.find(f => f.question.toLowerCase().includes('geschlecht') && !f.question.toLowerCase().includes('tandem') && !f.question.toLowerCase().includes('partner'));

            if (gender1 && gender2 && (genderPref1 || genderPref2)) {
                const g1 = gender1.answer.toLowerCase();
                const g2 = gender2.answer.toLowerCase();
                const pref1 = genderPref1 ? genderPref1.answer.toLowerCase() : 'egal';
                const pref2 = genderPref2 ? genderPref2.answer.toLowerCase() : 'egal';

                // Pr√ºfe ob Pr√§ferenzen erf√ºllt sind
                const pref1Match = pref1.includes('egal') || pref1.includes('keine') || pref1.includes(g2);
                const pref2Match = pref2.includes('egal') || pref2.includes('keine') || pref2.includes(g1);

                if (pref1Match && pref2Match) {
                    score += 1;
                    details.genderPreference = 'match';
                    details.reasons.push('Geschlechtspr√§ferenz erf√ºllt');
                } else if (pref1Match || pref2Match) {
                    score += 0.5;
                    details.genderPreference = 'partial';
                } else {
                    details.genderPreference = 'mismatch';
                }
            }

            // 4. Interkulturell (max 1 Punkt - Bonus!)
            maxScore += 1;
            const gruppe1Field = profile1.fields.find(f =>
                f.question.toLowerCase().includes('gruppe') ||
                f.question.toLowerCase().includes('local') ||
                f.question.toLowerCase().includes('einwander') ||
                f.question.toLowerCase().includes('newcom')
            );
            const gruppe2Field = profile2.fields.find(f =>
                f.question.toLowerCase().includes('gruppe') ||
                f.question.toLowerCase().includes('local') ||
                f.question.toLowerCase().includes('einwander') ||
                f.question.toLowerCase().includes('newcom')
            );
            if (gruppe1Field && gruppe2Field) {
                const g1 = gruppe1Field.answer.toLowerCase();
                const g2 = gruppe2Field.answer.toLowerCase();
                details.gruppe1 = gruppe1Field.answer;
                details.gruppe2 = gruppe2Field.answer;
                const isIntercultural =
                    (g1.includes('local') && (g2.includes('einwander') || g2.includes('newcom'))) ||
                    ((g1.includes('einwander') || g1.includes('newcom')) && g2.includes('local'));
                if (isIntercultural) {
                    score += 1;
                    details.intercultural = true;
                    details.reasons.push('Interkulturell');
                }
            }

            // Speichere Geschlechter in Details f√ºr Anzeige
            if (gender1 && gender2) {
                details.gender1 = gender1.answer;
                details.gender2 = gender2.answer;
            }
            if (genderPref1 && genderPref2) {
                details.genderPref1 = genderPref1.answer;
                details.genderPref2 = genderPref2.answer;
            }

            // 5. Hobbys (max 2 Punkte) - MIT NORMALISIERUNG
            maxScore += 2;
            const hobbies1Field = profile1.fields.find(f => f.question.toLowerCase().includes('hobby'));
            const hobbies2Field = profile2.fields.find(f => f.question.toLowerCase().includes('hobby'));
            if (hobbies1Field && hobbies2Field) {
                // Normalisiere beide Hobby-Listen
                const normalized1 = normalizeHobbyInterest(hobbies1Field.answer);
                const normalized2 = normalizeHobbyInterest(hobbies2Field.answer);

                // Finde gemeinsame normalisierte Kategorien
                const commonHobbies = normalized1.filter(h => normalized2.includes(h));

                if (commonHobbies.length > 0) {
                    const hobbyScore = Math.min(2, commonHobbies.length * 0.4);
                    score += hobbyScore;
                    // Generische Formulierung statt spezifischer Hobbys
                    if (commonHobbies.length >= 3) {
                        details.reasons.push('Viele gemeinsame Hobbys und Interessen');
                    } else if (commonHobbies.length === 2) {
                        details.reasons.push('Mehrere gemeinsame Hobbys');
                    } else {
                        details.reasons.push('Gemeinsame Hobby-Interessen');
                    }
                }
            }

            // 6. Freizeit-Interessen (max 1.5 Punkte)
            maxScore += 1.5;
            const freetime1Field = profile1.fields.find(f =>
                f.question.toLowerCase().includes('freizeit') && !f.question.toLowerCase().includes('vermittler')
            );
            const freetime2Field = profile2.fields.find(f =>
                f.question.toLowerCase().includes('freizeit') && !f.question.toLowerCase().includes('vermittler')
            );
            if (freetime1Field && freetime2Field) {
                const ft1Words = freetime1Field.answer.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                const ft2Words = freetime2Field.answer.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                const commonWords = ft1Words.filter(w => ft2Words.includes(w));

                if (commonWords.length >= 3) {
                    score += 1.5;
                    details.reasons.push('√Ñhnliche Freizeitinteressen');
                } else if (commonWords.length >= 1) {
                    score += 0.75;
                }
            }

            // 7. Besondere Themeninteressen (max 1.5 Punkte)
            maxScore += 1.5;
            const interests1Field = profile1.fields.find(f =>
                f.question.toLowerCase().includes('themen') && f.question.toLowerCase().includes('interessieren')
            );
            const interests2Field = profile2.fields.find(f =>
                f.question.toLowerCase().includes('themen') && f.question.toLowerCase().includes('interessieren')
            );
            if (interests1Field && interests2Field) {
                const int1 = interests1Field.answer.toLowerCase();
                const int2 = interests2Field.answer.toLowerCase();

                // Check for common interest keywords
                const interestKeywords = ['politik', 'kunst', 'kultur', 'technologie', 'sport', 'musik', 'natur', 'reisen', 'essen', 'kochen', 'wissenschaft', 'geschichte', 'literatur'];
                const commonInterests = interestKeywords.filter(kw => int1.includes(kw) && int2.includes(kw));

                if (commonInterests.length >= 2) {
                    score += 1.5;
                    details.reasons.push('Mehrere gemeinsame Interessensgebiete');
                } else if (commonInterests.length === 1) {
                    score += 0.75;
                    details.reasons.push('Gemeinsame Interessensgebiete');
                }
            }

            // 8. Freundschafts-Werte (max 1.5 Punkte)
            maxScore += 1.5;
            const values1Field = profile1.fields.find(f =>
                f.question.toLowerCase().includes('freundschaft') && f.question.toLowerCase().includes('wichtig')
            );
            const values2Field = profile2.fields.find(f =>
                f.question.toLowerCase().includes('freundschaft') && f.question.toLowerCase().includes('wichtig')
            );
            if (values1Field && values2Field) {
                const val1 = values1Field.answer.toLowerCase();
                const val2 = values2Field.answer.toLowerCase();

                // Check for common values
                const valueKeywords = ['ehrlichkeit', 'vertrauen', 'respekt', 'toleranz', 'humor', 'offenheit', 'zuverl√§ssigkeit', 'loyalit√§t', 'treue'];
                const commonValues = valueKeywords.filter(kw => val1.includes(kw) && val2.includes(kw));

                if (commonValues.length >= 2) {
                    score += 1.5;
                    details.reasons.push('√Ñhnliche Wertvorstellungen in Freundschaften');
                } else if (commonValues.length === 1) {
                    score += 0.75;
                    details.reasons.push('Gemeinsame Wertvorstellungen');
                }
            }

            // 9. Tandem-Vorstellung (max 1 Punkt)
            maxScore += 1;
            const tandemVision1 = profile1.fields.find(f =>
                f.question.toLowerCase().includes('tandem') &&
                f.question.toLowerCase().includes('vorstellung') &&
                !f.question.toLowerCase().includes('geschlecht')
            );
            const tandemVision2 = profile2.fields.find(f =>
                f.question.toLowerCase().includes('tandem') &&
                f.question.toLowerCase().includes('vorstellung') &&
                !f.question.toLowerCase().includes('geschlecht')
            );
            if (tandemVision1 && tandemVision2) {
                const tv1Words = tandemVision1.answer.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                const tv2Words = tandemVision2.answer.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                const commonWords = tv1Words.filter(w => tv2Words.includes(w));

                if (commonWords.length >= 2) {
                    score += 1;
                    details.reasons.push('√Ñhnliche Tandem-Vorstellungen');
                } else if (commonWords.length >= 1) {
                    score += 0.5;
                }
            }

            // 10. Community-Event Interessen (max 0.5 Punkte)
            maxScore += 0.5;
            const event1Field = profile1.fields.find(f =>
                f.question.toLowerCase().includes('community-event') ||
                (f.question.toLowerCase().includes('event') && f.question.toLowerCase().includes('unternehmen'))
            );
            const event2Field = profile2.fields.find(f =>
                f.question.toLowerCase().includes('community-event') ||
                (f.question.toLowerCase().includes('event') && f.question.toLowerCase().includes('unternehmen'))
            );
            if (event1Field && event2Field) {
                const ev1Words = event1Field.answer.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                const ev2Words = event2Field.answer.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                const commonWords = ev1Words.filter(w => ev2Words.includes(w));

                if (commonWords.length >= 1) {
                    score += 0.5;
                }
            }

            // Normalisiere auf 5 Sterne
            const normalizedScore = Math.min(5, Math.round((score / maxScore) * 5));
            return {
                score: normalizedScore,
                details: details
            };
        }

        function updateSmartMatches() {
            const panel = document.getElementById('smart-match-panel');
            const container = document.getElementById('smart-match-suggestions');

            if (!panel || !container) return;

            // Hole verf√ºgbare Profile
            const matchedProfileIds = new Set();
            tandems.forEach(tandem => {
                matchedProfileIds.add(tandem.profile1.id);
                matchedProfileIds.add(tandem.profile2.id);
            });

            const availableProfiles = profiles.filter(profile => !matchedProfileIds.has(profile.id));

            if (availableProfiles.length < 2) {
                panel.style.display = 'none';
                return;
            }

            // Berechne alle m√∂glichen Paare und deren Qualit√§t
            // NUR interkulturelle Paare (Local ‚Üî Eingewanderte/Newcomer)
            const suggestions = [];
            for (let i = 0; i < availableProfiles.length; i++) {
                for (let j = i + 1; j < availableProfiles.length; j++) {
                    const p1 = availableProfiles[i];
                    const p2 = availableProfiles[j];
                    const suggestionId = `${p1.id}-${p2.id}`;

                    // Skip dismissed suggestions
                    if (dismissedSuggestions.has(suggestionId)) continue;

                    // Pr√ºfe ob es ein interkulturelles Paar ist
                    const gruppe1Field = p1.fields.find(f =>
                        f.question.toLowerCase().includes('gruppe') ||
                        f.question.toLowerCase().includes('local') ||
                        f.question.toLowerCase().includes('einwander') ||
                        f.question.toLowerCase().includes('newcom')
                    );
                    const gruppe2Field = p2.fields.find(f =>
                        f.question.toLowerCase().includes('gruppe') ||
                        f.question.toLowerCase().includes('local') ||
                        f.question.toLowerCase().includes('einwander') ||
                        f.question.toLowerCase().includes('newcom')
                    );

                    // Nur wenn beide ein Gruppenfeld haben
                    if (gruppe1Field && gruppe2Field) {
                        const g1 = gruppe1Field.answer.toLowerCase();
                        const g2 = gruppe2Field.answer.toLowerCase();

                        // Pr√ºfe ob es interkulturell ist (Local ‚Üî Eingewanderte/Newcomer)
                        const isIntercultural =
                            (g1.includes('local') && (g2.includes('einwander') || g2.includes('newcom'))) ||
                            ((g1.includes('einwander') || g1.includes('newcom')) && g2.includes('local'));

                        // Skip wenn NICHT interkulturell
                        if (!isIntercultural) continue;
                    } else {
                        // Skip wenn Gruppe nicht bestimmt werden kann
                        continue;
                    }

                    const quality = calculateMatchQuality(p1, p2);
                    suggestions.push({
                        id: suggestionId,
                        profile1: p1,
                        profile2: p2,
                        quality: quality.score,
                        details: quality.details
                    });
                }
            }

            // Sortiere nach Qualit√§t und nehme Top 3
            suggestions.sort((a, b) => b.quality - a.quality);
            const top3 = suggestions.slice(0, 3).filter(s => s.quality >= 3); // Nur Vorschl√§ge mit mind. 3 Sternen

            if (top3.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            container.innerHTML = top3.map((suggestion, index) => {
                const stars = '‚≠ê'.repeat(suggestion.quality);
                const reasons = suggestion.details.reasons || [];

                // Erstelle vollst√§ndigen Profil-Vergleich mit ALLEN Feldern
                // Sammle alle eindeutigen Fragen aus beiden Profilen
                const allQuestions = new Map();
                suggestion.profile1.fields.forEach(field => {
                    if (!allQuestions.has(field.question)) {
                        allQuestions.set(field.question, { p1: field.answer, p2: null });
                    }
                });
                suggestion.profile2.fields.forEach(field => {
                    if (allQuestions.has(field.question)) {
                        allQuestions.get(field.question).p2 = field.answer;
                    } else {
                        allQuestions.set(field.question, { p1: null, p2: field.answer });
                    }
                });

                // Erstelle Vergleichstabelle mit ALLEN Feldern
                const tableRows = Array.from(allQuestions.entries()).map(([question, answers], idx) => {
                    // Pr√ºfe ob es eine Gemeinsamkeit oder Unterschied ist
                    const isSame = answers.p1 && answers.p2 &&
                        answers.p1.toLowerCase().trim() === answers.p2.toLowerCase().trim();
                    const rowBg = idx % 2 === 0 ? '#ffffff' : '#f8fafc';
                    const highlightBg = isSame ? '#f0fdf4' : rowBg;

                    return `
                        <tr style="background: ${highlightBg};">
                            <td style="padding: 0.5rem; font-weight: 500; border-bottom: 1px solid #e2e8f0; vertical-align: top;">
                                ${question} ${isSame ? '‚úÖ' : ''}
                            </td>
                            <td style="padding: 0.5rem; border-bottom: 1px solid #e2e8f0; vertical-align: top;">
                                ${answers.p1 || '<span style="color: #94a3b8;">-</span>'}
                            </td>
                            <td style="padding: 0.5rem; border-bottom: 1px solid #e2e8f0; vertical-align: top;">
                                ${answers.p2 || '<span style="color: #94a3b8;">-</span>'}
                            </td>
                        </tr>
                    `;
                }).join('');

                const comparisonHTML = `
                    <div style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;" id="comparison-${suggestion.id}">
                        <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f0f9ff; border-radius: 6px; border: 1px solid #bae6fd;">
                            <div style="font-weight: 600; color: #0c4a6e; margin-bottom: 0.5rem; font-size: 0.9rem;">
                                üéØ Match-Gr√ºnde:
                            </div>
                            <ul style="margin: 0; padding-left: 1.5rem; color: #0369a1;">
                                ${reasons.map(reason => `<li style="margin: 0.25rem 0;">${reason}</li>`).join('')}
                            </ul>
                        </div>
                        <div style="max-height: 600px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 6px;">
                            <table style="width: 100%; font-size: 0.85rem; border-collapse: collapse;">
                                <thead style="position: sticky; top: 0; background: #f8fafc; z-index: 1;">
                                    <tr>
                                        <th style="padding: 0.5rem; text-align: left; width: 30%; border-bottom: 2px solid #cbd5e1;">Frage</th>
                                        <th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid #cbd5e1;">${suggestion.profile1.name}</th>
                                        <th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid #cbd5e1;">${suggestion.profile2.name}</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${tableRows}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;

                return `
                    <div id="suggestion-${suggestion.id}" style="background: white; border: 2px solid #cbd5e1; border-radius: 8px; padding: 0.75rem;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 1rem;">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; color: #1e293b; margin-bottom: 0.25rem; font-size: 1rem;">
                                    ${suggestion.profile1.name} ‚Üî ${suggestion.profile2.name}
                                </div>
                                <div style="font-size: 0.85rem; color: #64748b; margin-bottom: 0.5rem;">
                                    ${stars} ‚Ä¢ ${reasons.slice(0, 2).join(' ‚Ä¢ ')}${reasons.length > 2 ? '...' : ''}
                                </div>
                                <button class="btn btn-outline btn-small" onclick="toggleComparisonDetails('${suggestion.id}')" style="font-size: 0.8rem;">
                                    üìä Vergleich anzeigen
                                </button>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <button class="btn btn-primary btn-small" onclick="quickMatch('${suggestion.profile1.id}', '${suggestion.profile2.id}')" style="white-space: nowrap;">
                                    ‚ú® Quick Match
                                </button>
                                <button class="btn btn-outline btn-small" onclick="dismissSuggestion('${suggestion.id}')" style="white-space: nowrap; color: #64748b;">
                                    ‚úï Ablehnen
                                </button>
                            </div>
                        </div>
                        ${comparisonHTML}
                    </div>
                `;
            }).join('');
        }

        function toggleComparisonDetails(suggestionId) {
            const comparison = document.getElementById(`comparison-${suggestionId}`);
            const button = event.target;

            if (comparison.style.display === 'none' || comparison.style.display === '') {
                comparison.style.display = 'block';
                button.textContent = 'üìä Vergleich verbergen';
            } else {
                comparison.style.display = 'none';
                button.textContent = 'üìä Vergleich anzeigen';
            }
        }

        function dismissSuggestion(suggestionId) {
            dismissedSuggestions.add(suggestionId);
            const suggestionEl = document.getElementById(`suggestion-${suggestionId}`);
            if (suggestionEl) {
                suggestionEl.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => {
                    updateSmartMatches();
                }, 300);
            }

            // F√ºge CSS-Animation hinzu falls noch nicht vorhanden
            if (!document.getElementById('fadeout-style')) {
                const style = document.createElement('style');
                style.id = 'fadeout-style';
                style.textContent = `
                    @keyframes fadeOut {
                        to {
                            opacity: 0;
                            transform: translateX(-20px);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function quickMatch(profileId1, profileId2) {
            console.log('‚ö° Quick Match:', profileId1, profileId2);

            // Setze selectedProfiles
            selectedProfiles = [parseFloat(profileId1), parseFloat(profileId2)];

            // Rufe normale Matching-Funktion auf
            matchSelectedProfiles();

            // Aktualisiere UI
            loadAvailableProfiles();
            updateSmartMatches();
        }

        function checkAchievements() {
            const container = document.getElementById('achievements-container');
            if (!container) return;

            const unlockedAchievements = gamificationStats.achievements || [];

            container.innerHTML = ACHIEVEMENTS.map(achievement => {
                const isUnlocked = unlockedAchievements.includes(achievement.id) || achievement.check(gamificationStats);

                // Unlock Achievement wenn noch nicht unlocked
                if (isUnlocked && !unlockedAchievements.includes(achievement.id)) {
                    unlockedAchievements.push(achievement.id);
                    gamificationStats.achievements = unlockedAchievements;
                    saveGamificationStats();

                    // Zeige Achievement-Notification
                    showAchievementUnlock(achievement);
                }

                return `
                    <div style="
                        background: ${isUnlocked ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)'};
                        border: 2px solid ${isUnlocked ? 'white' : 'rgba(255,255,255,0.3)'};
                        border-radius: 8px;
                        padding: 0.5rem;
                        text-align: center;
                        min-width: 70px;
                        ${isUnlocked ? '' : 'opacity: 0.5; filter: grayscale(1);'}
                    " title="${achievement.description}">
                        <div style="font-size: 1.5rem;">${achievement.icon}</div>
                        <div style="font-size: 0.7rem; margin-top: 0.25rem;">${achievement.name}</div>
                    </div>
                `;
            }).join('');
        }

        function showAchievementUnlock(achievement) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 2rem;
                border-radius: 12px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                z-index: 10001;
                text-align: center;
                animation: achievementPop 0.5s ease;
            `;

            notification.innerHTML = `
                <div style="font-size: 4rem; margin-bottom: 1rem;">${achievement.icon}</div>
                <h2 style="margin: 0 0 0.5rem 0;">Achievement Unlocked!</h2>
                <h3 style="margin: 0 0 0.5rem 0; color: #FFB000;">${achievement.name}</h3>
                <p style="margin: 0; opacity: 0.9;">${achievement.description}</p>
            `;

            document.body.appendChild(notification);

            // Entferne nach 3 Sekunden
            setTimeout(() => {
                notification.style.animation = 'achievementPop 0.3s ease reverse';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function celebrateMatch(qualityScore) {
            // Konfetti-Effekt
            createConfetti(qualityScore >= 4 ? 100 : 50);

            // Motivierende Nachricht
            const messages = {
                5: ['üéâ Perfektes Match!', 'Unglaublich! 5 Sterne!', '‚ú® Absolut perfekt!'],
                4: ['üåü Gro√üartig!', 'Super Match!', 'üí´ Hervorragend!'],
                3: ['üëç Gutes Match!', 'Passt gut!', '‚úÖ Sch√∂nes Tandem!'],
                2: ['üëå Passt!', 'Solides Match!'],
                1: ['‚úì Match erstellt!']
            };

            const messageArray = messages[qualityScore] || messages[3];
            const randomMessage = messageArray[Math.floor(Math.random() * messageArray.length)];

            showNotification(`${randomMessage} Du hast gerade 2 Menschen zusammengebracht!`, 'success', 3000);
        }

        function createConfetti(count = 50) {
            for (let i = 0; i < count; i++) {
                const confetti = document.createElement('div');
                confetti.style.cssText = `
                    position: fixed;
                    width: 10px;
                    height: 10px;
                    background: ${['#FFB000', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A'][Math.floor(Math.random() * 5)]};
                    top: -10px;
                    left: ${Math.random() * 100}%;
                    opacity: 1;
                    transform: rotate(${Math.random() * 360}deg);
                    animation: confettiFall ${2 + Math.random() * 3}s linear;
                    z-index: 10000;
                    pointer-events: none;
                `;

                document.body.appendChild(confetti);

                setTimeout(() => confetti.remove(), 5000);
            }

            // F√ºge CSS-Animation hinzu falls noch nicht vorhanden
            if (!document.getElementById('confetti-style')) {
                const style = document.createElement('style');
                style.id = 'confetti-style';
                style.textContent = `
                    @keyframes confettiFall {
                        to {
                            top: 100%;
                            transform: translateY(100vh) rotate(${Math.random() * 720}deg);
                            opacity: 0;
                        }
                    }
                    @keyframes achievementPop {
                        0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
                        50% { transform: translate(-50%, -50%) scale(1.1); }
                        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function undoLastMatch() {
            if (undoStack.length === 0) {
                showNotification('Nichts zum R√ºckg√§ngig machen', 'info');
                return;
            }

            const lastAction = undoStack.pop();

            // Stelle Tandem wieder her
            tandems.push(lastAction.tandem);
            saveTandems();

            // Aktualisiere Stats
            gamificationStats.totalMatches--;
            gamificationStats.todayMatches--;
            if (gamificationStats.qualityScores.length > 0) {
                gamificationStats.qualityScores.pop();
            }
            saveGamificationStats();

            // Aktualisiere UI
            updateMatchedPairs();
            updateStatistics();
            loadAvailableProfiles();
            updateGamificationUI();
            updateSmartMatches();
            checkAchievements();

            showNotification(`‚Ü©Ô∏è Tandem "${lastAction.tandem.name}" wiederhergestellt`, 'success');

            // Disable Undo-Button
            const undoBtn = document.getElementById('undo-button');
            if (undoBtn && undoStack.length === 0) {
                undoBtn.disabled = true;
                undoBtn.style.opacity = '0.5';
            }
        }

        function enableUndo(tandem) {
            // F√ºge zur Undo-Stack hinzu
            undoStack.push({
                tandem: { ...tandem },
                timestamp: Date.now()
            });

            // Aktiviere Undo-Button
            const undoBtn = document.getElementById('undo-button');
            if (undoBtn) {
                undoBtn.disabled = false;
                undoBtn.style.opacity = '1';

                // Starte 5-Sekunden Timer
                let countdown = 5;
                const originalText = undoBtn.textContent;

                if (undoTimer) clearInterval(undoTimer);

                undoTimer = setInterval(() => {
                    countdown--;
                    undoBtn.textContent = `‚Ü©Ô∏è R√ºckg√§ngig (${countdown}s)`;

                    if (countdown <= 0) {
                        clearInterval(undoTimer);
                        undoBtn.textContent = originalText;
                        undoBtn.disabled = true;
                        undoBtn.style.opacity = '0.5';
                        undoStack = []; // L√∂sche Undo-Stack
                    }
                }, 1000);
            }
        }

        function saveGamificationStats() {
            localStorage.setItem('swaf_gamification_stats', JSON.stringify(gamificationStats));
        }

        function onMatchCreated(tandem, qualityScore) {
            // Aktualisiere Stats
            gamificationStats.totalMatches++;
            gamificationStats.todayMatches++;
            gamificationStats.qualityScores = gamificationStats.qualityScores || [];
            gamificationStats.qualityScores.push(qualityScore);

            // Aktualisiere Streak
            const today = new Date().toDateString();
            if (gamificationStats.lastMatchDate !== today) {
                gamificationStats.streak = 1;
                gamificationStats.lastMatchDate = today;
            } else {
                gamificationStats.streak++;
            }

            saveGamificationStats();

            // UI Updates
            updateGamificationUI();
            checkAchievements();
            updateSmartMatches();
            celebrateMatch(qualityScore);
            enableUndo(tandem);
        }

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            // Escape: Schlie√üe Full-Screen
            if (e.key === 'Escape') {
                const modal = document.getElementById('fullscreen-map-modal');
                if (modal && modal.style.display === 'block') {
                    closeFullScreenMap();
                }
            }

            // Space: √ñffne Full-Screen (nur wenn nicht in Input)
            if (e.key === ' ' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                const tabPanel = document.getElementById('tab-1');
                if (tabPanel && tabPanel.style.display !== 'none') {
                    e.preventDefault();
                    openFullScreenMap();
                }
            }

            // Ctrl+Z: Undo
            if (e.ctrlKey && e.key === 'z') {
                const undoBtn = document.getElementById('undo-button');
                if (undoBtn && !undoBtn.disabled) {
                    e.preventDefault();
                    undoLastMatch();
                }
            }
        });

        // ===============================
        // FULL-SCREEN KARTEN FUNKTIONEN
        // ===============================
        let fullScreenMap = null;
        let fullScreenMarkers = [];
        let fullScreenLines = [];
        let fullScreenSelectedProfiles = [];

        function openFullScreenMap() {
            console.log('üñ•Ô∏è √ñffne Full-Screen Kartenansicht...');

            const modal = document.getElementById('fullscreen-map-modal');
            modal.style.display = 'block';

            // Warte einen Moment, damit das Modal gerendert wird
            setTimeout(() => {
                loadFullScreenMap();
            }, 100);
        }

        function closeFullScreenMap() {
            console.log('‚úï Schlie√üe Full-Screen Kartenansicht...');

            const modal = document.getElementById('fullscreen-map-modal');
            modal.style.display = 'none';

            // Cleanup
            if (fullScreenMap) {
                fullScreenMap.remove();
                fullScreenMap = null;
            }
            fullScreenMarkers = [];
            fullScreenLines = [];
            fullScreenSelectedProfiles = [];
        }

        async function loadFullScreenMap() {
            console.log('üó∫Ô∏è Lade Full-Screen Karte...');

            // Hole Filter-Werte
            const search = document.getElementById('fs-profile-search').value.toLowerCase().trim();
            const searchScope = document.getElementById('fs-search-scope')?.value || 'all';
            const specificField = document.getElementById('fs-specific-field-select')?.value || '';
            const genderFilter = document.getElementById('fs-filter-gender').value.toLowerCase();
            const gruppeFilter = document.getElementById('fs-filter-gruppe').value.toLowerCase();
            const ageMin = parseInt(document.getElementById('fs-filter-age-min').value) || 0;
            const ageMax = parseInt(document.getElementById('fs-filter-age-max').value) || 999;

            // Zeige/Verstecke spezifisches Feld-Dropdown
            const fsSpecificFieldContainer = document.getElementById('fs-specific-field-container');
            if (fsSpecificFieldContainer) {
                if (searchScope === 'specific') {
                    fsSpecificFieldContainer.style.display = 'block';
                    // F√ºlle das Dropdown mit verf√ºgbaren Feldern
                    const fsSelect = document.getElementById('fs-specific-field-select');
                    if (fsSelect && fsSelect.options.length <= 1) {
                        populateFieldDropdown(); // Nutze die bestehende Funktion
                        // Kopiere Optionen zum Full-Screen Select
                        const mainSelect = document.getElementById('specific-field-select');
                        if (mainSelect) {
                            fsSelect.innerHTML = mainSelect.innerHTML;
                        }
                    }
                } else {
                    fsSpecificFieldContainer.style.display = 'none';
                }
            }

            // Initialisiere Karte wenn noch nicht vorhanden
            if (!fullScreenMap) {
                fullScreenMap = L.map('fullscreen-map-container').setView([51.1657, 10.4515], 6);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(fullScreenMap);
            }

            // L√∂sche alte Marker und Linien
            fullScreenMarkers.forEach(marker => fullScreenMap.removeLayer(marker));
            fullScreenLines.forEach(line => fullScreenMap.removeLayer(line));
            fullScreenMarkers = [];
            fullScreenLines = [];

            // Sammle gematche Profile IDs
            const matchedProfileIds = new Set();
            tandems.forEach(tandem => {
                matchedProfileIds.add(tandem.profile1.id);
                matchedProfileIds.add(tandem.profile2.id);
            });

            // Verf√ºgbare Profile (noch nicht gematcht)
            const availableProfiles = profiles.filter(profile => !matchedProfileIds.has(profile.id));

            const bounds = [];
            const plzOffsets = {}; // Tracking f√ºr PLZ-Duplikate

            // 1. Zeichne VERF√úGBARE Profile
            for (const profile of availableProfiles) {
                // Anwenden der Filter
                if (!matchesFilters(profile, search, genderFilter, gruppeFilter, ageMin, ageMax, searchScope, specificField)) {
                    continue;
                }

                const coords = await getProfileCoordinates(profile, plzOffsets);
                if (!coords) continue;

                await renderProfileMarker(profile, coords, false);
                bounds.push(coords);
            }

            // 2. Zeichne GEMATCHTE Tandems
            for (const tandem of tandems) {
                const profile1 = tandem.profile1;
                const profile2 = tandem.profile2;

                // Filter anwenden
                const match1 = matchesFilters(profile1, search, genderFilter, gruppeFilter, ageMin, ageMax, searchScope, specificField);
                const match2 = matchesFilters(profile2, search, genderFilter, gruppeFilter, ageMin, ageMax, searchScope, specificField);

                if (!match1 && !match2) continue; // Beide passen nicht

                const coords1 = await getProfileCoordinates(profile1, plzOffsets);
                const coords2 = await getProfileCoordinates(profile2, plzOffsets);

                if (coords1 && match1) {
                    await renderProfileMarker(profile1, coords1, true, tandem.id);
                    bounds.push(coords1);
                }

                if (coords2 && match2) {
                    await renderProfileMarker(profile2, coords2, true, tandem.id);
                    bounds.push(coords2);
                }

                // Zeichne Verbindungslinie wenn beide sichtbar sind
                if (coords1 && coords2 && match1 && match2) {
                    const line = L.polyline([coords1, coords2], {
                        color: '#6B46C1',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 10'
                    }).addTo(fullScreenMap);

                    line.bindPopup(`
                        <div style="text-align: center;">
                            <strong style="color: #6B46C1;">Tandem: ${tandem.name}</strong><br>
                            <small>${profile1.name} ‚Üî ${profile2.name}</small><br>
                            <button class="btn btn-outline btn-small" onclick="dissolveTandemFromFullScreen('${tandem.id}')" style="margin-top: 0.5rem;">
                                üóëÔ∏è Tandem aufl√∂sen
                            </button>
                        </div>
                    `);

                    fullScreenLines.push(line);
                }
            }

            // Passe Kartenansicht an alle Marker an
            if (bounds.length > 0) {
                fullScreenMap.fitBounds(bounds, { padding: [50, 50] });
            }

            updateFullScreenSelectionStatus();
            console.log(`‚úÖ ${fullScreenMarkers.length} Profile auf Full-Screen Karte angezeigt`);
        }

        function matchesFilters(profile, search, genderFilter, gruppeFilter, ageMin, ageMax, searchScope = 'all', specificField = '') {
            // Erweiterte Suche
            const matchesSearch = searchInProfile(profile, search, searchScope, specificField);

            // Geschlecht-Filter - ROBUSTER
            let matchesGender = true;
            if (genderFilter) {
                const genderField = profile.fields.find(f =>
                    f.question.toLowerCase().includes('geschlecht') &&
                    !f.question.toLowerCase().includes('tandem') &&
                    !f.question.toLowerCase().includes('partner')
                );
                if (genderField) {
                    const profileGender = genderField.answer.toLowerCase().trim();
                    matchesGender = profileGender.includes(genderFilter);
                }
                // Kein Feld ‚Üí trotzdem anzeigen
            }

            // Gruppen-Filter - ROBUSTER
            let matchesGruppe = true;
            if (gruppeFilter) {
                const gruppeField = profile.fields.find(f =>
                    f.question.toLowerCase().includes('gruppe') ||
                    f.question.toLowerCase().includes('local') ||
                    f.question.toLowerCase().includes('einwander') ||
                    f.question.toLowerCase().includes('newcom')
                );
                if (gruppeField) {
                    const profileGruppe = gruppeField.answer.toLowerCase().trim();
                    // Erweiterte Matching-Logik f√ºr Eingewanderte/Newcomer
                    if (gruppeFilter === 'einwander') {
                        matchesGruppe = profileGruppe.includes('einwander') || profileGruppe.includes('newcom');
                    } else {
                        matchesGruppe = profileGruppe.includes(gruppeFilter);
                    }
                }
                // Kein Feld ‚Üí trotzdem anzeigen
            }

            // Alter-Filter
            let matchesAge = true;
            if (ageMin > 0 || ageMax < 999) {
                const ageField = profile.fields.find(f =>
                    f.question.toLowerCase() === 'alter' ||
                    (f.question.toLowerCase().includes('alter') &&
                     !f.question.toLowerCase().includes('unterschied') &&
                     !f.question.toLowerCase().includes('gro√ü')) ||
                    f.question.toLowerCase().includes('geburtstag')
                );
                if (ageField) {
                    let profileAge = parseInt(ageField.answer) || 0;
                    if (profileAge === 0 && ageField.answer.includes('/')) {
                        const parts = ageField.answer.split(/[\/\.]/);
                        if (parts.length === 3) {
                            const year = parseInt(parts[2]);
                            const currentYear = new Date().getFullYear();
                            profileAge = currentYear - year;
                        }
                    }
                    if (profileAge > 0) {
                        matchesAge = profileAge >= ageMin && profileAge <= ageMax;
                    }
                }
                // Kein Altersfeld ‚Üí trotzdem anzeigen
            }

            return matchesSearch && matchesGender && matchesGruppe && matchesAge;
        }

        async function getProfileCoordinates(profile, plzOffsets) {
            const plzField = profile.fields.find(f =>
                f.question.toLowerCase().includes('postleitzahl') ||
                f.question.toLowerCase().includes('plz')
            );

            if (!plzField) return null;

            const plz = extractPLZ(plzField.answer);
            if (!plz) return null;

            let coords = await getPLZCoordinates(plz);
            if (!coords) return null;

            // Behandle PLZ-Duplikate
            if (!plzOffsets[plz]) {
                plzOffsets[plz] = 0;
            } else {
                const offsetCount = plzOffsets[plz];
                const angle = (offsetCount * 45) % 360;
                const distance = 0.005;

                const latOffset = distance * Math.cos(angle * Math.PI / 180);
                const lngOffset = distance * Math.sin(angle * Math.PI / 180);

                coords = [coords[0] + latOffset, coords[1] + lngOffset];
            }
            plzOffsets[plz]++;

            return coords;
        }

        async function renderProfileMarker(profile, coords, isMatched, tandemId = null) {
            // Extrahiere Profilinformationen
            const alter = profile.fields.find(f =>
                f.question.toLowerCase() === 'alter' ||
                (f.question.toLowerCase().includes('alter') &&
                 !f.question.toLowerCase().includes('unterschied') &&
                 !f.question.toLowerCase().includes('gro√ü'))
            )?.answer || 'N/A';
            const geschlecht = profile.fields.find(f =>
                f.question.toLowerCase().includes('geschlecht') &&
                !f.question.toLowerCase().includes('tandem') &&
                !f.question.toLowerCase().includes('partner')
            )?.answer || 'N/A';
            const gruppe = profile.fields.find(f =>
                f.question.toLowerCase().includes('gruppe') ||
                f.question.toLowerCase().includes('local') ||
                f.question.toLowerCase().includes('einwander') ||
                f.question.toLowerCase().includes('newcom')
            )?.answer || 'N/A';
            const plzField = profile.fields.find(f =>
                f.question.toLowerCase().includes('postleitzahl') ||
                f.question.toLowerCase().includes('plz')
            );
            const plz = plzField ? extractPLZ(plzField.answer) : 'N/A';

            // Bestimme Marker-Farbe
            const isSelected = fullScreenSelectedProfiles.some(id => id == profile.id);

            let markerColor;
            if (isMatched) {
                markerColor = '#6B46C1'; // Lila f√ºr gematchte Profile
            } else if (isSelected) {
                markerColor = '#C30045'; // Rot f√ºr ausgew√§hlte Profile
            } else {
                // Grundfarbe nach Gruppe
                if (gruppe.toLowerCase().includes('local')) {
                    markerColor = '#FFB000'; // Gold f√ºr Locals
                } else if (gruppe.toLowerCase().includes('einwander')) {
                    markerColor = '#009892'; // Teal f√ºr Einwanderer*innen
                } else {
                    markerColor = '#009892'; // Standard: Teal
                }
            }

            // Erstelle Custom Icon
            const customIcon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="background-color: ${markerColor}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">${profile.name.substring(0, 1).toUpperCase()}</div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });

            // Erstelle vollst√§ndige Profil-Details
            const allFieldsHTML = profile.fields.map(field => `
                <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: #f5f5f5; border-radius: 4px;">
                    <strong style="color: var(--swaf-teal); font-size: 0.85rem;">${field.question}</strong>
                    <div style="margin-top: 0.25rem; font-size: 0.9rem;">${field.answer}</div>
                </div>
            `).join('');

            // Popup-Inhalt
            let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                    <h4 style="margin: 0 0 0.5rem 0; color: ${markerColor};">${profile.name}</h4>
                    <table style="width: 100%; font-size: 0.9rem; margin-bottom: 0.5rem;">
                        <tr><td><strong>Alter:</strong></td><td>${alter}</td></tr>
                        <tr><td><strong>Geschlecht:</strong></td><td>${geschlecht}</td></tr>
                        <tr><td><strong>Gruppe:</strong></td><td>${gruppe}</td></tr>
                        <tr><td><strong>PLZ:</strong></td><td>${plz}</td></tr>
                    </table>

                    <button class="btn btn-outline btn-small"
                        onclick="toggleFSPopupDetails('${profile.id}')"
                        id="fs-toggle-details-${profile.id}"
                        style="width: 100%; margin-bottom: 0.5rem; font-size: 0.85rem;">
                        üìã Alle Felder anzeigen
                    </button>

                    <div id="fs-popup-details-${profile.id}" style="display: none; max-height: 300px; overflow-y: auto; margin-bottom: 0.5rem; padding: 0.5rem; background: white; border: 1px solid #ddd; border-radius: 4px;">
                        ${allFieldsHTML}
                    </div>
            `;

            if (isMatched) {
                // F√ºr gematchte Profile: Tandem aufl√∂sen Button
                const tandem = tandems.find(t => t.id == tandemId);
                popupContent += `
                    <div style="background: #f0e6ff; padding: 0.5rem; border-radius: 4px; margin-bottom: 0.5rem;">
                        <strong style="color: #6B46C1;">‚úì Bereits gematcht</strong><br>
                        <small>Tandem: ${tandem ? tandem.name : 'N/A'}</small>
                    </div>
                    <button class="btn btn-outline" onclick="dissolveTandemFromFullScreen('${tandemId}')" style="width: 100%;">
                        üóëÔ∏è Tandem aufl√∂sen
                    </button>
                `;
            } else {
                // F√ºr verf√ºgbare Profile: Auswahl Button
                popupContent += `
                    <button class="btn btn-primary" onclick="toggleFSProfileSelection('${profile.id}')" style="width: 100%;">
                        ${isSelected ? '‚úì Ausgew√§hlt' : 'Ausw√§hlen'}
                    </button>
                `;
            }

            popupContent += `</div>`;

            // Erstelle Marker
            const marker = L.marker(coords, { icon: customIcon }).addTo(fullScreenMap);
            marker.bindPopup(popupContent, { maxWidth: 450 });
            fullScreenMarkers.push(marker);
        }

        function toggleFSPopupDetails(profileId) {
            const detailsDiv = document.getElementById(`fs-popup-details-${profileId}`);
            const toggleBtn = document.getElementById(`fs-toggle-details-${profileId}`);

            if (detailsDiv && toggleBtn) {
                if (detailsDiv.style.display === 'none' || detailsDiv.style.display === '') {
                    detailsDiv.style.display = 'block';
                    toggleBtn.textContent = 'üìã Alle Felder verbergen';
                } else {
                    detailsDiv.style.display = 'none';
                    toggleBtn.textContent = 'üìã Alle Felder anzeigen';
                }
            }
        }

        function toggleFSProfileSelection(profileId) {
            const numericId = typeof profileId === 'string' ? parseFloat(profileId) : profileId;
            const index = fullScreenSelectedProfiles.findIndex(id => {
                const numericSelectedId = typeof id === 'string' ? parseFloat(id) : id;
                return numericSelectedId === numericId;
            });

            if (index > -1) {
                fullScreenSelectedProfiles.splice(index, 1);
            } else {
                if (fullScreenSelectedProfiles.length >= 2) {
                    showNotification('Maximal 2 Profile k√∂nnen ausgew√§hlt werden', 'warning');
                    return;
                }
                fullScreenSelectedProfiles.push(numericId);
            }

            loadFullScreenMap();
        }

        function clearFullScreenSelection() {
            fullScreenSelectedProfiles = [];
            loadFullScreenMap();
        }

        function updateFullScreenSelectionStatus() {
            const statusSpan = document.getElementById('fs-selection-status');
            const matchBtn = document.getElementById('fs-create-match-btn');

            statusSpan.textContent = `${fullScreenSelectedProfiles.length} von 2 Profilen ausgew√§hlt`;

            if (fullScreenSelectedProfiles.length === 2) {
                matchBtn.disabled = false;
            } else {
                matchBtn.disabled = true;
            }
        }

        function filterFullScreenMap() {
            loadFullScreenMap();
        }

        function clearFullScreenFilters() {
            document.getElementById('fs-profile-search').value = '';
            if (document.getElementById('fs-search-scope')) {
                document.getElementById('fs-search-scope').value = 'all';
            }
            if (document.getElementById('fs-specific-field-container')) {
                document.getElementById('fs-specific-field-container').style.display = 'none';
            }
            document.getElementById('fs-filter-gender').value = '';
            document.getElementById('fs-filter-gruppe').value = '';
            document.getElementById('fs-filter-age-min').value = '';
            document.getElementById('fs-filter-age-max').value = '';
            filterFullScreenMap();
            showNotification('‚úÖ Alle Filter zur√ºckgesetzt', 'success', 2000);
        }

        function createMatchFromFullScreen() {
            if (fullScreenSelectedProfiles.length !== 2) {
                showNotification('Bitte w√§hle genau 2 Profile aus', 'warning');
                return;
            }

            // Setze die globalen selectedProfiles
            selectedProfiles = [...fullScreenSelectedProfiles];

            // Schlie√üe das Modal tempor√§r
            const modal = document.getElementById('fullscreen-map-modal');
            const wasOpen = modal.style.display === 'block';

            // Rufe die normale Matching-Funktion auf
            matchSelectedProfiles();

            // L√∂sche Auswahl und lade Karte neu
            fullScreenSelectedProfiles = [];

            if (wasOpen) {
                loadFullScreenMap();
            }
        }

        function dissolveTandemFromFullScreen(tandemId) {
            const tandem = tandems.find(t => t.id == tandemId);

            if (!tandem) {
                showNotification('Tandem nicht gefunden', 'error');
                return;
            }

            if (confirm(`Tandem "${tandem.name}" wirklich aufl√∂sen?`)) {
                tandems = tandems.filter(t => t.id != tandemId);
                saveTandems();
                updateMatchedPairs();
                updateStatistics();
                loadAvailableProfiles();

                showNotification(`‚úÖ Tandem "${tandem.name}" aufgel√∂st`, 'success');
                loadFullScreenMap();
            }
        }


        // ===============================
        // MATCHING-FUNKTIONEN
        // ===============================
        function loadAvailableProfiles() {
            console.log('üîÑ Lade verf√ºgbare Profile f√ºr Matching...');
            console.log('üìä Anzahl Profile im Array:', profiles.length);

            const container = document.getElementById('available-profiles');

            if (!container) {
                console.error('‚ùå Container "available-profiles" nicht gefunden!');
                return;
            }

            // Filtere Profile: Entferne bereits gematchte Profile
            const matchedProfileIds = new Set();
            tandems.forEach(tandem => {
                matchedProfileIds.add(tandem.profile1.id);
                matchedProfileIds.add(tandem.profile2.id);
            });

            const availableProfiles = profiles.filter(profile => !matchedProfileIds.has(profile.id));

            console.log('üìä Gematchte Profile:', matchedProfileIds.size, 'Verf√ºgbare Profile:', availableProfiles.length);

            if (availableProfiles.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--swaf-dark-gray);">
                        ${profiles.length === 0
                        ? 'Keine Profile verf√ºgbar. Bitte zuerst Profile sammeln.'
                        : 'Alle Profile sind bereits zu Tandems gematcht!'
                    }
                        ${matchedProfileIds.size > 0
                        ? `<p style="margin-top: 1rem; font-size: 0.9rem;"><strong>${matchedProfileIds.size} Profile bereits gematcht:</strong><br>${tandems.map(t => t.name).join('<br>')}</p>`
                        : ''
                    }
                    </div>
                `;
                return;
            }

            console.log('‚úÖ Erstelle verf√ºgbare Profile-Liste f√ºr Matching...');

            try {
                container.innerHTML = availableProfiles.map((profile, index) => {
                    console.log(`üìã Verf√ºgbares Profil ${index + 1}: ${profile.name} (${profile.fields.length} Felder) ID: ${profile.id}`);

                    // Pr√ºfe ob dieses Profil bereits ausgew√§hlt ist
                    const isSelected = selectedProfiles.some(id => id == profile.id);
                    const selectedClass = isSelected ? 'selected' : '';

                    console.log(`  -> Ist ausgew√§hlt: ${isSelected} (${selectedClass})`);

                    // Extrahiere Alter, Geschlecht und Gruppe f√ºr die Anzeige
                    const ageField = profile.fields.find(f =>
                        f.question.toLowerCase() === 'alter' ||
                        (f.question.toLowerCase().includes('alter') &&
                         !f.question.toLowerCase().includes('unterschied') &&
                         !f.question.toLowerCase().includes('gro√ü')) ||
                        f.question.toLowerCase().includes('geburtstag')
                    );
                    const genderField = profile.fields.find(f =>
                        f.question.toLowerCase().includes('geschlecht') &&
                        !f.question.toLowerCase().includes('tandem') &&
                        !f.question.toLowerCase().includes('partner')
                    );
                    const gruppeField = profile.fields.find(f =>
                        f.question.toLowerCase().includes('gruppe') ||
                        f.question.toLowerCase().includes('local') ||
                        f.question.toLowerCase().includes('einwander') ||
                        f.question.toLowerCase().includes('newcom')
                    );

                    const ageText = ageField ? ` ‚Ä¢ ${ageField.answer}` : '';
                    const genderText = genderField ? ` ‚Ä¢ ${genderField.answer}` : '';

                    // Bestimme Gruppenfarbe und Badge
                    let gruppeColor = '#009892'; // Standard: Teal (Eingewanderte)
                    let gruppeLabel = 'Eingewanderte*r';
                    if (gruppeField) {
                        const gruppe = gruppeField.answer.toLowerCase();
                        if (gruppe.includes('local')) {
                            gruppeColor = '#FFB000'; // Gelb/Gold f√ºr Locals
                            gruppeLabel = 'Local';
                        } else if (gruppe.includes('einwander') || gruppe.includes('newcom')) {
                            gruppeColor = '#009892'; // Teal f√ºr Einwanderer*innen
                            gruppeLabel = 'Eingewanderte*r';
                        }
                    }
                    const gruppeBadge = gruppeField ? `<span style="display: inline-block; padding: 2px 8px; background: ${gruppeColor}; color: white; border-radius: 12px; font-size: 0.75rem; font-weight: 600; margin-left: 0.5rem;">${gruppeLabel}</span>` : '';

                    // Erstelle Detailansicht mit allen relevanten Feldern
                    const detailsHTML = createProfileDetailsHTML(profile);

                    return `
                        <div class="profile-item ${selectedClass}" data-profile-id="${profile.id}" data-gruppe="${gruppeField ? gruppeField.answer : ''}">
                            <div onclick="selectProfile('${profile.id}')">
                                <div style="display: flex; align-items: center; justify-content: space-between;">
                                    <strong>${profile.name}</strong>
                                    ${gruppeBadge}
                                </div>
                                <p><small>${profile.fields.length} Felder${ageText}${genderText}</small></p>
                                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--swaf-dark-gray);">
                                    ${profile.fields.slice(0, 3).map(f => f.question).join(', ')}
                                    ${profile.fields.length > 3 ? '...' : ''}
                                </div>
                            </div>
                            <span class="expand-toggle" onclick="toggleProfileDetails(event, '${profile.id}')">
                                üìã Details anzeigen
                            </span>
                            <div class="profile-details" id="details-${profile.id}">
                                ${detailsHTML}
                            </div>
                        </div>
                    `;
                }).join('');

                console.log('‚úÖ Profile-Liste erfolgreich erstellt');
                console.log('üìä Bereits ausgew√§hlte Profile:', selectedProfiles);

                // Zeige Info √ºber verf√ºgbare vs. gematchte Profile
                const message = matchedProfileIds.size > 0
                    ? `‚úÖ ${availableProfiles.length} verf√ºgbare Profile geladen (${matchedProfileIds.size} bereits gematcht)`
                    : `‚úÖ ${availableProfiles.length} Profile f√ºr Matching geladen`;
                showNotification(message, 'success', 3000);

                // Wende Filter an, falls welche gesetzt sind
                if (currentView === 'list') {
                    setTimeout(() => filterProfiles(), 100);
                }

            } catch (error) {
                console.error('‚ùå Fehler beim Erstellen der Profile-Liste:', error);
                container.innerHTML = `
                    <div class="alert alert-error">
                        <strong>Fehler beim Laden der Profile:</strong> ${error.message}<br>
                        <button onclick="loadAvailableProfiles()" class="btn btn-outline btn-small" style="margin-top: 0.5rem;">üîÑ Erneut versuchen</button>
                    </div>
                `;
            }
        }

        function selectProfile(profileId) {
            console.log('üéØ Profile ausw√§hlen:', profileId, 'Typ:', typeof profileId);
            console.log('üìã Aktuell ausgew√§hlte Profile vor √Ñnderung:', selectedProfiles);

            const element = event.target.closest('.profile-item');

            if (!element) {
                console.error('‚ùå Profile-Element nicht gefunden');
                return;
            }

            // Verwende == f√ºr flexiblen Typ-Vergleich
            const isCurrentlySelected = selectedProfiles.some(id => id == profileId);
            console.log('üîç Profil bereits ausgew√§hlt?', isCurrentlySelected);

            if (isCurrentlySelected) {
                console.log('‚ûñ Entferne Profile aus Auswahl');
                element.classList.remove('selected');
                selectedProfiles = selectedProfiles.filter(id => id != profileId);
            } else {
                if (selectedProfiles.length >= 2) {
                    console.log('‚ö†Ô∏è Maximale Anzahl Profile bereits ausgew√§hlt');
                    showNotification('Maximal 2 Profile k√∂nnen gleichzeitig ausgew√§hlt werden. Entferne zuerst ein anderes Profil.', 'warning');
                    return;
                }

                console.log('‚ûï F√ºge Profile zur Auswahl hinzu');
                element.classList.add('selected');
                selectedProfiles.push(profileId);
            }

            console.log('‚úÖ Neue Auswahl nach √Ñnderung:', selectedProfiles);
            updateMatchingStatus();
        }

        function updateMatchingStatus() {
            // Zeige Status der Auswahl
            const statusElement = document.getElementById('matching-status');
            const matchBtn = document.getElementById('match-btn');

            if (statusElement) {
                statusElement.textContent = `${selectedProfiles.length} von 2 Profilen ausgew√§hlt`;

                if (selectedProfiles.length === 0) {
                    statusElement.style.background = 'var(--swaf-light-gray)';
                    statusElement.style.color = 'var(--swaf-dark-gray)';
                } else if (selectedProfiles.length === 1) {
                    statusElement.style.background = 'var(--swaf-lightest-red)';
                    statusElement.style.color = 'var(--swaf-red)';
                    statusElement.textContent += ' - W√§hle noch ein Profil';
                } else if (selectedProfiles.length === 2) {
                    statusElement.style.background = 'var(--swaf-lightest-teal)';
                    statusElement.style.color = 'var(--swaf-teal)';
                    statusElement.textContent += ' - Bereit zum Matchen!';
                }
            }

            // Aktiviere/Deaktiviere Match-Button
            if (matchBtn) {
                matchBtn.disabled = selectedProfiles.length !== 2;
                if (selectedProfiles.length === 2) {
                    matchBtn.textContent = 'ü§ù Profile matchen';
                } else {
                    matchBtn.textContent = `ü§ù Ausgew√§hlte Profile matchen (${selectedProfiles.length}/2)`;
                }
            }
        }

        function matchSelectedProfiles() {
            console.log('ü§ù Starte Profile-Matching...');
            console.log('üìã Ausgew√§hlte Profile:', selectedProfiles);
            console.log('üìã Typ der ausgew√§hlten IDs:', selectedProfiles.map(id => typeof id));

            if (selectedProfiles.length !== 2) {
                const message = `Bitte w√§hle genau 2 Profile aus. Aktuell ausgew√§hlt: ${selectedProfiles.length}`;
                console.log('‚ùå ' + message);
                showNotification(message, 'warning');
                return;
            }

            // Verwende == statt === f√ºr flexiblen Typ-Vergleich
            const profile1 = profiles.find(p => p.id == selectedProfiles[0]);
            const profile2 = profiles.find(p => p.id == selectedProfiles[1]);

            console.log('üîç Suche Profil 1 mit ID:', selectedProfiles[0], 'Typ:', typeof selectedProfiles[0]);
            console.log('üîç Suche Profil 2 mit ID:', selectedProfiles[1], 'Typ:', typeof selectedProfiles[1]);
            console.log('üìä Alle verf√ºgbaren Profile-IDs:', profiles.map(p => `${p.id} (${typeof p.id})`));

            console.log('üë§ Profil 1 gefunden:', profile1 ? profile1.name : 'NICHT GEFUNDEN');
            console.log('üë§ Profil 2 gefunden:', profile2 ? profile2.name : 'NICHT GEFUNDEN');

            if (!profile1 || !profile2) {
                const message = 'Fehler beim Laden der Profile. ID-Typ-Problem erkannt - verwende "üîç Debug Matching" f√ºr Details.';
                console.error('‚ùå ' + message);

                // Zus√§tzliche Debug-Info
                console.error('üêõ DEBUG: Profile-Suche fehlgeschlagen:');
                console.error('- Gesuchte ID 1:', selectedProfiles[0], typeof selectedProfiles[0]);
                console.error('- Gesuchte ID 2:', selectedProfiles[1], typeof selectedProfiles[1]);
                console.error('- Verf√ºgbare IDs:', profiles.map(p => ({ id: p.id, type: typeof p.id, name: p.name })));

                showNotification(message, 'error');
                return;
            }

            console.log('üîç Analysiere Gemeinsamkeiten...');
            const commonalities = findCommonalities(profile1, profile2);
            console.log('üìä Gefundene Gemeinsamkeiten:', commonalities.length);

            const tandem = {
                id: Date.now() + Math.random(),
                profile1: profile1,
                profile2: profile2,
                name: `${profile1.name} & ${profile2.name}`,
                created: new Date().toISOString(),
                commonalities: commonalities
            };

            console.log('‚úÖ Neues Tandem erstellt:', tandem.name);

            tandems.push(tandem);
            saveTandems();

            updateMatchedPairs();
            clearProfileSelection();
            updateStatistics();

            // WICHTIG: Profile-Liste aktualisieren
            loadAvailableProfiles();

            // Berechne Match-Quality Score
            const qualityScore = calculateMatchQuality(profile1, profile2).score;

            // Gamification: Match wurde erstellt
            onMatchCreated(tandem, qualityScore);

            const successMessage = `‚úÖ Tandem "${tandem.name}" erstellt (${commonalities.filter(c => c.commonality).length} Gemeinsamkeiten)`;
            showNotification(successMessage, 'success');
            updateStatus(`Tandem "${tandem.name}" erstellt`);

            console.log('üéâ Matching erfolgreich abgeschlossen!');
        }

        function generateSmartCommonalityText(question, answer1, answer2, profile1, profile2) {
            const q = question.toLowerCase();
            const a1 = cleanAnswer(answer1).toLowerCase();
            const a2 = cleanAnswer(answer2).toLowerCase();
            
            const name1 = extractFirstName(profile1.name);
            const name2 = extractFirstName(profile2.name);
            
            console.log(`üß† Intelligente Analyse: "${question}" | "${a1}" vs "${a2}"`);
            
            // Identische Antworten
            if (a1 === a2 && a1.length > 0) {
                if (q.includes('hobby') || q.includes('freizeit')) {
                    return `Gemeinsames Hobby: ${answer1}! üéØ`;
                }
                if (q.includes('interesse') || q.includes('thema')) {
                    return `Geteiltes Interesse: ${answer1} üí°`;
                }
                if (q.includes('sprache')) {
                    return `Sprechen beide: ${answer1} üó£Ô∏è`;
                }
                return `Haben gemeinsam: ${answer1}`;
            }
            
            // Hobbies und Freizeitaktivit√§ten
            if (q.includes('hobby') || q.includes('freizeit') || q.includes('gerne')) {
                const hobbies1 = splitAndNormalize(a1);
                const hobbies2 = splitAndNormalize(a2);
                const common = findCommonHobbies(hobbies1, hobbies2);
                
                if (common.length > 0) {
                    return `Gemeinsame Interessen: ${common.join(', ')} üé™`;
                } else {
                    return `${name1}: ${answer1} | ${name2}: ${answer2} - super Mix! üåü`;
                }
            }
            
            // Interessen und Themen
            if (q.includes('interesse') || q.includes('thema')) {
                const interests1 = splitAndNormalize(a1);
                const interests2 = splitAndNormalize(a2);
                const common = findCommonInterests(interests1, interests2);
                
                if (common.length > 0) {
                    return `Gemeinsame Themen: ${common.join(', ')} üí¨`;
                } else {
                    return `Verschiedene Perspektiven - perfekt zum Austauschen! üîÑ`;
                }
            }
            
            // Berufliches
            if (q.includes('beruf') || q.includes('arbeit') || q.includes('job')) {
                if (findCareerSimilarity(a1, a2)) {
                    return `√Ñhnliche Bereiche - viel zu besprechen! üíº`;
                } else {
                    return `${name1}: ${answer1} | ${name2}: ${answer2} - unterschiedliche Welten! üåç`;
                }
            }
            
            // Alter
            if (q.includes('alter') || q.includes('geburt')) {
                const age1 = extractNumber(answer1);
                const age2 = extractNumber(answer2);
                if (age1 && age2) {
                    const diff = Math.abs(age1 - age2);
                    if (diff <= 2) {
                        return `Fast gleich alt (${age1} & ${age2}) üë•`;
                    } else if (diff <= 5) {
                        return `√Ñhnliche Generation (${age1} & ${age2}) üë´`;
                    } else {
                        return `Verschiedene Generationen (${age1} & ${age2}) - interessant! üîÑ`;
                    }
                }
            }
            
            // Default f√ºr andere Felder
            return '';
        }

        function findCommonHobbies(hobbies1, hobbies2) {
            const commonHobbies = [];
            const hobbyKeywords = {
                'sport': ['sport', 'fitness', 'laufen', 'joggen', 'gym', 'training'],
                'lesen': ['lesen', 'b√ºcher', 'buch', 'literatur'],
                'musik': ['musik', 'konzert', 'singen', 'instrument'],
                'kochen': ['kochen', 'backen', 'k√ºche', 'rezept'],
                'reisen': ['reisen', 'urlaub', 'l√§nder', 'kultur'],
                'film': ['filme', 'kino', 'serie', 'netflix'],
                'natur': ['natur', 'wandern', 'spazieren', 'park']
            };
            
            Object.entries(hobbyKeywords).forEach(([category, keywords]) => {
                const found1 = hobbies1.some(h => keywords.some(k => h.includes(k)));
                const found2 = hobbies2.some(h => keywords.some(k => h.includes(k)));
                if (found1 && found2) {
                    commonHobbies.push(category);
                }
            });
            
            // Direkte √úbereinstimmungen
            hobbies1.forEach(h1 => {
                hobbies2.forEach(h2 => {
                    if (h1.includes(h2) || h2.includes(h1) || h1 === h2) {
                        if (!commonHobbies.includes(h1)) {
                            commonHobbies.push(h1);
                        }
                    }
                });
            });
            
            return commonHobbies;
        }

        function findCommonInterests(interests1, interests2) {
            const common = [];
            const interestMap = {
                'politik': ['politik', 'gesellschaft', 'demokratie'],
                'technik': ['technik', 'computer', 'digital', 'technologie'],
                'kunst': ['kunst', 'museum', 'galerie', 'kreativ'],
                'wissenschaft': ['wissenschaft', 'forschung', 'studien']
            };
            
            Object.entries(interestMap).forEach(([category, keywords]) => {
                const found1 = interests1.some(i => keywords.some(k => i.includes(k)));
                const found2 = interests2.some(i => keywords.some(k => i.includes(k)));
                if (found1 && found2) {
                    common.push(category);
                }
            });
            
            return common;
        }

        function findCareerSimilarity(career1, career2) {
            const careerFields = {
                'it': ['it', 'computer', 'software', 'entwickler', 'programm'],
                'gesundheit': ['medizin', 'pflege', 'arzt', 'gesundheit', 'therapie'],
                'bildung': ['lehrer', 'schule', 'bildung', 'universit√§t', 'student'],
                'sozial': ['sozial', 'beratung', 'hilfe', 'unterst√ºtzung']
            };
            
            for (const [field, keywords] of Object.entries(careerFields)) {
                const match1 = keywords.some(k => career1.includes(k));
                const match2 = keywords.some(k => career2.includes(k));
                if (match1 && match2) return true;
            }
            
            return false;
        }

        function findCommonalities(profile1, profile2) {
            console.log('üîç Analysiere Gemeinsamkeiten zwischen:', profile1.name, 'und', profile2.name);

            const commonalities = [];

            // Definiere Sortier-Priorit√§t f√ºr Felder
            const fieldPriority = {
                // Basis-Infos zuerst
                'Vorname': 1, 'Nachname': 2, 'Alter': 3, 'Geschlecht': 4,
                'Standort': 5, 'Postleitzahl': 6, 'Region': 7,

                // Kontakt
                'E-Mail-Adresse': 10, 'Telefonnummer': 11,

                // Wichtige Matching-Felder
                'Welche Sprachen sprichst du?': 20, 'Hobbys': 21,
                'Was machst du gerade im Leben?': 22, 'Branche': 23,
                'In welchem Land bist du geboren?': 24,
                'Bist du in Deutschland geboren?': 25,
                'Seit wann lebst du in Deutschland?': 26,

                // Tandem-spezifisch
                'Warum m√∂chtest du bei SwaF mitmachen?': 30,
                'Was ist dir in einer Freundschaft besonders wichtig?': 31,
                'Wann hast du Zeit dich mit deinem Tandem zu treffen?': 32,
                'Wie gro√ü darf der Altersunterschied sein?': 33,
                'Geschlecht der Tandempartner*in': 34,
                'Wie lange kannst du anreisen um dich mit deinem Tandem zu treffen?': 35,
                'Wie bewegst du dich in der Stadt?': 36,

                // Sonstige (niedrige Priorit√§t)
                'Gruppe': 100, 'Vermittler*in': 101, 'Status': 102,
                'Terminart': 103, 'Durchgef√ºhrt von': 104
            };

            // Sammle alle Fragen und normalisiere sie f√ºr bessere Zuordnung
            const questionMap = new Map(); // normalisiert -> original
            const allQuestions = new Set();

            profile1.fields.forEach(f => {
                const normalized = normalizeQuestion(f.question);
                if (!questionMap.has(normalized)) {
                    questionMap.set(normalized, f.question);
                    allQuestions.add(f.question);
                }
            });

            profile2.fields.forEach(f => {
                const normalized = normalizeQuestion(f.question);
                if (!questionMap.has(normalized)) {
                    questionMap.set(normalized, f.question);
                    allQuestions.add(f.question);
                }
            });

            console.log(`üìä Gefunden: ${allQuestions.size} einzigartige Fragen nach Normalisierung`);

            console.log('üìä Anzahl einzigartige Fragen:', allQuestions.size);

            // Konvertiere zu Array und sortiere nach Priorit√§t
            const sortedQuestions = Array.from(allQuestions).sort((a, b) => {
                const priorityA = fieldPriority[a] || 999;
                const priorityB = fieldPriority[b] || 999;

                if (priorityA !== priorityB) {
                    return priorityA - priorityB;
                }

                // Bei gleicher Priorit√§t alphabetisch sortieren
                return a.localeCompare(b);
            });

            sortedQuestions.forEach(question => {
                const normalizedQuestion = normalizeQuestion(question);
                
                // √úberspringe Fragen, die nicht f√ºr Matching geeignet sind
                if (shouldExcludeFromMatching(question)) {
                    console.log(`‚è≠Ô∏è √úberspringe Matching f√ºr: "${question}" (in Ausschlussliste)`);
                    
                    // F√ºge trotzdem zur √úbersicht hinzu, aber ohne Gemeinsamkeiten-Analyse
                    const field1 = profile1.fields.find(f => normalizeQuestion(f.question) === normalizedQuestion);
                    const field2 = profile2.fields.find(f => normalizeQuestion(f.question) === normalizedQuestion);
                    const displayQuestion = field1?.question || field2?.question || question;
                    
                    commonalities.push({
                        question: displayQuestion,
                        answer1: field1 ? field1.answer : '',
                        answer2: field2 ? field2.answer : '',
                        commonality: '' // Bewusst leer f√ºr ausgeschlossene Felder
                    });
                    return; // √úberspringe den Rest der Matching-Logik
                }
                
                // Finde Felder mit normalisierter Frage (ber√ºcksichtigt Variationen)
                const field1 = profile1.fields.find(f => normalizeQuestion(f.question) === normalizedQuestion);
                const field2 = profile2.fields.find(f => normalizeQuestion(f.question) === normalizedQuestion);
                
                // Verwende die Hauptversion der Frage f√ºr die Anzeige
                const displayQuestion = field1?.question || field2?.question || question;

                const answer1 = field1 ? field1.answer : '';
                const answer2 = field2 ? field2.answer : '';

                let commonality = '';

                // Pr√ºfe Gemeinsamkeiten nur wenn beide Antworten haben
                if (answer1 && answer2) {
                    // F√ºr Listen-Felder (Hobbys, Sprachen, etc.) mit intelligenter Synonymerkennung
                    if (question.toLowerCase().includes('hobby') ||
                        question.toLowerCase().includes('sprache') ||
                        question.toLowerCase().includes('interesse')) {

                        // Hobby-Synonyme f√ºr besseren Abgleich
                        const hobbyMappings = {
                            'feiern': ['feiern gehen', 'ausgehen', 'party'],
                            'feiern gehen': ['feiern', 'ausgehen', 'party'],
                            'freunde treffen': ['leute treffen', 'soziale kontakte', 'gesellschaft'],
                            'leute treffen': ['freunde treffen', 'soziale kontakte', 'gesellschaft'],
                            'handwerkliche t√§tigkeiten': ['handwerk', 'basteln', 'diy'],
                            'it/technik': ['technik', 'computer', 'technologie'],
                            'kino': ['ins kino gehen', 'filme schauen', 'film'],
                            'ins kino gehen': ['kino', 'filme schauen', 'film'],
                            'kochen': ['gemeinsam kochen', 'kulinarik', 'essen zubereiten'],
                            'gemeinsam kochen': ['kochen', 'kulinarik', 'essen zubereiten'],
                            'konzerte': ['konzerte besuchen', 'livemusik', 'musik live'],
                            'konzerte besuchen': ['konzerte', 'livemusik', 'musik live'],
                            'kultur/museum/theater': ['ins museum oder theater gehen', 'kulturveranstaltungen', 'museum', 'theater'],
                            'ins museum oder theater gehen': ['kultur/museum/theater', 'kulturveranstaltungen', 'museum', 'theater'],
                            'literatur': ['lesen', 'b√ºcher', 'literatur'],
                            'lesen': ['literatur', 'b√ºcher'],
                            'politik und gesellschaft': ['√ºber politik und gesellschaft sprechen', 'politische diskussionen'],
                            '√ºber politik und gesellschaft sprechen': ['politik und gesellschaft', 'politische diskussionen'],
                            'wandern und natur': ['wandern', 'natur', 'outdoor'],
                            'serien und filme zu hause schauen': ['filme schauen', 'serien', 'netflix'],
                            'gesellschaftsspiele/brettspiele': ['brettspiele', 'spiele', 'gaming']
                        };

                        function normalizeHobby(hobby) {
                            const normalized = hobby.trim().toLowerCase();
                            // Entferne h√§ufige Zus√§tze
                            return normalized
                                .replace(/\s*(gehen|besuchen|schauen|sprechen)\s*$/, '')
                                .replace(/^(gemeinsam|ins?)\s+/, '')
                                .trim();
                        }

                        function findHobbyMatches(item1, item2) {
                            const norm1 = normalizeHobby(item1);
                            const norm2 = normalizeHobby(item2);

                            // Exakte √úbereinstimmung
                            if (norm1 === norm2) return true;

                            // Substring-√úbereinstimmung
                            if (norm1.includes(norm2) || norm2.includes(norm1)) return true;

                            // Synonym-√úberpr√ºfung
                            const synonyms1 = hobbyMappings[norm1] || [];
                            const synonyms2 = hobbyMappings[norm2] || [];

                            if (synonyms1.some(syn => syn === norm2 || norm2.includes(syn))) return true;
                            if (synonyms2.some(syn => syn === norm1 || norm1.includes(syn))) return true;

                            return false;
                        }

                        const items1 = answer1.split(/[,;]/).map(s => s.trim()).filter(s => s.length > 0);
                        const items2 = answer2.split(/[,;]/).map(s => s.trim()).filter(s => s.length > 0);
                        const commonItems = [];

                        items1.forEach(item1 => {
                            items2.forEach(item2 => {
                                if (findHobbyMatches(item1, item2)) {
                                    // Verwende die l√§ngere/spezifischere Version
                                    const betterItem = item1.length >= item2.length ? item1 : item2;
                                    if (!commonItems.some(existing => findHobbyMatches(existing, betterItem))) {
                                        commonItems.push(betterItem);
                                    }
                                }
                            });
                        });

                        if (commonItems.length > 0) {
                            if (commonItems.length === 1) {
                                commonality = `Gemeinsames Hobby: ${commonItems[0]}! Das verbindet sofort üéØ`;
                            } else if (commonItems.length <= 3) {
                                commonality = `${commonItems.length} gemeinsame Hobbys: ${commonItems.join(', ')}! Perfekte Basis üé®`;
                            } else {
                                commonality = `Viele gemeinsame Hobbys: ${commonItems.slice(0, 3).join(', ')} und mehr! Ihr werdet viel Spa√ü haben üéâ`;
                            }
                        }
                    }
                    // F√ºr exakte √úbereinstimmungen
                    else if (answer1.toLowerCase().trim() === answer2.toLowerCase().trim()) {
                        commonality = answer1;
                    }
                    // F√ºr Alters-√Ñhnlichkeit
                    else if (question.toLowerCase().includes('alter')) {
                        const age1 = parseInt(answer1);
                        const age2 = parseInt(answer2);
                        if (!isNaN(age1) && !isNaN(age2)) {
                            const diff = Math.abs(age1 - age2);
                            if (diff <= 5) {
                                commonality = `Ihr seid etwa gleich alt (${diff} Jahre Unterschied)`;
                            }
                        }
                    }
                    // F√ºr PLZ-basierte Entfernungsberechnung
                    else if (question.toLowerCase().includes('postleitzahl') || question.toLowerCase().includes('plz')) {
                        const plz1 = extractPLZ(answer1);
                        const plz2 = extractPLZ(answer2);

                        if (plz1 && plz2) {
                            // Verwende Promise f√ºr async Berechnung
                            calculatePLZDistanceAdvanced(plz1, plz2).then(result => {
                                if (result && result.distance !== null) {
                                    let commonalityText = '';
                                    if (result.distance === 0) {
                                        commonalityText = 'Ihr wohnt in derselben PLZ';
                                    } else {
                                        // Verbesserte Texte mit Links
                                        const routingInfo = result.routingInfo === 'Echte Routing-Distanz' ? 'üéØ' : 'üìè';
                                        
                                        if (result.type === 'very_close') {
                                            commonalityText = `${routingInfo} Sehr nah: ${result.distance}km (üö≤ ${result.estimatedTimes.cycling}min, üöå ${result.estimatedTimes.transit}min)`;
                                        } else if (result.type === 'close') {
                                            commonalityText = `${routingInfo} Nah: ${result.distance}km (üöå ${result.estimatedTimes.transit}min, üöó ${result.estimatedTimes.driving}min)`;
                                        } else if (result.type === 'medium') {
                                            commonalityText = `${routingInfo} Erreichbar: ${result.distance}km (üöå ${result.estimatedTimes.transit}min, üöó ${result.estimatedTimes.driving}min)`;
                                        } else if (result.type === 'far') {
                                            commonalityText = `${routingInfo} Weiter entfernt: ${result.distance}km (üöó ${result.estimatedTimes.driving}min)`;
                                        }
                                        
                                        // F√ºge Maps-Link-Info hinzu
                                        commonalityText += ` | üó∫Ô∏è Navigation: Google Maps, √ñPNV`;
                                    }

                                    // Aktualisiere die Gemeinsamkeit in der bereits erstellten Liste
                                    const existingEntry = commonalities.find(c => c.question === question);
                                    if (existingEntry) {
                                        existingEntry.commonality = commonalityText;
                                        // Speichere Maps-Links f√ºr sp√§teren Zugriff
                                        existingEntry.mapsLinks = result.mapsLinks;
                                    }
                                }
                            });

                            // Sofortige Luftlinien-Berechnung als Fallback
                            const coords1Cache = plzCache[plz1];
                            const coords2Cache = plzCache[plz2];

                            if (coords1Cache && coords2Cache) {
                                const airDistance = calculateHaversineDistance(
                                    coords1Cache[0], coords1Cache[1],
                                    coords2Cache[0], coords2Cache[1]
                                );
                                const estimatedDistance = Math.round(airDistance * 1.3);
                                
                                if (estimatedDistance <= 10) {
                                    commonality = `Sehr nah: ca. ${estimatedDistance}km - quasi Nachbarn! üè†`;
                                } else if (estimatedDistance <= 25) {
                                    commonality = `Gute Erreichbarkeit: ca. ${estimatedDistance}km mit √ñPNV üöã`;
                                } else if (estimatedDistance <= 50) {
                                    commonality = `Regionale N√§he: ca. ${estimatedDistance}km - gut machbar üìç`;
                                } else {
                                    commonality = `Weitere Entfernung: ca. ${estimatedDistance}km - aber zu schaffen üó∫Ô∏è`;
                                }
                            } else {
                                commonality = 'Distanz wird berechnet... üó∫Ô∏è';
}
                        }
                    }
                    // F√ºr Wohnort/Standort-Felder
                    else if (question.toLowerCase().includes('wohnort') ||
                        question.toLowerCase().includes('standort') ||
                        question.toLowerCase().includes('ort')) {

                        // Erst nach exakter √úbereinstimmung suchen
                        if (answer1.toLowerCase().trim() === answer2.toLowerCase().trim()) {
                            commonality = answer1;
                        } else {
                            // Dann nach PLZ in den Antworten suchen
                            const plz1 = extractPLZ(answer1);
                            const plz2 = extractPLZ(answer2);
                            if (plz1 && plz2) {
                                calculatePLZDistanceAdvanced(plz1, plz2).then(result => {
                                    if (result && result.distance !== null && result.distance <= 50) {
                                        const distance = result.distance;
                                        if (distance === 0) {
                                            commonality = 'Gleiche PLZ';
                                        } else if (distance <= 10) {
                                            commonality = `Nahegelegene Orte (ca. ${distance} km)`;
                                        } else if (distance <= 25) {
                                            commonality = `Gleiche Region (ca. ${distance} km)`;
                                        } else {
                                            commonality = `√Ñhnliche Region (ca. ${distance} km)`;
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
                // F√ºge ALLE Fragen hinzu (wichtig f√ºr vollst√§ndige √úbersicht)
                // ABER: Verwende intelligente Analyse f√ºr bessere Texte
                let finalCommonality = commonality;

                // Intelligente Texterstellung f√ºr geeignete Felder (verwendet neuen, verbesserten Mechanismus)
                if (!shouldExcludeFromMatching(question) && answer1 && answer2) {
                    const name1 = extractFirstNameSmart(profile1.name || '');
                    const name2 = extractFirstNameSmart(profile2.name || '');
                    const intelligentText = analyzeBothAnswersIntelligently(question, name1, name2, answer1, answer2);
                    if (intelligentText && intelligentText.length > 0) {
                        finalCommonality = intelligentText;
                        console.log(`üß† Intelligente Analyse (neu) f√ºr "${displayQuestion}": "${intelligentText}"`);
                    }
                }

                commonalities.push({
                    question: displayQuestion,
                    answer1: answer1,
                    answer2: answer2,
                    commonality: finalCommonality
                });
            });

            console.log('üìã Gemeinsamkeiten gefunden:', commonalities.filter(c => c.commonality).length, 'von', commonalities.length);
            return commonalities;
        }

        function updateMatchedPairs() {
            console.log('üîÑ Aktualisiere Tandem-Liste...');
            console.log('üìä Anzahl Tandems:', tandems.length);

            const container = document.getElementById('matched-pairs');
            const tandemCountElement = document.getElementById('tandem-count');
            const removePairBtn = document.getElementById('remove-pair-btn');

            // Update Counter
            if (tandemCountElement) {
                tandemCountElement.textContent = tandems.length;
            }

            if (tandems.length === 0) {
                container.innerHTML = '<li style="padding: 1rem; text-align: center; color: var(--swaf-dark-gray); font-style: italic;">Noch keine Tandems erstellt.</li>';
                if (removePairBtn) removePairBtn.disabled = true;
                return;
            }

            try {
                container.innerHTML = tandems.map((tandem, index) => {
                    const isSelected = selectedTandemPairId == tandem.id; 
                    const selectedClass = isSelected ? 'selected' : '';

                    return `
                        <li class="matched-pair ${selectedClass}" onclick="selectTandemPair('${tandem.id}')" data-tandem-id="${tandem.id}">
                            <div style="flex: 1;">
                                <strong>${tandem.name}</strong>
                                <div style="font-size: 0.8rem; color: var(--swaf-dark-gray); margin-top: 0.2rem;">
                                    ${tandem.commonalities.filter(c => c.commonality).length} Gemeinsamkeiten
                                    ${tandem.autoMatch ? ' ‚Ä¢ Auto-Match' : ''}
                                    ${isSelected ? ' ‚Ä¢ Ausgew√§hlt' : ''}
                                </div>
                            </div>
                            <button onclick="event.stopPropagation(); removeTandem('${tandem.id}')" 
                                    class="btn btn-outline btn-small" 
                                    style="margin-left: 1rem;">
                                üóëÔ∏è
                            </button>
                        </li>
                    `;
                }).join('');

                console.log('‚úÖ Tandem-Liste erfolgreich aktualisiert');

                if (removePairBtn) removePairBtn.disabled = false;

            } catch (error) {
                console.error('‚ùå Fehler beim Aktualisieren der Tandem-Liste:', error);
                container.innerHTML = `
                    <li style="padding: 1rem;">
                        <div class="alert alert-error">
                            Fehler beim Laden der Tandems: ${error.message}
                            <button onclick="updateMatchedPairs()" class="btn btn-outline btn-small" style="margin-top: 0.5rem;">üîÑ Erneut versuchen</button>
                        </div>
                    </li>
                `;
            }
        }

        // ===============================
        // UI-UPDATE-FUNKTIONEN  
        // ===============================
        function updateUI() {
            updateCollectedProfiles();
            updateStatistics();
            updateProfileCounts();
        }

        function updateCollectedProfiles() {
            const container = document.getElementById('collected-profiles-display');

            if (profiles.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--swaf-dark-gray); font-style: italic;">
                        <p>Noch keine Profile gesammelt.</p>
                        <p>Verwende das Bookmarklet, um Profile aus dem Portal zu sammeln!</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                    <h4 style="color: var(--swaf-teal); margin-bottom: 0.5rem;">‚úÖ Gesammelte Profile (${profiles.length}):</h4>
                    <div style="max-height: 200px; overflow-y: auto;">
                        ${profiles.map((profile, index) => `
                            <div style="background: white; padding: 0.75rem; margin: 0.5rem 0; border-radius: 4px; border: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: var(--swaf-red);">${index + 1}. ${profile.name}</strong><br>
                                    <small style="color: var(--swaf-dark-gray);">
                                        ${profile.fields.length} Felder${profile.pageType ? ' ‚Ä¢ ' + profile.pageType : ''} ‚Ä¢ ${new Date(profile.timestamp).toLocaleString('de-DE')}
                                    </small>
                                </div>
                                <button onclick="removeProfile('${profile.id}')" 
                                        style="background: var(--swaf-red); color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 3px; cursor: pointer;">
                                    ‚ùå
                                </button>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function updateProfileCounts() {
            document.getElementById('profile-count').textContent = profiles.length;
            document.getElementById('profile-count-btn').textContent = profiles.length;

            const continueBtn = document.getElementById('continue-btn');
            if (profiles.length > 0) {
                continueBtn.style.display = 'inline-block';
                updateProgress('download-progress', Math.min((profiles.length / 5) * 100, 100));
            } else {
                continueBtn.style.display = 'none';
                updateProgress('download-progress', 0);
            }
        }

        function updateStatistics() {
            document.getElementById('stats-profiles').textContent = profiles.length;
            document.getElementById('stats-tandems').textContent = tandems.length;

            const avgFields = profiles.length > 0
                ? Math.round(profiles.reduce((sum, p) => sum + p.fields.length, 0) / profiles.length)
                : 0;
            document.getElementById('stats-fields').textContent = avgFields;
        }

        function showNotification(message, type = 'info', duration = 5000) {
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(n => n.remove());

            const notification = document.createElement('div');
            notification.className = 'notification';

            const bgColors = {
                info: 'var(--swaf-teal)',
                success: '#28a745',
                warning: '#ffc107',
                error: 'var(--swaf-red)'
            };

            notification.style.background = bgColors[type] || bgColors.info;
            notification.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>${message}</span>
                    <button onclick="this.closest('.notification').remove()" style="background: none; border: none; color: white; font-size: 1.2rem; cursor: pointer; margin-left: 1rem;">√ó</button>
                </div>
            `;

            document.body.appendChild(notification);

            if (duration > 0) {
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, duration);
            }
        }

        function updateStatus(message) {
            document.getElementById('status-text').textContent = message;
            console.log('Status:', message);
        }

        function updateProgress(elementId, percentage) {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.width = percentage + '%';
            }
        }

        // ===============================
        // WEITERE MATCHING-FUNKTIONEN
        // ===============================
        function selectTandemPair(tandemId) {
            console.log('üéØ Tandem-Paar ausw√§hlen:', tandemId);

            // Entferne vorherige Auswahl
            document.querySelectorAll('.matched-pair.selected').forEach(el => {
                el.classList.remove('selected');
            });

            // W√§hle neues Paar aus
            const element = document.querySelector(`[data-tandem-id="${tandemId}"]`);
            if (element) {
                element.classList.add('selected');
                selectedTandemPairId = tandemId;

                const removePairBtn = document.getElementById('remove-pair-btn');
                if (removePairBtn) {
                    removePairBtn.disabled = false;
                    removePairBtn.textContent = 'üóëÔ∏è Ausgew√§hltes Paar entfernen';
                }
            }
        }

        function removeTandem(tandemId) {
            console.log('üóëÔ∏è Entferne Tandem mit ID:', tandemId);

            const tandemToRemove = tandems.find(t => t.id == tandemId);
            if (!tandemToRemove) {
                console.error('‚ùå Tandem nicht gefunden:', tandemId);
                showNotification('‚ùå Tandem nicht gefunden', 'error');
                return;
            }

            if (confirm(`Tandem "${tandemToRemove.name}" wirklich entfernen?`)) {
                console.log('‚úÖ Entferne Tandem:', tandemToRemove.name);

                tandems = tandems.filter(t => t.id != tandemId);
                saveTandems();
                updateMatchedPairs();
                updateStatistics();

                // Aktualisiere verf√ºgbare Profile
                loadAvailableProfiles();

                // Reset Auswahl wenn das entfernte Tandem ausgew√§hlt war
                if (selectedTandemPairId == tandemId) {
                    selectedTandemPairId = null;
                    const removePairBtn = document.getElementById('remove-pair-btn');
                    if (removePairBtn) {
                        removePairBtn.disabled = true;
                        removePairBtn.textContent = 'üóëÔ∏è Ausgew√§hltes Paar entfernen';
                    }
                }

                showNotification(`‚úÖ Tandem "${tandemToRemove.name}" entfernt`, 'success');
                updateStatus(`Tandem "${tandemToRemove.name}" entfernt`);
            }
        }

        function removeSelectedPair() {
            console.log('üóëÔ∏è Entferne ausgew√§hltes Tandem-Paar. Ausgew√§hlt:', selectedTandemPairId);

            if (!selectedTandemPairId) {
                showNotification('‚ö†Ô∏è Bitte w√§hle zuerst ein Tandem-Paar aus, indem du es in der Liste anklickst.', 'warning', 4000);
                return;
            }

            removeTandem(selectedTandemPairId);
        }

        function clearFilters() {
            document.getElementById('profile-search').value = '';
            document.getElementById('filter-gender').value = '';
            document.getElementById('filter-gruppe').value = '';
            document.getElementById('filter-age-min').value = '';
            document.getElementById('filter-age-max').value = '';
            filterProfiles();
            showNotification('‚úÖ Alle Filter zur√ºckgesetzt', 'success', 2000);
        }

        function clearProfileSelection() {
            console.log('üóëÔ∏è L√∂sche Profile-Auswahl...');
            console.log('üìã Auswahl vor L√∂schung:', selectedProfiles);

            // Setze Arrays zur√ºck
            selectedProfiles = [];
            selectedTandemPairId = null;

            // Entferne visuelle Auswahl von Profilen
            document.querySelectorAll('.profile-item.selected').forEach((el, index) => {
                console.log(`‚ûñ Entferne Auswahl von Profil ${index + 1}`);
                el.classList.remove('selected');
            });

            // Entferne visuelle Auswahl von Tandems
            document.querySelectorAll('.matched-pair.selected').forEach(el => {
                el.classList.remove('selected');
            });

            // Update UI-Status
            updateMatchingStatus();

            console.log('‚úÖ Auswahl erfolgreich gel√∂scht. Neue Auswahl:', selectedProfiles);
            showNotification('‚úÖ Auswahl gel√∂scht', 'success', 2000);
        }

        // ===============================
        // PROFIL-DETAILS FUNKTIONEN
        // ===============================
        function createProfileDetailsHTML(profile) {
            // Relevante Felder f√ºr Matching (filtere sensible Daten)
            const relevantFields = profile.fields.filter(field => {
                const question = field.question.toLowerCase();
                // Filtere sensible oder irrelevante Felder
                return !question.includes('email') &&
                    !question.includes('e-mail') &&
                    !question.includes('telefon') &&
                    !question.includes('nachname') &&
                    !question.includes('passwort') &&
                    !question.includes('id') &&
                    field.answer && 
                    field.answer.trim() !== '';
            });

            if (relevantFields.length === 0) {
                return '<p style="color: var(--swaf-dark-gray); font-style: italic;">Keine weiteren Details verf√ºgbar</p>';
            }

            return `
                <div class="profile-details-content">
                    ${relevantFields.map(field => `
                        <div class="profile-field-item">
                            <div class="profile-field-question">${escapeHtml(field.question)}</div>
                            <div class="profile-field-answer">${escapeHtml(field.answer)}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function toggleProfileDetails(event, profileId) {
            event.stopPropagation(); // Verhindere selectProfile Aufruf
            
            const detailsDiv = document.getElementById(`details-${profileId}`);
            const toggleBtn = event.target;
            
            if (!detailsDiv) {
                console.error('Details-Div nicht gefunden f√ºr Profil:', profileId);
                return;
            }
            
            if (detailsDiv.classList.contains('expanded')) {
                // Schlie√üen
                detailsDiv.classList.remove('expanded');
                toggleBtn.textContent = 'üìã Details anzeigen';
            } else {
                // √ñffnen
                detailsDiv.classList.add('expanded');
                toggleBtn.textContent = 'üîº Details ausblenden';
            }
        }

        function clearAllTandems() {
            if (tandems.length === 0) {
                showNotification('Keine Tandems zum L√∂schen vorhanden.', 'warning');
                return;
            }

            if (confirm(`Wirklich alle ${tandems.length} Tandems l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden!`)) {
                tandems = [];
                saveTandems();
                updateMatchedPairs();
                updateStatistics();

                // Profile wieder verf√ºgbar machen
                loadAvailableProfiles();

                showNotification('‚úÖ Alle Tandems gel√∂scht', 'success');
                updateStatus('Alle Tandems gel√∂scht');
            }
        }

        // Sammle alle verf√ºgbaren Felder aus allen Profilen
        function collectAvailableFields() {
            const fieldSet = new Set();
            profiles.forEach(profile => {
                profile.fields.forEach(field => {
                    if (field.question && field.question.trim()) {
                        fieldSet.add(field.question.trim());
                    }
                });
            });
            return Array.from(fieldSet).sort();
        }

        // F√ºlle das Feld-Dropdown mit verf√ºgbaren Feldern
        function populateFieldDropdown() {
            const select = document.getElementById('specific-field-select');
            if (!select) return;

            const fields = collectAvailableFields();
            select.innerHTML = '<option value="">-- Feld ausw√§hlen --</option>';

            fields.forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                select.appendChild(option);
            });
        }

        // Erweiterte Suche durch Profile
        function searchInProfile(profile, searchTerm, scope, specificField) {
            if (!searchTerm) return true;

            const term = searchTerm.toLowerCase();

            switch (scope) {
                case 'name':
                    // Nur im Namen suchen
                    return profile.name.toLowerCase().includes(term);

                case 'specific':
                    // In einem bestimmten Feld suchen
                    if (!specificField) return true;
                    const field = profile.fields.find(f => f.question === specificField);
                    if (!field) return false;
                    return field.answer.toLowerCase().includes(term);

                case 'all':
                default:
                    // Durch alle Felder suchen
                    // 1. Name
                    if (profile.name.toLowerCase().includes(term)) return true;

                    // 2. Alle Fragen und Antworten
                    for (const field of profile.fields) {
                        if (field.question.toLowerCase().includes(term)) return true;
                        if (field.answer.toLowerCase().includes(term)) return true;
                    }

                    return false;
            }
        }

        function filterProfiles() {
            const search = document.getElementById('profile-search').value.toLowerCase().trim();
            const searchScope = document.getElementById('search-scope').value;
            const specificField = document.getElementById('specific-field-select')?.value || '';
            const genderFilter = document.getElementById('filter-gender').value.toLowerCase().trim();
            const gruppeFilter = document.getElementById('filter-gruppe').value.toLowerCase().trim();
            const ageMin = parseInt(document.getElementById('filter-age-min').value) || 0;
            const ageMax = parseInt(document.getElementById('filter-age-max').value) || 999;

            // Zeige/Verstecke spezifisches Feld-Dropdown
            const specificFieldContainer = document.getElementById('specific-field-container');
            if (specificFieldContainer) {
                if (searchScope === 'specific') {
                    specificFieldContainer.style.display = 'block';
                    populateFieldDropdown();
                } else {
                    specificFieldContainer.style.display = 'none';
                }
            }

            console.log('üîç Filter-Werte:', { search, searchScope, specificField, genderFilter, gruppeFilter, ageMin, ageMax });

            // Pr√ºfe welche Ansicht aktiv ist
            if (currentView === 'map') {
                // Kartenansicht: Lade Karte neu mit gefilterten Profilen
                loadProfileMap();
                return;
            }

            // Listenansicht: Filtere .profile-item Elemente
            const profileItems = document.querySelectorAll('.profile-item');
            console.log(`üìã Filtere ${profileItems.length} Profile...`);

            let matchCount = 0;

            profileItems.forEach(item => {
                const profileId = item.getAttribute('data-profile-id');
                const profile = profiles.find(p => p.id == profileId);

                if (!profile) {
                    item.style.display = 'none';
                    return;
                }

                // Erweiterte Suche durch Profile
                const matchesSearch = searchInProfile(profile, search, searchScope, specificField);

                // Geschlecht-Filter - ROBUSTER
                let matchesGender = true;
                if (genderFilter) {
                    const genderField = profile.fields.find(f =>
                        f.question.toLowerCase().includes('geschlecht') &&
                        !f.question.toLowerCase().includes('tandem') &&
                        !f.question.toLowerCase().includes('partner')
                    );
                    if (genderField) {
                        const profileGender = genderField.answer.toLowerCase().trim();
                        matchesGender = profileGender.includes(genderFilter);
                    } else {
                        // Kein Geschlechtsfeld ‚Üí zeige Profil trotzdem an (nicht ausfiltern)
                        matchesGender = true;
                    }
                }

                // Gruppen-Filter - ROBUSTER
                let matchesGruppe = true;
                if (gruppeFilter) {
                    const gruppeField = profile.fields.find(f =>
                        f.question.toLowerCase().includes('gruppe') ||
                        f.question.toLowerCase().includes('local') ||
                        f.question.toLowerCase().includes('einwander') ||
                        f.question.toLowerCase().includes('newcom')
                    );
                    if (gruppeField) {
                        const profileGruppe = gruppeField.answer.toLowerCase().trim();
                        // Erweiterte Matching-Logik f√ºr Eingewanderte/Newcomer
                        if (gruppeFilter === 'einwander') {
                            matchesGruppe = profileGruppe.includes('einwander') || profileGruppe.includes('newcom');
                        } else {
                            matchesGruppe = profileGruppe.includes(gruppeFilter);
                        }
                    } else {
                        // Kein Gruppenfeld ‚Üí zeige Profil trotzdem an
                        matchesGruppe = true;
                    }
                }

                // Alter-Filter
                let matchesAge = true;
                if (ageMin > 0 || ageMax < 999) {
                    const ageField = profile.fields.find(f =>
                        f.question.toLowerCase() === 'alter' ||
                        f.question.toLowerCase().includes('geburtstag')
                    );
                    if (ageField) {
                        let profileAge = parseInt(ageField.answer) || 0;
                        if (profileAge === 0 && ageField.answer.includes('/')) {
                            const parts = ageField.answer.split(/[\/\.]/);
                            if (parts.length === 3) {
                                const year = parseInt(parts[2]);
                                const currentYear = new Date().getFullYear();
                                profileAge = currentYear - year;
                            }
                        }
                        if (profileAge > 0) {
                            matchesAge = profileAge >= ageMin && profileAge <= ageMax;
                        }
                    }
                    // Kein Altersfeld ‚Üí zeige trotzdem an
                }

                const shouldShow = matchesSearch && matchesGender && matchesGruppe && matchesAge;

                // Debug-Log f√ºr erste 3 Profile
                if (matchCount < 3) {
                    console.log(`Profile "${profile.name}":`, {
                        matchesSearch,
                        matchesGender,
                        matchesGruppe,
                        matchesAge,
                        shouldShow
                    });
                }

                item.style.display = shouldShow ? '' : 'none';
                if (shouldShow) matchCount++;
            });

            console.log(`‚úÖ ${matchCount} von ${profileItems.length} Profilen sichtbar`);

            // Zeige Feedback
            if (matchCount === 0 && profileItems.length > 0) {
                showNotification('‚ö†Ô∏è Keine Profile entsprechen den Filtern', 'warning', 3000);
            } else if (matchCount < profileItems.length) {
                showNotification(`üîç ${matchCount} von ${profileItems.length} Profilen gefunden`, 'info', 2000);
            }
        }

        function suggestAutoMatches() {
            if (profiles.length < 2) {
                showNotification('Mindestens 2 Profile ben√∂tigt f√ºr Auto-Matching.', 'warning');
                return;
            }

            updateStatus('Auto-Matching wird berechnet...');

            setTimeout(() => {
                const suggestions = [];

                for (let i = 0; i < profiles.length; i++) {
                    for (let j = i + 1; j < profiles.length; j++) {
                        const commonalities = findCommonalities(profiles[i], profiles[j]);
                        const score = commonalities.filter(c => c.commonality).length;

                        if (score > 0) {
                            suggestions.push({
                                profile1: profiles[i],
                                profile2: profiles[j],
                                score: score,
                                commonalities: commonalities
                            });
                        }
                    }
                }

                suggestions.sort((a, b) => b.score - a.score);

                if (suggestions.length > 0) {
                    showAutoMatchModal(suggestions.slice(0, 5));
                } else {
                    showNotification('Keine geeigneten Matches gefunden.', 'warning');
                }

                updateStatus('Auto-Matching abgeschlossen');
            }, 1000);
        }

        function showAutoMatchModal(suggestions) {
            const modal = createModal('üéØ Auto-Match Vorschl√§ge', `
                <p style="margin-bottom: 1.5rem;">Basierend auf Gemeinsamkeiten wurden folgende Tandems vorgeschlagen:</p>
                
                <div id="suggestion-list">
                    ${suggestions.map((suggestion, index) => `
                        <div style="border: 2px solid #ddd; padding: 1rem; margin: 0.5rem 0; border-radius: 6px;">
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="checkbox" value="${index}" style="margin-right: 1rem; margin-top: 0.2rem;">
                                <div style="flex: 1;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                        <strong>${suggestion.profile1.name} & ${suggestion.profile2.name}</strong>
                                        <span style="background: var(--swaf-teal); color: white; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.9rem;">
                                            ${suggestion.score} Gemeinsamkeiten
                                        </span>
                                    </div>
                                    <div style="font-size: 0.9rem; color: var(--swaf-dark-gray);">
                                        ${suggestion.commonalities.filter(c => c.commonality).slice(0, 3).map(c =>
                    `‚Ä¢ ${c.question}: ${c.commonality}`
                ).join('<br>')}
                                    </div>
                                </div>
                            </label>
                        </div>
                    `).join('')}
                </div>
            `, [
                {
                    text: 'Alle ausw√§hlen', class: 'btn-outline btn-small', action: function() {
                        document.querySelectorAll('#suggestion-list input[type=checkbox]').forEach(cb => cb.checked = true);
                    }
                },
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Ausgew√§hlte anwenden', class: 'btn-primary', action: function() { applyAutoMatches(suggestions); } }
            ]);
        }

        function applyAutoMatches(suggestions) {
            const checkboxes = document.querySelectorAll('#suggestion-list input[type="checkbox"]:checked');
            let applied = 0;
            let perfectMatches = 0;

            checkboxes.forEach(checkbox => {
                const index = parseInt(checkbox.value);
                const suggestion = suggestions[index];

                if (suggestion) {
                    const tandem = {
                        id: Date.now() + Math.random() + applied,
                        profile1: suggestion.profile1,
                        profile2: suggestion.profile2,
                        name: `${suggestion.profile1.name} & ${suggestion.profile2.name}`,
                        created: new Date().toISOString(),
                        commonalities: suggestion.commonalities,
                        autoMatch: true
                    };

                    tandems.push(tandem);
                    applied++;

                    // Gamification: Tandem erstellt
                    trackActivity('tandem_created');

                    // Pr√ºfe auf Perfect Match (8+ Gemeinsamkeiten)
                    if (suggestion.commonalities && suggestion.commonalities.length >= 8) {
                        trackActivity('perfect_match');
                        perfectMatches++;
                    }
                }
            });

            if (applied > 0) {
                saveTandems();
                updateMatchedPairs();
                updateStatistics();
                showNotification(`‚úÖ ${applied} Auto-Matches erfolgreich angewendet`, 'success');
            }

            closeModal();
        }

        // ===============================
        // FRAGEN-DEDUPLIZIERUNG (VOR loadFieldSelection!)
        // ===============================

        function findSimilarQuestions(questions) {
            const groups = [];
            const used = new Set();
            
            questions.forEach((question, index) => {
                if (used.has(index)) return;
                
                const normalized = normalizeQuestion(question);
                const group = [question];
                used.add(index);
                
                // Finde √§hnliche Fragen
                questions.forEach((otherQuestion, otherIndex) => {
                    if (otherIndex === index || used.has(otherIndex)) return;
                    
                    const otherNormalized = normalizeQuestion(otherQuestion);
                    
                    // Pr√ºfe verschiedene √Ñhnlichkeitskriterien
                    if (areQuestionsSimilar(normalized, otherNormalized)) {
                        group.push(otherQuestion);
                        used.add(otherIndex);
                    }
                });
                
                groups.push(group);
            });
            
            return groups;
        }

        function areQuestionsSimilar(q1, q2) {
            // Exakte √úbereinstimmung nach Normalisierung
            if (q1 === q2) return true;
            
            // Sehr hohe Wort√ºbereinstimmung (90%+)
            const words1 = q1.split(' ').filter(w => w.length > 2);
            const words2 = q2.split(' ').filter(w => w.length > 2);
            
            if (words1.length === 0 || words2.length === 0) return false;
            
            const commonWords = words1.filter(w => words2.includes(w));
            const similarity = (commonWords.length * 2) / (words1.length + words2.length);
            
            // 90% √Ñhnlichkeit oder mehr
            if (similarity >= 0.9) {
                console.log(`üîç √Ñhnliche Fragen erkannt (${Math.round(similarity*100)}%): "${q1}" ‚Üî "${q2}"`);
                return true;
            }
            
            return false;
        }

        // ===============================
        // FELD-AUSWAHL
        // ===============================
        function loadFieldSelection() {
            const container = document.getElementById('field-selection');

            if (profiles.length === 0) {
                container.innerHTML = '<p>Keine Profile verf√ºgbar. Bitte zuerst Profile sammeln.</p>';
                return;
            }

            const allFields = new Set();
            profiles.forEach(profile => {
                profile.fields.forEach(field => {
                    allFields.add(field.question);
                });
            });

            const excludeFields = [
                'Nachname', 'E-Mail-Adresse', 'Telefonnummer', 'Status',
                'Terminart', 'Durchgef√ºhrt von', 'Datum/Uhrzeit', 'Gruppe',
                'Standort-Newsletter', 'Vermittler*in'
            ];

            // Gruppiere √§hnliche Fragen und w√§hle Hauptvariante
            const questionGroups = findSimilarQuestions(Array.from(allFields));
            const deduplicatedFields = questionGroups.map(group => {
                if (group.length === 1) return group[0];
                
                // W√§hle die h√§ufigste oder k√ºrzeste Variante als Hauptfrage
                const fieldCounts = group.map(field => ({
                    field: field,
                    count: profiles.reduce((count, profile) => 
                        count + (profile.fields.some(f => f.question === field) ? 1 : 0), 0
                    )
                }));
                
                // Sortiere nach H√§ufigkeit, dann nach K√ºrze
                fieldCounts.sort((a, b) => {
                    if (b.count !== a.count) return b.count - a.count;
                    return a.field.length - b.field.length;
                });
                
                const mainField = fieldCounts[0].field;
                console.log(`üìù Hauptfrage gew√§hlt: "${mainField}" (aus ${group.length} Varianten)`);
                
                return mainField;
            });

            // Sortiere deduplizierte Felder alphabetisch
            const sortedFields = deduplicatedFields.sort();

            // Initialisiere selectedFields falls leer
            if (selectedFields.length === 0) {
                selectedFields = sortedFields.filter(field => !excludeFields.includes(field));
                localStorage.setItem('swaf_selected_fields', JSON.stringify(selectedFields));
            }

            container.innerHTML = `
                <div style="margin-bottom: 1rem; background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px;">
                    <h4 style="margin-top: 0; color: var(--swaf-teal);">üìä Feld-Statistiken:</h4>
                    <p style="margin: 0.5rem 0;">
                        <strong>Gesamt:</strong> ${sortedFields.length} verschiedene Felder gefunden<br>
                        <strong>Ausgew√§hlt:</strong> <span id="selected-fields-count">${selectedFields.length}</span> Felder<br>
                        <strong>Automatisch ausgeschlossen:</strong> ${excludeFields.length} Felder (sensible Daten)
                    </p>
                </div>
                
                ${sortedFields.map(field => {
                    const isSelected = selectedFields.includes(field);
                    const isExcluded = excludeFields.includes(field);
                    const fieldCount = profiles.reduce((count, profile) => 
                        count + (profile.fields.some(f => f.question === field) ? 1 : 0), 0
                    );

                    return `
                        <div style="display: flex; align-items: center; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; margin: 0.3rem 0; ${isExcluded ? 'background: #f0f0f0; opacity: 0.7;' : ''}">
                            <input type="checkbox" 
                                id="field-${field.replace(/[^a-zA-Z0-9]/g, '_')}" 
                                ${isSelected ? 'checked' : ''} 
                                ${isExcluded ? 'disabled' : ''}
                                onchange="toggleField('${field.replace(/'/g, "\\'")}')" 
                                style="margin-right: 0.75rem; transform: scale(1.2);">
                            <div style="flex: 1;">
                                <label for="field-${field.replace(/[^a-zA-Z0-9]/g, '_')}" style="margin: 0; cursor: pointer;">
                                    <strong>${field}</strong>
                                    ${isExcluded ? '<em style="color: var(--swaf-red);"> (Automatisch ausgeschlossen)</em>' : ''}
                                </label>
                                <div style="font-size: 0.8rem; color: var(--swaf-dark-gray); margin-top: 0.2rem;">
                                    In ${fieldCount} von ${profiles.length} Profilen vorhanden
                                </div>
                            </div>
                        </div>
                    `;
                }).join('')}
            `;
            
            console.log('üìä Feld-Auswahl geladen:', selectedFields.length, 'von', sortedFields.length, 'Feldern ausgew√§hlt');
        }

        function toggleField(field) {
            console.log('üîß Toggle Feld:', field);
            
            if (selectedFields.includes(field)) {
                selectedFields = selectedFields.filter(f => f !== field);
                console.log('‚ûñ Feld entfernt:', field);
            } else {
                selectedFields.push(field);
                console.log('‚ûï Feld hinzugef√ºgt:', field);
            }
            
            localStorage.setItem('swaf_selected_fields', JSON.stringify(selectedFields));
            
            // Update Counter
            const counter = document.getElementById('selected-fields-count');
            if (counter) {
                counter.textContent = selectedFields.length;
            }
            
            console.log('‚úÖ Neue Auswahl:', selectedFields.length, 'Felder');
        }

        function selectAllFields(select) {
            const checkboxes = document.querySelectorAll('#field-selection input[type="checkbox"]:not([disabled])');
            
            if (select) {
                // Alle aktivieren - hole Feldnamen aus dem Label-Text
                selectedFields = [];
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    // Finde das Label und extrahiere den Feldnamen (ohne "Automatisch ausgeschlossen")
                    const labelDiv = checkbox.parentElement.querySelector('label strong');
                    if (labelDiv) {
                        const fieldName = labelDiv.textContent.trim();
                        if (fieldName && !selectedFields.includes(fieldName)) {
                            selectedFields.push(fieldName);
                        }
                    }
                });
            } else {
                // Alle deaktivieren
                selectedFields = [];
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
            }

            localStorage.setItem('swaf_selected_fields', JSON.stringify(selectedFields));
            
            // Update Counter
            const counter = document.getElementById('selected-fields-count');
            if (counter) {
                counter.textContent = selectedFields.length;
            }
            
            console.log(`‚úÖ ${select ? 'Alle' : 'Keine'} Felder ausgew√§hlt:`, selectedFields.length, 'Felder');
        }

        // ===============================
        // BEARBEITUNGS-FUNKTIONEN
        // ===============================
        function loadTandemSelector() {
            const selector = document.getElementById('tandem-selector');

            selector.innerHTML = '<option value="">-- Tandem ausw√§hlen --</option>' +
                tandems.map(tandem => `<option value="${tandem.id}">${tandem.name}</option>`).join('');
        }

        function loadTandemForEditing() {
            const tandemId = document.getElementById('tandem-selector').value;
            if (!tandemId) {
                document.getElementById('tandem-editor').classList.add('hidden');
                return;
            }

            currentTandem = tandems.find(t => t.id == tandemId);
            if (!currentTandem) return;

            document.getElementById('tandem-editor').classList.remove('hidden');

            const tbody = document.querySelector('#tandem-table tbody');
            tbody.innerHTML = '';

            // Filtere und sortiere nach Reihenfolge
            const fieldOrder = JSON.parse(localStorage.getItem('swaf_field_order') || '[]');
            const filteredCommonalities = currentTandem.commonalities
                .filter(c => {
                // Wenn keine Felder ausgew√§hlt, zeige alle
                if (selectedFields.length === 0) return true;
                
                // Zeige nur Felder, die in der Auswahl enthalten sind
                return selectedFields.includes(c.question);
            });

            console.log(`üìä Zeige ${filteredCommonalities.length} von ${currentTandem.commonalities.length} Feldern (basierend auf Feldauswahl)`);

            // Sortiere nach gespeicherter Reihenfolge
            const sortedCommonalities = filteredCommonalities.sort((a, b) => {
                const indexA = fieldOrder.indexOf(a.question);
                const indexB = fieldOrder.indexOf(b.question);
                if (indexA === -1 && indexB === -1) return 0;
                if (indexA === -1) return 1;
                if (indexB === -1) return -1;
                return indexA - indexB;
            });

            filteredCommonalities.forEach(c => {
                const isPLZField = c.question.toLowerCase().includes('postleitzahl') || c.question.toLowerCase().includes('plz');
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${c.question}</td>
                    <td contenteditable="true">${c.answer1}</td>
                    <td contenteditable="true">${c.answer2}</td>
                    <td contenteditable="true" 
                        style="background: var(--swaf-lightest-teal); cursor: text; ${isPLZField ? 'padding-right: 90px; position: relative;' : ''}" 
                        title="${isPLZField ? 'üîÑ Distanz wird automatisch berechnet' : 'Klick hier f√ºr passende Formulierungsvorschl√§ge'}"
                        onfocus="handleCellFocus(this)"
                        data-is-plz="${isPLZField}"
                        data-answer1="${(c.answer1 || '').replace(/"/g, '&quot;')}"
                        data-answer2="${(c.answer2 || '').replace(/"/g, '&quot;')}">
                        ${isPLZField ? 'üîÑ Berechne Distanz...' : c.commonality}
                    </td>
                    <td style="position: relative;">
                        ${!isPLZField ? `<button class="ai-assist-btn btn btn-outline btn-small" style="margin-right: 0.5rem;" title="KI-Unterst√ºtzung" data-question="${c.question.replace(/"/g, '&quot;')}" data-answer1="${(c.answer1 || '').replace(/"/g, '&quot;')}" data-answer2="${(c.answer2 || '').replace(/"/g, '&quot;')}">ü§ñ KI</button>` : ''}
                        <button onclick="deleteRow(this)" class="btn btn-outline btn-small">üóëÔ∏è</button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            // Event Listener f√ºr KI-Buttons
            setTimeout(() => {
                const aiButtons = document.querySelectorAll('.ai-assist-btn');
                aiButtons.forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const question = this.getAttribute('data-question');
                        const answer1 = this.getAttribute('data-answer1');
                        const answer2 = this.getAttribute('data-answer2');
                        openAIAssistant(question, answer1, answer2);
                    });
                });
            }, 100);

            // Automatische PLZ-Distanzberechnung starten
            setTimeout(() => {
                autoCalculatePLZDistances();
            }, 300);

            // Info-Hinweis wenn Felder gefiltert wurden
            if (filteredCommonalities.length < currentTandem.commonalities.length) {
                const infoRow = document.createElement('tr');
                infoRow.innerHTML = `
                    <td colspan="5" style="text-align: center; padding: 1rem; background: var(--swaf-lightest-red); color: var(--swaf-red); font-style: italic;">
                        üìä ${currentTandem.commonalities.length - filteredCommonalities.length} Felder durch Feldkonfiguration ausgeblendet. 
                        <button onclick="showAllFields()" class="btn btn-outline btn-small" style="margin-left: 1rem;">Alle anzeigen</button>
                    </td>
                `;
                tbody.appendChild(infoRow);
            }
        }

        function deleteRow(button) {
            if (confirm('Zeile wirklich l√∂schen?')) {
                button.closest('tr').remove();
            }
        }

        function saveTandemSilently() {
            if (!currentTandem) return false;

            const rows = document.querySelectorAll('#tandem-table tbody tr');
            const updatedCommonalities = [];

            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 4) {
                    updatedCommonalities.push({
                        question: cells[0].textContent,
                        answer1: cells[1].textContent,
                        answer2: cells[2].textContent,
                        commonality: cells[3].textContent
                    });
                }
            });

            const tandemIndex = tandems.findIndex(t => t.id === currentTandem.id);
            if (tandemIndex !== -1) {
                tandems[tandemIndex].commonalities = updatedCommonalities;
                tandems[tandemIndex].lastEdited = new Date().toISOString();
                saveTandems();
                console.log('‚úÖ Tandem automatisch gespeichert (still)');
                return true;
            }
            return false;
        }

        function saveTandem() {
            if (saveTandemSilently()) {
                showNotification('‚úÖ Tandem gespeichert', 'success');
                updateStatus('Tandem gespeichert');

                // Gamification: Tandem erstellt
                trackActivity('tandem_created');

                // Pr√ºfe auf Perfect Match (8+ Gemeinsamkeiten)
                if (currentTandem && currentTandem.commonalities && currentTandem.commonalities.length >= 8) {
                    trackActivity('perfect_match');
                }
            }
        }

        function recomputeCommonalities() {
            if (!currentTandem) {
                showNotification('Kein Tandem ausgew√§hlt.', 'warning');
                return;
            }

            if (confirm('Gemeinsamkeiten neu berechnen? Manuelle √Ñnderungen gehen verloren.')) {
                // Berechne Gemeinsamkeiten neu
                const newCommonalities = findCommonalities(currentTandem.profile1, currentTandem.profile2);
                currentTandem.commonalities = newCommonalities;

                // Aktualisiere die Tabelle
                loadTandemForEditing();

                showNotification('‚úÖ Gemeinsamkeiten neu berechnet', 'success');
            }
        }

        // Aktualisiert nur PLZ-Distanzen ohne andere Gemeinsamkeiten zu √ºberschreiben
        async function updatePLZDistancesOnly() {
            if (!currentTandem) {
                showNotification('Kein Tandem ausgew√§hlt.', 'warning');
                return;
            }

            const table = document.getElementById('tandem-table');
            const rows = table.querySelectorAll('tbody tr');
            let updatedCount = 0;
            
            console.log('üó∫Ô∏è Starte PLZ-Distanz-Update...');
            
            for (const row of rows) {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 4) {
                    const question = cells[0].textContent.trim();
                    const answer1 = cells[1].textContent.trim();
                    const answer2 = cells[2].textContent.trim();
                    const currentCommonality = cells[3];

                    // Pr√ºfe ob es sich um PLZ/Wohnort-Feld handelt
                    const isLocationField = question.toLowerCase().includes('postleitzahl') || 
                                        question.toLowerCase().includes('plz') ||
                                        question.toLowerCase().includes('wohnort') ||
                                        question.toLowerCase().includes('standort');

                    if (isLocationField) {
                        const plz1 = extractPLZ(answer1);
                        const plz2 = extractPLZ(answer2);

                        if (plz1 && plz2) {
                            console.log(`üìç Berechne Distanz: ${plz1} ‚Üî ${plz2}`);
                            
                            // Zeige Loading-Status
                            currentCommonality.textContent = 'üîÑ Berechne Distanz...';
                            currentCommonality.style.background = 'var(--swaf-lightest-teal)';

                            try {
                                const result = await calculatePLZDistanceAdvanced(plz1, plz2);
                                
                                if (result && result.distance !== null) {
                                    let distanceText = '';
                                    
                                    if (result.distance === 0) {
                                        distanceText = 'Ihr wohnt in derselben PLZ';
                                    } else {
                                        const routingInfo = result.routingInfo === 'Echte Routing-Distanz' ? 'üéØ' : 'üìè';
                                        
                                        if (result.type === 'very_close') {
                                            distanceText = `${routingInfo} Sehr nah: ${result.distance}km (üö≤ ${result.estimatedTimes.cycling}min, üöå ${result.estimatedTimes.transit}min)`;
                                        } else if (result.type === 'close') {
                                            distanceText = `${routingInfo} Nah: ${result.distance}km (üöå ${result.estimatedTimes.transit}min, üöó ${result.estimatedTimes.driving}min)`;
                                        } else if (result.type === 'medium') {
                                            distanceText = `${routingInfo} Erreichbar: ${result.distance}km (üöå ${result.estimatedTimes.transit}min, üöó ${result.estimatedTimes.driving}min)`;
                                        } else if (result.type === 'far') {
                                            distanceText = `${routingInfo} Weiter entfernt: ${result.distance}km (üöó ${result.estimatedTimes.driving}min)`;
                                        }
                                    }
                                    
                                    // Verwende verbesserte PLZ-Zellen-Behandlung
                                    if (result.mapsLinks) {
                                        enhancePLZCell(currentCommonality, result.mapsLinks, plz1, plz2, distanceText);
                                    } else {
                                        currentCommonality.textContent = distanceText;
                                    }
                                    
                                    // Visuelles Feedback
                                    currentCommonality.style.background = 'var(--swaf-lightest-teal)';
                                    setTimeout(() => {
                                        currentCommonality.style.background = '';
                                    }, 2000);
                                    
                                    updatedCount++;
                                    console.log(`‚úÖ ${plz1} ‚Üî ${plz2}: ${result.distance}km`);
                                } else {
                                    currentCommonality.textContent = '‚ùå Distanz nicht berechenbar';
                                    currentCommonality.style.background = 'var(--swaf-lightest-red)';
                                }
                            } catch (error) {
                                console.error(`‚ùå Fehler bei ${plz1} ‚Üî ${plz2}:`, error);
                                currentCommonality.textContent = '‚ùå Berechnung fehlgeschlagen';
                                currentCommonality.style.background = 'var(--swaf-lightest-red)';
                            }
                        } else {
                            console.log(`‚ö†Ô∏è Keine PLZ in "${question}" gefunden: "${answer1}" | "${answer2}"`);
                        }
                    }
                }
            }
            
            if (updatedCount > 0) {
                showNotification(`üó∫Ô∏è ${updatedCount} PLZ-Distanzen aktualisiert`, 'success', 4000);
            } else {
                showNotification('‚ÑπÔ∏è Keine PLZ-Felder zum Aktualisieren gefunden', 'info', 3000);
            }
        }

        // Zeigt Navigations-Optionen f√ºr PLZ-Kombination
        function showNavigationOptions(mapsLinks, plz1, plz2) {
            console.log(`üó∫Ô∏è √ñffne Navigation f√ºr ${plz1} ‚Üí ${plz2}`);
            
            // Spezielle Behandlung f√ºr verschiedene Regionen
            const regionInfo = getRegionInfo(plz1, plz2);
            const modal = createModal(`üó∫Ô∏è Navigation: ${plz1} ‚Üí ${plz2}`, `
                <div style="text-align: center;">
                    <p style="margin-bottom: 1.5rem;">W√§hle deinen bevorzugten Navigationsservice:</p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                        <button class="btn btn-primary" onclick="window.open('${mapsLinks.googleMaps}', '_blank')" style="padding: 1rem;">
                            üöó Google Maps<br><small>Auto-Navigation</small>
                        </button>
                        <button class="btn btn-secondary" onclick="window.open('${mapsLinks.googleMapsTransit}', '_blank')" style="padding: 1rem;">
                            üöå Google √ñPNV<br><small>Bus & Bahn</small>
                        </button>
                        <button class="btn btn-outline" onclick="window.open('${mapsLinks.openStreetMap}', '_blank')" style="padding: 1rem;">
                            üåç OpenStreetMap<br><small>Open Source</small>
                        </button>
                        <button class="btn btn-outline" onclick="window.open('${mapsLinks.localTransit}', '_blank')" style="padding: 1rem;">
                            üöá Lokale √ñPNV<br><small>BVG/MVV/HVV</small>
                        </button>
                    </div>
                    
                    <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <h4 style="margin-top: 0;">üìã Links kopieren:</h4>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center;">
                            <button class="btn btn-outline btn-small" onclick="copyToClipboard('${mapsLinks.googleMaps}')">
                                üìã Google Maps
                            </button>
                            <button class="btn btn-outline btn-small" onclick="copyToClipboard('${mapsLinks.googleMapsTransit}')">
                                üìã √ñPNV
                            </button>
                            <button class="btn btn-outline btn-small" onclick="copyToClipboard('${mapsLinks.localTransit}')">
                                üìã Lokale √ñPNV
                            </button>
                        </div>
                    </div>
                </div>
            `, [
                { text: 'Schlie√üen', class: 'btn-outline', action: 'closeModal' }
            ]);
        }

        // Verbesserte PLZ-Zellen-Behandlung f√ºr bessere UX
        function enhancePLZCell(cell, mapsLinks, plz1, plz2, distanceText) {
            // Entferne alte Event Listener
            cell.onclick = null;
            cell.ondblclick = null;
            
            // Setze Inhalt und Style
            cell.textContent = distanceText;
            cell.style.cursor = 'text';
            cell.title = `üìù Klick zum Bearbeiten | üó∫Ô∏è Doppelklick f√ºr Navigation (${plz1} ‚Üí ${plz2})`;
            
            // Doppelklick f√ºr Navigation
            cell.addEventListener('dblclick', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Kurzes visuelles Feedback
                cell.style.background = 'var(--swaf-light-teal)';
                setTimeout(() => {
                    cell.style.background = 'var(--swaf-lightest-teal)';
                }, 200);
                
                showNavigationOptions(mapsLinks, plz1, plz2);
            });
            
            // Hover-Effekt f√ºr bessere UX
            cell.addEventListener('mouseenter', function() {
                if (!cell.matches(':focus')) {
                    cell.style.background = 'var(--swaf-lightest-teal)';
                    cell.style.borderLeft = '3px solid var(--swaf-teal)';
                }
            });
            
            cell.addEventListener('mouseleave', function() {
                if (!cell.matches(':focus')) {
                    cell.style.background = '';
                    cell.style.borderLeft = '';
                }
            });
            
            // Focus-Behandlung f√ºr Bearbeitung
            cell.addEventListener('focus', function() {
                cell.style.background = '#fff';
                cell.style.borderLeft = '3px solid var(--swaf-red)';
                cell.title = `üìù Bearbeitung aktiv | Esc zum Beenden`;
            });
            
            cell.addEventListener('blur', function() {
                cell.style.background = '';
                cell.style.borderLeft = '';
                cell.title = `üìù Klick zum Bearbeiten | üó∫Ô∏è Doppelklick f√ºr Navigation (${plz1} ‚Üí ${plz2})`;
            });
            
            // Speichere Maps-Links als Data-Attribut
            cell.setAttribute('data-maps-links', JSON.stringify(mapsLinks));
            cell.setAttribute('data-plz-pair', `${plz1}-${plz2}`);
        }

        // Hilfsfunktion zum Kopieren in Zwischenablage
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification('üìã Link in Zwischenablage kopiert', 'success', 2000);
            }).catch(() => {
                // Fallback f√ºr √§ltere Browser
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showNotification('üìã Link kopiert', 'success', 2000);
            });
        }        

        // Ermittelt regionale Informationen f√ºr bessere √ñPNV-Links
        function getRegionInfo(plz1, plz2) {
            const regions = {
                berlin: { name: 'Berlin', pattern: /^(10|12|13)/, transport: 'BVG' },
                munich: { name: 'M√ºnchen', pattern: /^8[0-5]/, transport: 'MVV' },
                hamburg: { name: 'Hamburg', pattern: /^2[0-2]/, transport: 'HVV' },
                cologne: { name: 'K√∂ln/NRW', pattern: /^(4|5)/, transport: 'VRS/VRR' },
                frankfurt: { name: 'Frankfurt', pattern: /^6/, transport: 'RMV' }
            };
            
            for (const [key, region] of Object.entries(regions)) {
                if (region.pattern.test(plz1) || region.pattern.test(plz2)) {
                    return region;
                }
            }
            
            return { name: 'Deutschland', transport: 'Deutsche Bahn' };
        }

        // Keyboard-Shortcut f√ºr Navigation in PLZ-Zellen
        document.addEventListener('keydown', function(e) {
            // Strg+N f√ºr Navigation wenn PLZ-Zelle fokussiert ist
            if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
                const focusedElement = document.activeElement;
                
                if (focusedElement && focusedElement.hasAttribute('data-maps-links')) {
                    e.preventDefault();
                    
                    const mapsLinks = JSON.parse(focusedElement.getAttribute('data-maps-links'));
                    const plzPair = focusedElement.getAttribute('data-plz-pair').split('-');
                    
                    showNavigationOptions(mapsLinks, plzPair[0], plzPair[1]);
                    showShortcutFeedback('üó∫Ô∏è Navigation ge√∂ffnet!');
                }
            }
});

        // ===============================
        // EMAIL TEMPLATE SYSTEM
        // ===============================
        function formatText(command) {
            document.execCommand(command, false, null);
            updateToolbarState();
        }

        function insertText(text) {
            document.execCommand('insertHTML', false, text);
        }

        function insertPlaceholder(placeholder) {
            document.execCommand('insertHTML', false, `<strong>${placeholder}</strong>`);
        }

        function updateToolbarState() {
            const commands = ['bold', 'italic', 'underline'];
            commands.forEach(cmd => {
                const btn = document.querySelector(`[onclick="formatText('${cmd}')"]`);
                if (btn) {
                    btn.classList.toggle('active', document.queryCommandState(cmd));
                }
            });
        }

        function saveEmailTemplate() {
            emailTemplate.subject = document.getElementById('email-subject').value;
            emailTemplate.intro = document.getElementById('email-intro-editor').innerHTML;
            emailTemplate.link = document.getElementById('tandem-link').value;

            localStorage.setItem('swaf_email_template', JSON.stringify(emailTemplate));
            showNotification('‚úÖ E-Mail-Vorlage gespeichert', 'success');
        }

        function loadEmailTemplate() {
            const saved = localStorage.getItem('swaf_email_template');
            if (saved) {
                try {
                    emailTemplate = JSON.parse(saved);
                    document.getElementById('email-subject').value = emailTemplate.subject;
                    document.getElementById('email-intro-editor').innerHTML = emailTemplate.intro;
                    document.getElementById('tandem-link').value = emailTemplate.link;
                    showNotification('‚úÖ E-Mail-Vorlage geladen', 'success');
                } catch (error) {
                    console.error('Fehler beim Laden der E-Mail-Vorlage:', error);
                    showNotification('‚ùå Fehler beim Laden der Vorlage', 'error');
                }
            } else {
                showNotification('‚ÑπÔ∏è Keine gespeicherte Vorlage gefunden', 'info');
            }
        }

        function resetEmailTemplate() {
            if (confirm('E-Mail-Vorlage auf Standardwerte zur√ºcksetzen?')) {
                document.getElementById('email-intro-editor').innerHTML = `
                    Hi <strong>[NAME1]</strong> und <strong>[NAME2]</strong>,<br><br>
                    
                    hier ist ein Tandemvorschlag f√ºr euch üòä Lest euch das gerne einmal durch ‚Äì ich finde, <strong>ihr habt einige Gemeinsamkeiten und Interessen</strong>. Lest euch die Tabelle gerne durch.<br><br>
                    
                    <strong>Ihr findet:</strong> Eure Angaben, die Angaben der anderen Person, meine Einsch√§tzung.<br><br>
                    
                    <em>Auch wenn es auf den ersten Blick nicht zu 100% passt, probiert es vielleicht aus.</em> Nat√ºrlich nur, wenn ihr Lust drauf habt. Wenn nicht, ist das auch okay.<br><br>
                    
                    Unter der Tabelle findet ihr einen Link. <strong>Bitte dr√ºckt hier drauf.</strong> Dann k√∂nnt ihr sagen, ob ihr das Tandem annehmen oder ablehnen wollt üòä<br><br>
                    
                    <strong>Wichtig:</strong> Wenn ihr das Tandem ablehnt schreibt mir bitte die Gr√ºnde auf.<br><br>
                    
                    Ich freue mich √ºber eure R√ºckmeldung!<br><br>
                    
                    <strong>Eure Gemeinsamkeiten und Profile im √úberblick</strong>
                `;
                showNotification('‚úÖ E-Mail-Vorlage zur√ºckgesetzt', 'success');
            }
        }

        function generateCompleteEmail() {
            if (!currentTandem) {
                showNotification('‚ùå Bitte w√§hle zuerst ein Tandem aus', 'error');
                return;
            }

            // Automatisch Tandem speichern BEVOR E-Mail erstellt wird
            console.log('üíæ Auto-Save: Speichere Tandem vor E-Mail-Erstellung...');
            saveTandemSilently();

            saveEmailTemplate(); // Aktuelle Eingaben speichern
            previewEmail();

            // Gamification: E-Mail erstellt
            trackActivity('email_sent');

            // Feedback f√ºr User
            showNotification('üíæ Tandem automatisch gespeichert', 'success', 2000);
        }

        function previewEmail() {
            if (!currentTandem) {
                showNotification('‚ùå Bitte w√§hle zuerst ein Tandem aus', 'error');
                return;
            }

            const subject = document.getElementById('email-subject').value;
            const introHtml = document.getElementById('email-intro-editor').innerHTML;
            const tandemLink = document.getElementById('tandem-link').value;

            // Ersetze Platzhalter in der Einleitung (nur Vornamen)
            const firstName1 = extractFirstName(currentTandem.profile1.name);
            const firstName2 = extractFirstName(currentTandem.profile2.name);

            const processedIntro = introHtml
                .replace(/\[NAME1\]/g, firstName1)
                .replace(/\[NAME2\]/g, firstName2);

            // Erstelle Tabelle
            const tableHtml = createHTMLVersionForClipboard();

            // Komplette E-Mail zusammenstellen
            const completeEmail = `
                <div class="email-subject-line">
                    <strong>Betreff:</strong> ${escapeHtml(subject)}
                </div>
                
                <div>
                    ${processedIntro}
                </div>
                
                ${tableHtml}
                
            `;

            // Zeige Vorschau
            document.getElementById('email-preview-content').innerHTML = completeEmail;
            document.getElementById('email-preview-section').classList.remove('hidden');

            // Scroll zur Vorschau
            document.getElementById('email-preview-section').scrollIntoView({ behavior: 'smooth' });
        }

        function hideEmailPreview() {
            document.getElementById('email-preview-section').classList.add('hidden');
        }

        function copyCompleteEmailToClipboard() {
            if (!currentTandem) {
                showNotification('‚ùå Keine E-Mail-Vorschau verf√ºgbar', 'error');
                return;
            }

            // Automatisch Tandem speichern BEVOR E-Mail kopiert wird
            console.log('üíæ Auto-Save: Speichere Tandem vor E-Mail-Kopieren...');
            saveTandemSilently();

            const subject = document.getElementById('email-subject').value;
            const introHtml = document.getElementById('email-intro-editor').innerHTML;
            const tandemLink = document.getElementById('tandem-link').value;

            // Erstelle Text- und HTML-Version
            const textVersion = createCompleteEmailText(subject, introHtml, tandemLink);
            const htmlVersion = createCompleteEmailHTML(subject, introHtml, tandemLink);

            if (navigator.clipboard && navigator.clipboard.write) {
                const clipboardItems = [
                    new ClipboardItem({
                        'text/html': new Blob([htmlVersion], { type: 'text/html' }),
                        'text/plain': new Blob([textVersion], { type: 'text/plain' })
                    })
                ];

                navigator.clipboard.write(clipboardItems).then(() => {
                    showNotification('üìß Komplette E-Mail in Zwischenablage kopiert (Word & E-Mail kompatibel)', 'success', 4000);
                }).catch(error => {
                    console.error('Clipboard API Error:', error);
                    fallbackCopyToClipboard(textVersion, htmlVersion);
                });
            } else {
                fallbackCopyToClipboard(textVersion, htmlVersion);
            }

            // Feedback f√ºr User
            showNotification('üíæ Tandem automatisch gespeichert', 'success', 2000);
        }

        function createCompleteEmailText(subject, introHtml, tandemLink) {
            // Konvertiere HTML zu Text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = introHtml;
            const introText = tempDiv.textContent || tempDiv.innerText || '';

            const firstName1 = extractFirstName(currentTandem.profile1.name);
            const firstName2 = extractFirstName(currentTandem.profile2.name);

            const processedIntro = introText
                .replace(/\[NAME1\]/g, firstName1)
                .replace(/\[NAME2\]/g, firstName2);

            const tableText = createTextVersionForClipboard();

            return `Betreff: ${subject}\n\n${processedIntro}\n\n${tableText}\n\nTandem-Link: ${tandemLink}\n`;
        }

        function createCompleteEmailHTML(subject, introHtml, tandemLink) {
            const firstName1 = extractFirstName(currentTandem.profile1.name);
            const firstName2 = extractFirstName(currentTandem.profile2.name);

            const processedIntro = introHtml
                .replace(/\[NAME1\]/g, firstName1)
                .replace(/\[NAME2\]/g, firstName2);

            const tableHtml = createHTMLVersionForClipboard();

            return `
                <!--StartFragment-->
                <html>
                <head>
                    <meta charset="utf-8">
                    <style>
                        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.5; }
                        .email-header { background: #f0f0f0; padding: 10px; border-radius: 4px; margin-bottom: 20px; }
                        .tandem-link { background: #fff3cd; padding: 15px; border-radius: 4px; margin: 20px 0; border-left: 4px solid #ffc107; }
                    </style>
                </head>
                <body>
                    <div class="email-header">
                        <strong>Betreff:</strong> ${escapeHtml(subject)}
                    </div>
                    
                    <div>
                        ${processedIntro}
                    </div>
                    
                    ${tableHtml}
                    
                </body>
                </html>
                <!--EndFragment-->
            `;
        }

        function downloadEmailAsHTML() {
            if (!currentTandem) {
                showNotification('‚ùå Keine E-Mail-Vorschau verf√ºgbar', 'error');
                return;
            }

            // Automatisch Tandem speichern BEVOR Download
            console.log('üíæ Auto-Save: Speichere Tandem vor Download...');
            saveTandemSilently();

            const subject = document.getElementById('email-subject').value;
            const introHtml = document.getElementById('email-intro-editor').innerHTML;
            const tandemLink = document.getElementById('tandem-link').value;

            const htmlContent = createCompleteEmailHTML(subject, introHtml, tandemLink);
            const filename = `SwaF_Email_${currentTandem.profile1.name}_${currentTandem.profile2.name}_${new Date().toISOString().split('T')[0]}.html`;

            downloadFile(htmlContent, filename, 'text/html');
            showNotification('üì• E-Mail als HTML-Datei gespeichert', 'success');
            showNotification('üíæ Tandem automatisch gespeichert', 'success', 2000);
        }

        // ===============================
        // EXPORT-FUNKTIONEN
        // ===============================
        function copyTandemToClipboard() {
            if (!currentTandem) return;

            // Automatisch Tandem speichern BEVOR kopiert wird
            console.log('üíæ Auto-Save: Speichere Tandem vor Kopieren...');
            saveTandemSilently();

            // Erstelle sowohl Text- als auch HTML-Version
            const textVersion = createTextVersionForClipboard();
            const htmlVersion = createHTMLVersionForClipboard();
            
            // Feedback f√ºr User (am Ende der Funktion)
            setTimeout(() => {
                showNotification('üíæ Tandem automatisch gespeichert', 'success', 2000);
            }, 500);

            // Moderne Clipboard API mit mehreren Formaten
            if (navigator.clipboard && navigator.clipboard.write) {
                const clipboardItems = [
                    new ClipboardItem({
                        'text/html': new Blob([htmlVersion], { type: 'text/html' }),
                        'text/plain': new Blob([textVersion], { type: 'text/plain' })
                    })
                ];

                navigator.clipboard.write(clipboardItems).then(() => {
                    showNotification('üìã Tandem als Tabelle in Zwischenablage kopiert (Word-kompatibel)', 'success');
                }).catch(error => {
                    console.error('Clipboard API Error:', error);
                    fallbackCopyToClipboard(textVersion, htmlVersion);
                });
            } else {
                fallbackCopyToClipboard(textVersion, htmlVersion);
            }
        }

        function createTextVersionForClipboard() {
            if (!currentTandem) return '';

            let text = `${currentTandem.name}\n`;
            text += '='.repeat(currentTandem.name.length) + '\n\n';

            // Tabellen-√§hnliche Formatierung f√ºr Plain Text
            const maxQuestionWidth = Math.max(...currentTandem.commonalities.map(c => c.question.length));
            const maxAnswer1Width = Math.max(...currentTandem.commonalities.map(c => c.answer1.length));
            const maxAnswer2Width = Math.max(...currentTandem.commonalities.map(c => c.answer2.length));

            // Header
            text += 'Frage'.padEnd(maxQuestionWidth + 2) + '| ';
            text += extractFirstName(currentTandem.profile1.name).padEnd(maxAnswer1Width + 2) + '| ';
            text += extractFirstName(currentTandem.profile2.name).padEnd(maxAnswer2Width + 2) + '| ';
            text += 'Gemeinsamkeiten\n';

            text += '-'.repeat(maxQuestionWidth + 2) + '+-';
            text += '-'.repeat(maxAnswer1Width + 2) + '+-';
            text += '-'.repeat(maxAnswer2Width + 2) + '+-';
            text += '-'.repeat(20) + '\n';

            // Datenzeilen
            currentTandem.commonalities.forEach(c => {
                text += c.question.padEnd(maxQuestionWidth + 2) + '| ';
                text += (c.answer1 || '').padEnd(maxAnswer1Width + 2) + '| ';
                text += (c.answer2 || '').padEnd(maxAnswer2Width + 2) + '| ';
                text += (c.commonality || '') + '\n';
            });

            return text;
        }

        function createHTMLVersionForClipboard() {
            if (!currentTandem) return '';

            // Word-optimierte HTML-Tabelle
            const html = `
                <!--StartFragment-->
                <html xmlns:o="urn:schemas-microsoft-com:office:office" 
                    xmlns:w="urn:schemas-microsoft-com:office:word">
                <head>
                    <meta charset="utf-8">
                    <meta name="ProgId" content="Word.Document">
                    <meta name="Generator" content="SwaF Tandem Matcher">
                    <meta name="Originator" content="SwaF Tandem Matcher v2.0">
                    <!--[if gte mso 9]>
                    <xml>
                        <w:WordDocument>
                            <w:View>Normal</w:View>
                            <w:Zoom>0</w:Zoom>
                            <w:DoNotPromptForConvert/>
                            <w:DoNotShowInsertionsAndDeletions/>
                        </w:WordDocument>
                    </xml>
                    <![endif]-->
                    <style>
                        table {
                            border-collapse: collapse;
                            width: 100%;
                            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                            font-size: 11pt;
                        }
                        .table-title {
                            font-size: 14pt;
                            font-weight: bold;
                            color: #C3003B;
                            margin-bottom: 10pt;
                            text-align: center;
                        }
                        th {
                            background-color: #009892;
                            color: white;
                            font-weight: bold;
                            padding: 8pt;
                            border: 1px solid #ddd;
                            text-align: left;
                            vertical-align: top;
                        }
                        td {
                            padding: 8pt;
                            border: 1px solid #ddd;
                            text-align: left;
                            vertical-align: top;
                            max-width: 200pt;
                            word-wrap: break-word;
                        }
                        .question-col {
                            background-color: #f8f9fa;
                            font-weight: bold;
                            width: 25%;
                        }
                        .answer-col {
                            width: 25%;
                        }
                        .commonality-col {
                            background-color: #E6FFFD;
                            font-weight: bold;
                            color: #009892;
                            width: 25%;
                        }
                        .empty-cell {
                            color: #999;
                            font-style: italic;
                        }
                    </style>
                </head>
                <body>
                    <table border="1" cellspacing="0" cellpadding="8">
                        <thead>
                            <tr>
                                <th class="question-col">Frage</th>
                                <th class="answer-col">${escapeHtml(extractFirstName(currentTandem.profile1.name))}</th>
                                <th class="answer-col">${escapeHtml(extractFirstName(currentTandem.profile2.name))}</th>
                                <th class="commonality-col">Gemeinsamkeiten</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${currentTandem.commonalities.map(c => `
                                <tr>
                                    <td class="question-col">${escapeHtml(c.question)}</td>
                                    <td class="answer-col">${c.answer1 ? escapeHtml(c.answer1) : '<span class="empty-cell">Keine Angabe</span>'}</td>
                                    <td class="answer-col">${c.answer2 ? escapeHtml(c.answer2) : '<span class="empty-cell">Keine Angabe</span>'}</td>
                                    <td class="commonality-col">${c.commonality ? escapeHtml(c.commonality) : '<span class="empty-cell">Keine √úbereinstimmung</span>'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    
                </body>
                </html>
                <!--EndFragment-->
            `;

            return html;
        }

        function fallbackCopyToClipboard(textVersion, htmlVersion) {
            // Fallback f√ºr √§ltere Browser
            const textarea = document.createElement('textarea');
            textarea.value = textVersion;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            showNotification('üìã Tandem in Zwischenablage kopiert (Text-Format)', 'success');
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function extractFirstName(fullName) {
            if (!fullName || typeof fullName !== 'string') {
                return 'Partner*in';
            }

            console.log(`üìõ Extrahiere Namen aus: "${fullName}"`);

            // 1. Suche nach Namen in Klammern (h√∂chste Priorit√§t)
            const bracketMatch = fullName.match(/\(([^)]+)\)/);
            if (bracketMatch) {
                const nameInBrackets = bracketMatch[1].trim();
                const firstName = nameInBrackets.split(/[\s,]+/)[0];
                if (firstName && firstName.length > 1 && !firstName.match(/^(locals?|einwander|interview|gespr√§ch)/i)) {
                    console.log(`‚úÖ Name aus Klammern extrahiert: "${firstName}"`);
                    return firstName;
                }
            }

            // 2. Pr√ºfe ob es ein direkter Name ohne Pr√§fix ist
            if (!fullName.match(/^(aufnahmegespr√§ch|interview|gespr√§ch)/i)) {
                const firstName = fullName.split(/[\s,]+/)[0];
                if (firstName && firstName.length > 1) {
                    console.log(`‚úÖ Direkter Name: "${firstName}"`);
                    return firstName;
                }
            }

            // 3. Fallback f√ºr komplexe F√§lle
            console.log(`‚ö†Ô∏è Fallback f√ºr: "${fullName}"`);
            return 'Partner*in';
        }

        // ===============================
        // VERWALTUNGS-FUNKTIONEN
        // ===============================
        function loadSavedTandems() {
            const container = document.getElementById('saved-tandems-list');

            if (tandems.length === 0) {
                container.innerHTML = '<p>Keine gespeicherten Tandems vorhanden.</p>';
                return;
            }

            container.innerHTML = tandems.map(tandem => `
                <div style="border: 1px solid #ddd; padding: 1rem; margin: 0.5rem 0; border-radius: 4px;">
                    <strong>${tandem.name}</strong>
                    <p><small>Erstellt: ${new Date(tandem.created).toLocaleString('de-DE')}</small></p>
                    <div>
                        <button onclick="editTandem('${tandem.id}')" class="btn btn-outline btn-small">‚úèÔ∏è Bearbeiten</button>
                        <button onclick="deleteSavedTandem('${tandem.id}')" class="btn btn-outline btn-small">üóëÔ∏è L√∂schen</button>
                    </div>
                </div>
            `).join('');
        }

        function editTandem(tandemId) {
            switchTab(3);
            document.getElementById('tandem-selector').value = tandemId;
            loadTandemForEditing();
        }

        function deleteSavedTandem(tandemId) {
            if (confirm('Tandem wirklich l√∂schen?')) {
                tandems = tandems.filter(t => t.id != tandemId);
                saveTandems();
                loadSavedTandems();
                updateStatistics();
                showNotification('Tandem gel√∂scht', 'success');
            }
        }

        function exportAllTandems() {
            if (tandems.length === 0) {
                showNotification('Keine Tandems zum Exportieren vorhanden.', 'warning');
                return;
            }

            const data = {
                tandems: tandems,
                profiles: profiles,
                exported: new Date().toISOString(),
                version: '2.0'
            };

            downloadFile(JSON.stringify(data, null, 2), `SwaF_Tandems_${new Date().toISOString().split('T')[0]}.json`, 'application/json');
        }

        function createAutoBackupManual() {
            if (createAutoBackup()) {
                showNotification('‚úÖ Session gespeichert - wird beim n√§chsten Laden wiederhergestellt', 'success', 4000);
            } else {
                showNotification('‚ùå Fehler beim Speichern der Session', 'error');
            }
        }

        function exportAppData() {
            const data = {
                profiles: profiles,
                tandems: tandems,
                selectedFields: selectedFields,
                textTemplates: textTemplates,
                predefinedTemplates: predefinedTemplates,
                contextualTemplates: JSON.parse(localStorage.getItem('swaf_contextual_templates') || '{}'),
                questionCategoryMapping: JSON.parse(localStorage.getItem('swaf_question_category_mapping') || '{}'),
                emailTemplate: emailTemplate,
                plzCache: plzCache,
                autoClipboardDetection: localStorage.getItem('swaf_auto_clipboard_detection') !== 'false',
                exported: new Date().toISOString(),
                version: '2.1'
            };

            downloadFile(JSON.stringify(data, null, 2), `SwaF_Komplett-Backup_${new Date().toISOString().split('T')[0]}.json`, 'application/json');
            showNotification('‚úÖ Vollst√§ndiges Backup erfolgreich erstellt', 'success');
        }

        // ===============================
        // EXCEL-EXPORT FUNKTIONEN
        // ===============================
        function exportProfilesToExcel() {
            console.log('üìä Starte Excel-Export f√ºr alle Profile...');
            
            if (profiles.length === 0) {
                showNotification('‚ùå Keine Profile zum Exportieren vorhanden', 'error');
                return;
            }

            try {
                // Sammle alle eindeutigen Fragen aus allen Profilen
                const allQuestions = new Set();
                profiles.forEach(profile => {
                    profile.fields.forEach(field => {
                        // Filtere sensible Daten
                        const question = field.question.toLowerCase();
                        if (!question.includes('email') &&
                            !question.includes('e-mail') &&
                            !question.includes('telefon') &&
                            !question.includes('nachname') &&
                            !question.includes('passwort')) {
                            allQuestions.add(field.question);
                        }
                    });
                });

                const questionsList = Array.from(allQuestions).sort();
                
                // Erstelle Header-Zeile
                const headers = ['Name', 'Anzahl Felder', 'Gesammelt am', ...questionsList];
                
                // Erstelle Datenzeilen
                const rows = profiles.map(profile => {
                    const row = {
                        'Name': profile.name,
                        'Anzahl Felder': profile.fields.length,
                        'Gesammelt am': new Date(profile.timestamp).toLocaleString('de-DE')
                    };
                    
                    // F√ºge Antworten f√ºr jede Frage hinzu
                    questionsList.forEach(question => {
                        const field = profile.fields.find(f => f.question === question);
                        row[question] = field ? field.answer : '';
                    });
                    
                    return row;
                });

                // Erstelle Workbook
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(rows, { header: headers });
                
                // Setze Spaltenbreiten
                const colWidths = headers.map(header => {
                    if (header === 'Name') return { wch: 25 };
                    if (header === 'Anzahl Felder') return { wch: 15 };
                    if (header === 'Gesammelt am') return { wch: 20 };
                    return { wch: 30 };
                });
                ws['!cols'] = colWidths;

                // F√ºge Worksheet zum Workbook hinzu
                XLSX.utils.book_append_sheet(wb, ws, 'Profile');

                // Zus√§tzliches Worksheet mit Statistiken
                const statsData = [
                    { 'Statistik': 'Anzahl Profile', 'Wert': profiles.length },
                    { 'Statistik': 'Anzahl Tandems', 'Wert': tandems.length },
                    { 'Statistik': 'Durchschn. Felder pro Profil', 'Wert': Math.round(profiles.reduce((sum, p) => sum + p.fields.length, 0) / profiles.length) },
                    { 'Statistik': 'Export Datum', 'Wert': new Date().toLocaleString('de-DE') }
                ];
                const statsWs = XLSX.utils.json_to_sheet(statsData);
                XLSX.utils.book_append_sheet(wb, statsWs, 'Statistiken');

                // Generiere Excel-Datei
                const filename = `SwaF_Profile_Export_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(wb, filename);

                showNotification(`‚úÖ ${profiles.length} Profile als Excel exportiert`, 'success');
                console.log('‚úÖ Excel-Export erfolgreich abgeschlossen');
                
            } catch (error) {
                console.error('‚ùå Fehler beim Excel-Export:', error);
                showNotification('‚ùå Fehler beim Excel-Export: ' + error.message, 'error');
            }
        }

        function importAppData() {
            document.getElementById('import-data-input').click();
        }

        function handleDataImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (confirm('M√∂chtest du die importierten Daten mit den vorhandenen zusammenf√ºhren (Ja) oder alle vorhandenen Daten ersetzen (Nein)?')) {
                        // Zusammenf√ºhren
                        if (data.profiles) profiles.push(...data.profiles);
                        if (data.tandems) tandems.push(...data.tandems);
                        if (data.selectedFields) selectedFields.push(...data.selectedFields.filter(f => !selectedFields.includes(f)));
                        if (data.textTemplates) textTemplates.push(...data.textTemplates);
                        if (data.predefinedTemplates) {
                            predefinedTemplates.push(...data.predefinedTemplates.filter(t => 
                                !predefinedTemplates.some(existing => existing.title === t.title)
                            ));
                        }
                    } else {
                        // Ersetzen
                        if (data.profiles) profiles = data.profiles;
                        if (data.tandems) tandems = data.tandems;
                        if (data.selectedFields) selectedFields = data.selectedFields;
                        if (data.textTemplates) textTemplates = data.textTemplates;
                        if (data.predefinedTemplates) {
                            predefinedTemplates.length = 0;
                            predefinedTemplates.push(...data.predefinedTemplates);
                        }
                        if (data.contextualTemplates) {
                            localStorage.setItem('swaf_contextual_templates', JSON.stringify(data.contextualTemplates));
                        }
                        if (data.questionCategoryMapping) {
                            localStorage.setItem('swaf_question_category_mapping', JSON.stringify(data.questionCategoryMapping));
                        }
                        if (data.emailTemplate) emailTemplate = data.emailTemplate;
                        if (data.plzCache) {
                            plzCache = data.plzCache;
                            localStorage.setItem('swaf_plz_cache', JSON.stringify(plzCache));
                        }
                        if (data.hasOwnProperty('autoClipboardDetection')) {
                            localStorage.setItem('swaf_auto_clipboard_detection', data.autoClipboardDetection ? 'true' : 'false');
                        }
                    }

                    saveAllData();
                    localStorage.setItem('swaf_text_templates', JSON.stringify(textTemplates));
                    localStorage.setItem('swaf_predefined_templates', JSON.stringify(predefinedTemplates));
                    localStorage.setItem('swaf_email_template', JSON.stringify(emailTemplate));
                    
                    updateUI();
                    loadEmailTemplate();
                    loadPredefinedTemplates();
                    
                    showNotification('‚úÖ Vollst√§ndiges Backup erfolgreich wiederhergestellt', 'success');

                } catch (error) {
                    showNotification('‚ùå Fehler beim Importieren: ' + error.message, 'error');
                }
            };

            reader.readAsText(file);
        }

        function clearProfiles() {
            if (confirm('Wirklich alle Profile l√∂schen?')) {
                profiles = [];
                saveProfiles();
                updateUI();
                showNotification('Alle Profile gel√∂scht', 'success');
            }
        }

        function clearTandems() {
            if (confirm('Wirklich alle Tandems l√∂schen?')) {
                tandems = [];
                saveTandems();
                updateStatistics();
                loadSavedTandems();
                showNotification('Alle Tandems gel√∂scht', 'success');
            }
        }

        function clearAllProfiles() {
            if (confirm('Wirklich alle Profile l√∂schen?')) {
                profiles = [];
                saveProfiles();
                updateUI();
                showNotification('Alle Profile gel√∂scht', 'success');
            }
        }

        function resetAllData() {
            if (confirm('ACHTUNG: Alle Daten werden unwiederbringlich gel√∂scht!\n\nBist du sicher?')) {
                if (confirm('Letzte Warnung: Diese Aktion l√∂scht ALLE Profile, Tandems und Einstellungen!')) {
                    localStorage.clear();
                    location.reload();
                }
            }
        }

        function removeProfile(profileId) {
            if (confirm('Profil wirklich l√∂schen?')) {
                profiles = profiles.filter(p => p.id != profileId);
                saveProfiles();
                updateUI();
                showNotification('Profil gel√∂scht', 'success');
            }
        }

        // ===============================
        // TEXTBAUSTEIN-FUNKTIONEN
        // ===============================
        function initializeTextTemplates() {
            console.log('üìù Initialisiere Textbausteine...');
            
            // Initialisiere vordefinierte Templates
            initializePredefinedTemplates();

            // Lade vordefinierte Templates falls noch keine existieren
            if (textTemplates.length === 0) {
                textTemplates = [...predefinedTemplates];
                saveTextTemplates();
            }

            loadTextTemplates();
            
            // NEU: Stelle sicher, dass allgemeine Templates geladen werden
            setTimeout(() => {
                loadPredefinedTemplates();
                console.log('üìã Allgemeine Templates geladen:', predefinedTemplates.length);
            }, 200);
        }

        function loadTextTemplates() {
            const container = document.getElementById('saved-templates');
            if (!container) {
                console.log('‚ÑπÔ∏è saved-templates Container nicht vorhanden (wurde entfernt)');
                return;
            }

            if (textTemplates.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: var(--swaf-dark-gray); font-style: italic; padding: 1rem;">Noch keine eigenen Textbausteine gespeichert.</p>';
                return;
            }

            container.innerHTML = textTemplates.map((template, index) => `
                <div style="border: 1px solid #ddd; padding: 0.5rem; margin: 0.5rem 0; border-radius: 4px; background: white;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div style="flex: 1;" ondblclick="insertTemplate('${template.text.replace(/'/g, "\\'")}')">
                            <strong style="color: var(--swaf-red);">${template.title}</strong><br>
                            <span style="font-size: 0.9rem; color: var(--swaf-dark-gray);">${template.text}</span>
                        </div>
                        <button onclick="removeTemplate(${index})" 
                                style="background: var(--swaf-red); color: white; border: none; padding: 0.2rem 0.4rem; border-radius: 3px; cursor: pointer; margin-left: 0.5rem;">
                            ‚ùå
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function saveTextTemplate() {
            const title = document.getElementById('template-title').value.trim();
            const text = document.getElementById('template-text').value.trim();

            if (!title || !text) {
                showNotification('Bitte Titel und Text eingeben.', 'warning');
                return;
            }

            // Pr√ºfe auf Duplikate
            if (textTemplates.some(t => t.title === title)) {
                if (!confirm(`Textbaustein "${title}" existiert bereits. √úberschreiben?`)) {
                    return;
                }
                textTemplates = textTemplates.filter(t => t.title !== title);
            }

            textTemplates.push({ title, text });
            saveTextTemplates();
            loadTextTemplates();

            // Eingabefelder leeren
            document.getElementById('template-title').value = '';
            document.getElementById('template-text').value = '';

            showNotification(`‚úÖ Textbaustein "${title}" gespeichert`, 'success');
        }

        function removeTemplate(index) {
            const template = textTemplates[index];
            if (confirm(`Textbaustein "${template.title}" wirklich l√∂schen?`)) {
                textTemplates.splice(index, 1);
                saveTextTemplates();
                loadTextTemplates();
                showNotification(`Textbaustein "${template.title}" gel√∂scht`, 'success');
            }
        }

        function insertTemplate(text) {
            // Finde die aktuell ausgew√§hlte/fokussierte Zelle
            const focusedCell = document.activeElement;

            if (focusedCell && focusedCell.contentEditable === 'true') {
                // F√ºge Text in die fokussierte Zelle ein
                const currentText = focusedCell.textContent.trim();
                if (currentText && !currentText.includes(text)) {
                    focusedCell.textContent = currentText + '; ' + text;
                } else if (!currentText) {
                    focusedCell.textContent = text;
                }

                // Zelle hervorheben
                focusedCell.style.background = 'var(--swaf-lightest-teal)';
                setTimeout(() => {
                    focusedCell.style.background = '';
                }, 1000);

                showNotification('‚úÖ Textbaustein eingef√ºgt', 'success', 2000);
            } else {
                // Fallback: Kopiere in Zwischenablage
                navigator.clipboard.writeText(text).then(() => {
                    showNotification('üìã Textbaustein in Zwischenablage kopiert. Klicke in eine Zelle und f√ºge mit Strg+V ein.', 'info', 4000);
                }).catch(() => {
                    showNotification('Bitte klicke zuerst in eine Gemeinsamkeiten-Zelle.', 'warning');
                });
            }
        }

        function clearAllTemplates() {
            if (confirm('Wirklich alle eigenen Textbausteine l√∂schen?')) {
                textTemplates = [];
                saveTextTemplates();
                loadTextTemplates();
                showNotification('Alle Textbausteine gel√∂scht', 'success');
            }
        }

        function saveTextTemplates() {
            localStorage.setItem('swaf_text_templates', JSON.stringify(textTemplates));
        }

        // ===============================
        // FLOATING TEMPLATES SYSTEM
        // ===============================
        function initializeFloatingTemplates() {
            // Event Listener f√ºr Tabellenzellen hinzuf√ºgen
            document.addEventListener('click', function (e) {
                if (e.target.closest('#tandem-table')) {
                    const cell = e.target.closest('td[contenteditable="true"]');
                    if (cell) {
                        handleCellFocus(cell);
                    }
                }
            });

            // Event Listener f√ºr Escape-Taste
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape' && floatingTemplatesVisible) {
                    hideFloatingTemplates();
                }
            });
        }

        function handleCellFocus(cell) {
            activeTemplateCell = cell;

            // Bestimme Kontext basierend auf der Frage in der gleichen Zeile
            const row = cell.closest('tr');
            const questionCell = row?.querySelector('td:first-child');
            const question = questionCell?.textContent?.toLowerCase() || '';

            console.log('üéØ Zelle fokussiert, Frage:', question);

            // Erkenne Kontext
            let context = detectQuestionContext(question);

            if (context) {
                showContextualTemplates(context, question);
            } else {
                showGeneralTemplates();
            }
        }

        function detectQuestionContext(question) {
            const contextMappings = {
                'alter': ['alter', 'geburt', 'age', 'altersunterschied', 'geboren', 'geburtstag', 'wie gro√ü darf der altersunterschied'],
                'hobby': ['hobby', 'interesse', 'freizeit', 'sport', 'aktivit√§t', 'machst du gerne', 'ausprobieren', 'gibt es etwas neues', 'hobbys'],
                'beruf': ['beruf', 'arbeit', 'job', 'branche', 't√§tig', 'was machst du gerade', 'vorher gemacht', 'gelernt', 'was machst du'],
                'community': ['community', 'event', 'unternehmen', 'anbieten m√∂chtest', 'bei einem community-event'],
                'sprache': ['sprache', 'language', 'sprichst', 'deutsch', 'welche sprachen'],
                'postleitzahl': ['postleitzahl', 'plz'],
                'wohnort': ['wohnort', 'standort', 'ort', 'wohnen', 'adresse', 'region'],
                'studium': ['studium', 'ausbildung', 'schule', 'hochschule', 'uni', 'abschluss', 'zeugnis', 'schonmal ein studium'],
                'zeit': ['zeit', 'treffen', 'verf√ºgbar', 'wann hast du zeit'],
                'verkehr': ['verkehr', 'bewegst', 'transport', 'anreisen', 'wie bewegst du dich', 'wie lange kannst du anreisen'],
                'freundschaft': ['freundschaft', 'wichtig', 'tandem vor', 'wie stellst du dir'],
                'kinder': ['kinder', 'kindern anmelden'],
                'community': ['community', 'event', 'unternehmen', 'anbieten m√∂chtest'],
                'erreichen': ['erreichen', 'kontakt', 'wie kann man dich'],
                'geschlecht': ['geschlecht', 'tandempartner'],
                'schwerpunkt': ['schwerpunkt', 'zus√§tzlich'],
                
                // NEUE KATEGORIEN basierend auf den Logs:
                'motivation': ['warum m√∂chtest du', 'bei swaf mitmachen'],
                'herkunft_swaf': ['woher kennst du swaf'],
                'einwanderung': ['in welchem land bist du geboren', 'bist du in deutschland geboren', 'seit wann lebst du in deutschland'],
                'zukunft': ['was m√∂chtest du in zukunft', 'gerne machen'],
                'themen': ['gibt es themen', 'besonders interessieren'],
                'name': ['vorname', 'nachname'],
                'gruppe': ['gruppe'],
                'vermittlung': ['vermittler', 'durchgef√ºhrt von'],
                'eindruck': ['wie wirkt die person auf dich'],
                'matching_hinweise': ['worauf sollte bei der auswahl', 'tandempartner'],
                'herausforderungen': ['gibt es besondere herausforderungen'],
                'kontakt': ['e-mail', 'telefon', 'adresse'],
                'termine': ['datum', 'uhrzeit', 'terminart', 'infoabend'],
                'status': ['status', 'durchgef√ºhrt']
            };

            for (const [context, keywords] of Object.entries(contextMappings)) {
                if (keywords.some(keyword => question.toLowerCase().includes(keyword.toLowerCase()))) {
                    console.log(`üéØ Kontext erkannt: "${context}" f√ºr Frage: "${question}"`);
                    return context;
                }
            }

            console.log(`‚ùì Kein spezifischer Kontext f√ºr: "${question}"`);
            return null;
        }

        function showContextualTemplates(context, question) {
            currentContextQuestion = question;
            const contextTemplates = contextualTemplates[context] || [];

            // Kombiniere kontextspezifische und ALLE allgemeinen Templates
            const allTemplates = [
                ...contextTemplates,
                ...predefinedTemplates.map(t => ({ text: t.text, priority: false, source: 'allgemein' }))
            ];

            updateFloatingTemplatesContent(allTemplates, `${getContextDisplayName(context)}: ${question}`);
            showFloatingTemplates();
        }

        function getContextDisplayName(context) {
            const displayNames = {
                'alter': 'Alter',
                'hobby': 'Hobbys',
                'sprache': 'Sprachen',
                'postleitzahl': 'Wohnort',
                'wohnort': 'Wohnort',
                'beruf': 'Beruf',
                'studium': 'Bildung',
                'zeit': 'Zeitplanung',
                'verkehr': 'Mobilit√§t'
            };

            return displayNames[context] || 'Kontext';
        }

        function getRelevantGeneralTemplates(context) {
            // W√§hle passende allgemeine Templates basierend auf Kontext
            const relevantTitles = {
                'alter': ['Voneinander lernen', 'Neue Erfahrungen'],
                'hobby': ['Erg√§nzende Unterschiede', 'Neue Erfahrungen'],
                'sprache': ['Gegenseitige Unterst√ºtzung', 'Voneinander lernen'],
                'postleitzahl': ['Gut erreichbar', 'Flexibel'],
                'wohnort': ['Gut erreichbar', 'Gleiche Stadt'],
                'beruf': ['Voneinander lernen', 'Gegenseitige Unterst√ºtzung'],
                'studium': ['Voneinander lernen', '√Ñhnliche Lebenssituation'],
                'zeit': ['Flexibel', 'Wochenende'],
                'verkehr': ['Gut erreichbar', '√ñffentliche Verkehrsmittel']
            };

            const titles = relevantTitles[context] || ['Voneinander lernen'];

            return predefinedTemplates
                .filter(template => titles.includes(template.title))
                .map(template => ({ text: template.text, priority: false }));
        }

        function showGeneralTemplates() {
            const generalTemplates = predefinedTemplates
                .slice(0, 10) // Erste 10 Templates
                .map(template => ({ text: template.text, priority: false }));

            updateFloatingTemplatesContent(generalTemplates, 'Allgemeine Vorschl√§ge');
            showFloatingTemplates();
        }

        function updateFloatingTemplatesContent(templates, title) {
            const titleElement = document.getElementById('floating-templates-title');
            const contentElement = document.getElementById('floating-templates-content');

            titleElement.textContent = title;

            // Gruppiere nach Priorit√§t und Quelle
            const priorityTemplates = templates.filter(t => t.priority);
            const specificTemplates = templates.filter(t => !t.priority && !t.source);
            const generalTemplates = templates.filter(t => t.source === 'allgemein');

            let html = '<div style="max-height: 400px; overflow-y: auto; padding-right: 0.5rem;">';

            if (priorityTemplates.length > 0) {
                html += '<div class="template-category">';
                html += '<div class="template-category-title">‚≠ê Empfohlen</div>';
                priorityTemplates.forEach(template => {
                    html += `<button class="floating-template-btn priority" onclick="insertFloatingTemplate('${template.text.replace(/'/g, "\\'")}')">
                        ${template.text}
                    </button>`;
                });
                html += '</div>';
            }

            if (specificTemplates.length > 0) {
                html += '<div class="template-category">';
                html += '<div class="template-category-title">üéØ Fragespezifisch</div>';
                specificTemplates.forEach(template => {
                    html += `<button class="floating-template-btn" onclick="insertFloatingTemplate('${template.text.replace(/'/g, "\\'")}')">
                        ${template.text}
                    </button>`;
                });
                html += '</div>';
            }

            if (generalTemplates.length > 0) {
                html += '<div class="template-category">';
                html += '<div class="template-category-title">üìã Allgemeine Vorschl√§ge</div>';
                generalTemplates.forEach(template => {
                    html += `<button class="floating-template-btn" onclick="insertFloatingTemplate('${template.text.replace(/'/g, "\\'")}')">
                        ${template.text}
                    </button>`;
                });
                html += '</div>';
            }

            html += '</div>'; // Schlie√üt das scrollbare div

            contentElement.innerHTML = html;
        }

        function insertFloatingTemplate(text) {
            if (activeTemplateCell) {
                const currentText = activeTemplateCell.textContent.trim();

                if (currentText && !currentText.includes(text)) {
                    activeTemplateCell.textContent = currentText + '; ' + text;
                } else if (!currentText) {
                    activeTemplateCell.textContent = text;
                }

                // Visuelles Feedback
                activeTemplateCell.style.background = 'var(--swaf-lightest-teal)';
                setTimeout(() => {
                    activeTemplateCell.style.background = '';
                }, 1000);

                // Template-Panel ausblenden nach Einf√ºgung
                hideFloatingTemplates();

                showNotification('‚úÖ Formulierung eingef√ºgt', 'success', 2000);
            }
        }

        function showFloatingTemplates() {
            const panel = document.getElementById('floating-templates');
            const toggle = document.getElementById('floating-templates-toggle');

            panel.classList.add('visible');
            toggle.style.display = 'none';
            floatingTemplatesVisible = true;
        }

        function hideFloatingTemplates() {
            const panel = document.getElementById('floating-templates');
            const toggle = document.getElementById('floating-templates-toggle');

            panel.classList.remove('visible');
            toggle.style.display = 'block';
            floatingTemplatesVisible = false;
            activeTemplateCell = null;
        }

        function toggleFloatingTemplates() {
            if (floatingTemplatesVisible) {
                hideFloatingTemplates();
            } else {
                showGeneralTemplates();
            }
        }

        // ===============================
        // KONTEXTUELLE TEMPLATES
        // ===============================
        function editContextualTemplates() {
            loadContextualTemplatesFromStorage();
            
            // Extrahiere alle Fragen aus den Profilen
            const profileQuestions = extractQuestionsFromProfiles();
            
            const modal = createModal('üìù Fragespezifische Formulierungen bearbeiten', `
                <div style="max-height: 600px; overflow-y: auto;">
                    <div style="margin-bottom: 1rem;">
                        <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1rem;">
                            <button class="btn btn-primary" onclick="addNewContextCategory()">‚ûï Neue Kategorie</button>
                            <button class="btn btn-outline" onclick="resetContextualTemplates()">üîÑ Auf Standard zur√ºcksetzen</button>
                            <button class="btn btn-outline" onclick="exportContextualTemplates()">üì§ Exportieren</button>
                            <button class="btn btn-outline" onclick="importContextualTemplates()">üì• Importieren</button>
                        </div>
                    </div>
                    
                    <div id="contextual-templates-editor">
                        ${generateContextualTemplatesHTML()}
                    </div>
                    
                    <div style="margin-top: 2rem; padding: 1rem; background: var(--swaf-lightest-teal); border-radius: 4px;">
                        <h4>üí° Verf√ºgbare Kontext-Kategorien:</h4>
                        <p style="font-size: 0.9rem; margin: 0.5rem 0;">
                            <strong>alter:</strong> Alters-bezogene Fragen<br>
                            <strong>hobby:</strong> Hobbys, Interessen, Freizeit, Sport<br>
                            <strong>sprache:</strong> Sprachen, Deutsch, Kommunikation<br>
                            <strong>postleitzahl:</strong> PLZ-Felder<br>
                            <strong>wohnort:</strong> Wohnort, Standort, Adresse<br>
                            <strong>beruf:</strong> Beruf, Arbeit, Branche<br>
                            <strong>studium:</strong> Bildung, Studium, Ausbildung<br>
                            <strong>zeit:</strong> Zeitplanung, Verf√ºgbarkeit<br>
                            <strong>verkehr:</strong> Mobilit√§t, Transport, Anreise
                        </p>
                    </div>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Speichern & Schlie√üen', class: 'btn-primary', action: 'saveContextualTemplates' }
            ]);
        }

        function loadContextualTemplatesFromStorage() {
            const saved = localStorage.getItem('swaf_contextual_templates');
            if (saved) {
                try {
                    const savedTemplates = JSON.parse(saved);
                    if (savedTemplates && typeof savedTemplates === 'object') {
                        contextualTemplates = savedTemplates;
                        console.log('‚úÖ Gespeicherte kontextspezifische Templates geladen');
                    }
                } catch (error) {
                    console.error('‚ùå Fehler beim Laden der kontextspezifischen Templates:', error);
                }
            }
            
            // Lade auch die Fragen-Zuordnungen
            const savedMapping = localStorage.getItem('swaf_question_category_mapping');
            if (savedMapping) {
                try {
                    questionCategoryMapping = JSON.parse(savedMapping);
                    console.log('‚úÖ Gespeicherte Fragen-Zuordnungen geladen:', Object.keys(questionCategoryMapping).length, 'Zuordnungen');
                } catch (error) {
                    console.error('‚ùå Fehler beim Laden der Fragen-Zuordnungen:', error);
                    questionCategoryMapping = {};
                }
            }
        }

        function saveContextualTemplates() {
            localStorage.setItem('swaf_contextual_templates', JSON.stringify(contextualTemplates));
            closeModal();
            showNotification('‚úÖ Fragespezifische Formulierungen gespeichert', 'success');
        }

        // ===============================
        // PLZ-DISTANZBERECHNUNG
        // ===============================
        async function getPLZCoordinates(plz) {
            if (!plz || plz.length !== 5) return null;

            // Pr√ºfe Cache
            if (plzCache[plz]) {
                console.log(`üìç PLZ ${plz} aus Cache geladen:`, plzCache[plz]);
                return plzCache[plz];
            }

            try {
                // Rate Limiting
                const now = Date.now();
                if (now - lastApiCall < API_DELAY) {
                    await new Promise(resolve => setTimeout(resolve, API_DELAY - (now - lastApiCall)));
                }
                lastApiCall = Date.now();

                console.log(`üåê Lade PLZ ${plz} von OpenStreetMap...`);

                // Nominatim API Call
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&country=DE&postalcode=${plz}&limit=1`, {
                    headers: {
                        'User-Agent': 'SwaF Tandem Matcher v2.0'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data && data.length > 0) {
                    const coords = [parseFloat(data[0].lat), parseFloat(data[0].lon)];

                    // Speichere in Cache
                    plzCache[plz] = coords;
                    localStorage.setItem('swaf_plz_cache', JSON.stringify(plzCache));

                    console.log(`‚úÖ PLZ ${plz} gefunden:`, coords);
                    return coords;
                } else {
                    console.log(`‚ùå PLZ ${plz} nicht gefunden`);
                    return null;
                }

            } catch (error) {
                console.error(`‚ùå Fehler beim Laden von PLZ ${plz}:`, error);
                return null;
            }
        }

        // Cache f√ºr Routing-Ergebnisse
        let routingCache = JSON.parse(localStorage.getItem('swaf_routing_cache') || '{}');

        async function calculatePLZDistanceAdvanced(plz1, plz2) {
            if (!plz1 || !plz2) return null;
            if (plz1 === plz2) return { 
                distance: 0, 
                type: 'same',
                mapsLinks: generateMapsLinks(plz1, plz2),
                routingInfo: 'Identische PLZ'
            };

            try {
                const coords1 = await getPLZCoordinates(plz1);
                const coords2 = await getPLZCoordinates(plz2);

                if (!coords1 || !coords2) {
                    console.log(`‚ùå Koordinaten nicht verf√ºgbar f√ºr PLZ ${plz1} oder ${plz2}`);
                    return null;
                }

                // Luftlinien-Entfernung als Fallback
                const airDistance = calculateHaversineDistance(
                    coords1[0], coords1[1],
                    coords2[0], coords2[1]
                );

                // Maps-Links f√ºr genaue Navigation
                const mapsLinks = generateMapsLinks(plz1, plz2);

                // Versuche echte Routing-Distanz zu bekommen
                let routingResult = null;
                try {
                    routingResult = await getRoutingDistance(coords1, coords2, plz1, plz2);
                } catch (error) {
                    console.log('‚ö†Ô∏è Routing API nicht verf√ºgbar, verwende Luftlinie:', error.message);
                }

                // Verwende Routing-Distanz wenn verf√ºgbar, sonst Luftlinie
                const actualDistance = routingResult ? routingResult.distance : Math.round(airDistance * 1.3); // Luftlinie * 1.3 als Sch√§tzung
                const actualTimes = routingResult ? routingResult.times : estimateTimesFromAirDistance(airDistance);

                return {
                    distance: Math.round(actualDistance),
                    airDistance: Math.round(airDistance),
                    routingDistance: routingResult ? Math.round(routingResult.distance) : null,
                    estimatedTimes: actualTimes,
                    mapsLinks: mapsLinks,
                    routingInfo: routingResult ? 'Echte Routing-Distanz' : 'Gesch√§tzt aus Luftlinie (√ó1.3)',
                    type: actualDistance <= 5 ? 'very_close' :
                        actualDistance <= 15 ? 'close' :
                            actualDistance <= 30 ? 'medium' :
                                actualDistance <= 50 ? 'far' : 'very_far'
                };

            } catch (error) {
                console.error('‚ùå Fehler bei PLZ-Distanzberechnung:', error);
                return null;
            }
        }

        // Generiere Maps-Links f√ºr verschiedene Services
        function generateMapsLinks(plz1, plz2) {
            const googleMapsLink = `https://www.google.de/maps/dir/${encodeURIComponent(plz1)}/${encodeURIComponent(plz2)}`;
            const googleMapsTransit = `https://www.google.de/maps/dir/${encodeURIComponent(plz1)}/${encodeURIComponent(plz2)}/data=!3m1!4b1!4m2!4m1!3e3`; // √ñPNV
            const openStreetMapLink = `https://www.openstreetmap.org/directions?from=${encodeURIComponent(plz1)}&to=${encodeURIComponent(plz2)}`;
            
            return {
                googleMaps: googleMapsLink,
                googleMapsTransit: googleMapsTransit,
                openStreetMap: openStreetMapLink,
                // BVG/MVV je nach Region  
                localTransit: generateLocalTransitLink(plz1, plz2)
            };
        }

        // Generiere lokale √ñPNV-Links
        function generateLocalTransitLink(plz1, plz2) {
            // Berlin: BVG
            if ((plz1.startsWith('10') || plz1.startsWith('12') || plz1.startsWith('13')) &&
                (plz2.startsWith('10') || plz2.startsWith('12') || plz2.startsWith('13'))) {
                return `https://www.bvg.de/de/verbindungen?from=${plz1}&to=${plz2}`;
            }
            
            // M√ºnchen: MVV
            if (plz1.startsWith('80') || plz1.startsWith('81') || plz1.startsWith('82')) {
                return `https://www.mvv-muenchen.de/fahrplanauskunft/?from=${plz1}&to=${plz2}`;
            }
            
            // Hamburg: HVV
            if (plz1.startsWith('20') || plz1.startsWith('21') || plz1.startsWith('22')) {
                return `https://geofox.hvv.de/jsf/home.seam?from=${plz1}&to=${plz2}`;
            }
            
            // Fallback: Deutsche Bahn
            return `https://reiseauskunft.bahn.de/bin/query.exe/dn?S=${plz1}&Z=${plz2}`;
        }

        // OSRM (Open Source Routing Machine) - CORS-freundlich und kostenlos
        async function getRoutingDistance(coords1, coords2, plz1, plz2) {
            const cacheKey = `${plz1}-${plz2}`;
            
            // Pr√ºfe Cache
            if (routingCache[cacheKey]) {
                console.log(`üîÑ Routing aus Cache: ${plz1} ‚Üí ${plz2}`);
                return routingCache[cacheKey];
            }
            
            // Rate Limiting
            const now = Date.now();
            if (now - lastApiCall < API_DELAY) {
                await new Promise(resolve => setTimeout(resolve, API_DELAY - (now - lastApiCall)));
            }
            lastApiCall = Date.now();

            try {
                // OSRM API - unterst√ºtzt CORS und ist kostenlos
                const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${coords1[1]},${coords1[0]};${coords2[1]},${coords2[0]}?overview=false&alternatives=false&steps=false`;
                
                console.log(`üåê OSRM API Call: ${plz1} ‚Üí ${plz2}`);
                
                const response = await fetch(osrmUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                
                if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    const distanceKm = route.distance / 1000;
                    const durationMin = route.duration / 60;
                    
                    // Erweiterte Verkehrsmittel-Sch√§tzungen basierend auf echter Auto-Route
                    const result = {
                        distance: distanceKm,
                        times: {
                            driving: Math.round(durationMin),
                            // √ñPNV: 1.8x Auto-Zeit f√ºr Umsteigen + Wartezeiten
                            transit: Math.round(durationMin * 1.8), 
                            // Fahrrad: Realistische Geschwindigkeit je nach Distanz
                            cycling: Math.round(calculateCyclingTime(distanceKm)),
                            // Gehen: Realistische Geschwindigkeit
                            walking: Math.round(distanceKm * 12) // 5 km/h
                        }
                    };

                    // Cache speichern
                    routingCache[cacheKey] = result;
                    routingCache[`${plz2}-${plz1}`] = result; // Beide Richtungen
                    localStorage.setItem('swaf_routing_cache', JSON.stringify(routingCache));
                    
                    console.log(`‚úÖ OSRM Routing: ${plz1} ‚Üí ${plz2} = ${distanceKm.toFixed(1)}km, üöó${Math.round(durationMin)}min`);
                    return result;
                } else {
                    throw new Error(`OSRM API Error: ${data.code || 'Keine Route gefunden'}`);
                }

            } catch (error) {
                console.log(`‚ö†Ô∏è OSRM Routing API Fehler f√ºr ${plz1} ‚Üí ${plz2}:`, error.message);
                
                // Fallback zu GraphHopper (auch CORS-freundlich)
                try {
                    return await getGraphHopperDistance(coords1, coords2, plz1, plz2);
                } catch (fallbackError) {
                    console.log(`‚ö†Ô∏è GraphHopper Fallback auch fehlgeschlagen:`, fallbackError.message);
                    throw error;
                }
            }
        }

        // Fallback: GraphHopper API (kostenlos mit Limits)
        async function getGraphHopperDistance(coords1, coords2, plz1, plz2) {
            console.log(`üîÑ Fallback zu GraphHopper: ${plz1} ‚Üí ${plz2}`);
            
            // GraphHopper API - kostenlos bis 2500 Requests/Tag
            const ghUrl = `https://graphhopper.com/api/1/route?point=${coords1[0]},${coords1[1]}&point=${coords2[0]},${coords2[1]}&vehicle=car&debug=false&calc_points=false&key=LijBPDQGfu7Iiq80w3HzwB4RUDJbMbhs6BU0dEo`;
            
            const response = await fetch(ghUrl, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`GraphHopper HTTP ${response.status}`);
            }

            const data = await response.json();
            
            if (data.paths && data.paths.length > 0) {
                const path = data.paths[0];
                const distanceKm = path.distance / 1000;
                const durationMin = path.time / 60000; // GraphHopper gibt Zeit in ms zur√ºck
                
                const result = {
                    distance: distanceKm,
                    times: {
                        driving: Math.round(durationMin),
                        transit: Math.round(durationMin * 1.8),
                        cycling: Math.round(calculateCyclingTime(distanceKm)),
                        walking: Math.round(distanceKm * 12)
                    }
                };

                console.log(`‚úÖ GraphHopper Routing: ${plz1} ‚Üí ${plz2} = ${distanceKm.toFixed(1)}km, üöó${Math.round(durationMin)}min`);
                return result;
            } else {
                throw new Error('GraphHopper: Keine Route gefunden');
            }
        }

        // Realistische Fahrrad-Zeiten basierend auf Distanz
        function calculateCyclingTime(distanceKm) {
            // Fahrrad-Geschwindigkeit variiert je nach Distanz
            if (distanceKm <= 5) {
                return distanceKm * 3.5; // 17 km/h f√ºr kurze Strecken (Stadtverkehr)
            } else if (distanceKm <= 20) {
                return distanceKm * 3.8; // 16 km/h f√ºr mittlere Strecken
            } else {
                return distanceKm * 4.2; // 14 km/h f√ºr lange Strecken (Erm√ºdung)
            }
        }

        // Multi-Modal Routing: Verschiedene Verkehrsmittel parallel berechnen
        async function getMultiModalDistances(coords1, coords2, plz1, plz2) {
            const cacheKey = `${plz1}-${plz2}-multimodal`;
            
            // Pr√ºfe Cache
            if (routingCache[cacheKey]) {
                console.log(`üîÑ Multi-Modal aus Cache: ${plz1} ‚Üí ${plz2}`);
                return routingCache[cacheKey];
            }

            try {
                // Parallel: Auto und Fahrrad-Routen
                const [carRoute, bikeRoute] = await Promise.allSettled([
                    getOSRMRoute(coords1, coords2, 'driving'),
                    getOSRMRoute(coords1, coords2, 'cycling')
                ]);

                let result = {
                    distance: null,
                    times: {
                        driving: null,
                        cycling: null,
                        transit: null,
                        walking: null
                    },
                    accuracy: 'mixed'
                };

                // Auto-Route verwenden f√ºr Basis-Distanz
                if (carRoute.status === 'fulfilled' && carRoute.value) {
                    result.distance = carRoute.value.distance;
                    result.times.driving = carRoute.value.duration;
                    result.times.transit = Math.round(carRoute.value.duration * 1.8);
                    result.times.walking = Math.round(carRoute.value.distance * 12);
                    result.accuracy = 'high';
                }

                // Fahrrad-Route falls verf√ºgbar
                if (bikeRoute.status === 'fulfilled' && bikeRoute.value) {
                    result.times.cycling = bikeRoute.value.duration;
                } else if (result.distance) {
                    // Fallback-Berechnung f√ºr Fahrrad
                    result.times.cycling = Math.round(calculateCyclingTime(result.distance));
                }

                // Cache speichern
                if (result.distance) {
                    routingCache[cacheKey] = result;
                    localStorage.setItem('swaf_routing_cache', JSON.stringify(routingCache));
                    console.log(`‚úÖ Multi-Modal: ${plz1} ‚Üí ${plz2} = ${result.distance.toFixed(1)}km`);
                }

                return result;

            } catch (error) {
                console.error(`‚ùå Multi-Modal Routing fehlgeschlagen: ${error.message}`);
                throw error;
            }
        }

        // Spezifische OSRM-Route f√ºr verschiedene Verkehrsmittel
        async function getOSRMRoute(coords1, coords2, profile) {
            const profiles = {
                'driving': 'driving',
                'cycling': 'cycling', 
                'walking': 'foot'
            };

            const osrmProfile = profiles[profile] || 'driving';
            const url = `https://router.project-osrm.org/route/v1/${osrmProfile}/${coords1[1]},${coords1[0]};${coords2[1]},${coords2[0]}?overview=false&alternatives=false&steps=false`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`OSRM ${profile} HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                return {
                    distance: route.distance / 1000,
                    duration: Math.round(route.duration / 60)
                };
            } else {
                throw new Error(`OSRM ${profile}: ${data.code || 'Keine Route'}`);
            }
        }

        // Fallback: Sch√§tze Zeiten aus Luftlinie
        function estimateTimesFromAirDistance(airDistance) {
            return {
                walking: Math.round(airDistance * 12), // ~5 km/h
                cycling: Math.round(airDistance * 4),  // ~15 km/h
                transit: Math.round(airDistance * 2.5), // ~25 km/h mit Umsteigen
                driving: Math.round(airDistance * 1.5)  // ~40 km/h in der Stadt
            };
        }

        function extractPLZ(text) {
            if (!text) return null;

            // Suche nach 5-stelliger PLZ
            const plzMatch = text.match(/\b(\d{5})\b/);
            if (plzMatch) {
                return plzMatch[1];
            }

            return null;
        }

        function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Erdradius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);

            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c;

            return distance;
        }

        async function testPLZDistanceAPI() {
            const testCases = [
                ['10115', '10117'], // Berlin intern
                ['10115', '80331'], // Berlin - M√ºnchen
                ['50667', '40210']  // K√∂ln - D√ºsseldorf
            ];

            console.log('üß™ PLZ-Distanz API Tests:');

            for (const [plz1, plz2] of testCases) {
                const result = await calculatePLZDistanceAdvanced(plz1, plz2);
                if (result) {
                    console.log(`${plz1} ‚Üî ${plz2}: ${result.distance} km (${result.type})`);
                    console.log(`  Gesch√§tzte Zeiten: üö∂ ${result.estimatedTimes.walking}min, üö≤ ${result.estimatedTimes.cycling}min, üöå ${result.estimatedTimes.transit}min, üöó ${result.estimatedTimes.driving}min`);
                } else {
                    console.log(`${plz1} ‚Üî ${plz2}: API-Fehler`);
                }
            }

            showNotification('PLZ-Distanz API Tests in Konsole ausgegeben', 'info');
        }

        // Neue Test-Funktion f√ºr erweiterte PLZ-Features
        // Neue Test-Funktion f√ºr erweiterte PLZ-Features
        async function testAdvancedPLZFeatures() {
            console.log('üó∫Ô∏è === ERWEITERTE PLZ-FUNKTIONEN TEST (ECHTE ROUTEN) ===');
            
            const testCases = [
                ['10115', '10117'], // Berlin intern - sollte echte Route finden
                ['80331', '10115'], // M√ºnchen - Berlin - Fernstrecke
                ['50667', '40210']  // K√∂ln - D√ºsseldorf - Regional
            ];

            for (const [plz1, plz2] of testCases) {
                console.log(`\nüìç Test: ${plz1} ‚Üí ${plz2}`);
                
                try {
                    const result = await calculatePLZDistanceAdvanced(plz1, plz2);
                    
                    if (result) {
                        console.log(`  üéØ Distanz: ${result.distance}km (${result.routingInfo})`);
                        console.log(`  üìè Luftlinie: ${result.airDistance}km`);
                        if (result.routingDistance) {
                            console.log(`  üõ£Ô∏è Routing: ${result.routingDistance}km`);
                            console.log(`  üìä Routing-Faktor: ${(result.routingDistance / result.airDistance).toFixed(2)}x`);
                        }
                        console.log(`  ‚è±Ô∏è Zeiten: üöó ${result.estimatedTimes.driving}min, üöå ${result.estimatedTimes.transit}min, üö≤ ${result.estimatedTimes.cycling}min, üö∂ ${result.estimatedTimes.walking}min`);
                        console.log(`  üó∫Ô∏è Google Maps: ${result.mapsLinks.googleMaps}`);
                        console.log(`  üöå √ñPNV: ${result.mapsLinks.googleMapsTransit}`);
                        console.log(`  üåç OpenStreetMap: ${result.mapsLinks.openStreetMap}`);
                        console.log(`  üöá Lokale √ñPNV: ${result.mapsLinks.localTransit}`);
                        
                        // Zeige Qualit√§t der Routing-Daten
                        if (result.routingInfo === 'Echte Routing-Distanz') {
                            console.log(`  ‚úÖ ECHTE ROUTE berechnet!`);
                        } else {
                            console.log(`  ‚ö†Ô∏è Sch√§tzung verwendet (API nicht verf√ºgbar)`);
                        }
                    } else {
                        console.log(`  ‚ùå Berechnung fehlgeschlagen`);
                    }
                } catch (error) {
                    console.log(`  ‚ùå Fehler: ${error.message}`);
                }
            }
            
            showNotification('üó∫Ô∏è Echte Routing-Tests in Konsole ausgegeben', 'info', 4000);
        }

        // Funktion f√ºr interaktive PLZ-Distanz-Berechnung
        function interactivePLZTest() {
            const plz1 = prompt('Erste PLZ eingeben:');
            const plz2 = prompt('Zweite PLZ eingeben:');
            
            if (plz1 && plz2) {
                calculatePLZDistanceAdvanced(plz1, plz2).then(result => {
                    if (result) {
                        const links = result.mapsLinks;
                        const message = `üó∫Ô∏è PLZ-Distanz Ergebnis:\n\n` +
                            `üìç ${plz1} ‚Üí ${plz2}\n` +
                            `üéØ Distanz: ${result.distance}km (${result.routingInfo})\n` +
                            `üìè Luftlinie: ${result.airDistance}km\n` +
                            `‚è±Ô∏è Zeiten:\n` +
                            `  üöó Auto: ${result.estimatedTimes.driving} min\n` +
                            `  üöå √ñPNV: ${result.estimatedTimes.transit} min\n` +
                            `  üö≤ Fahrrad: ${result.estimatedTimes.cycling} min\n\n` +
                            `üó∫Ô∏è Navigation:\n` +
                            `‚Ä¢ Google Maps: ${links.googleMaps}\n` +
                            `‚Ä¢ √ñPNV: ${links.googleMapsTransit}\n` +
                            `‚Ä¢ OpenStreetMap: ${links.openStreetMap}\n` +
                            `‚Ä¢ Lokale √ñPNV: ${links.localTransit}`;
                        
                        alert(message);
                        
                        // √ñffne Google Maps Link
                        if (confirm('Google Maps f√ºr genaue Route √∂ffnen?')) {
                            window.open(links.googleMaps, '_blank');
                        }
                    } else {
                        alert('‚ùå PLZ-Distanz konnte nicht berechnet werden');
                    }
                });
            }
        }

        // Debug-Funktion f√ºr Routing-Cache
        function debugRoutingCache() {
            console.log('üíæ === ROUTING CACHE DEBUG ===');
            console.log(`üìä Cache-Eintr√§ge: ${Object.keys(routingCache).length}`);
            console.log('üóÇÔ∏è Gespeicherte Routen:');
            
            Object.entries(routingCache).forEach(([key, value]) => {
                console.log(`  ${key}: ${value.distance.toFixed(1)}km, ${value.times.driving}min Auto`);
            });
            
            const cacheSize = JSON.stringify(routingCache).length;
            console.log(`üíæ Cache-Gr√∂√üe: ${(cacheSize / 1024).toFixed(1)} KB`);
            
            showNotification(`üíæ Routing-Cache: ${Object.keys(routingCache).length} Routen gespeichert`, 'info');
        }

        // Routing-Cache leeren
        function clearRoutingCache() {
            if (confirm('Routing-Cache leeren? Alle gespeicherten Distanzen werden neu berechnet.')) {
                routingCache = {};
                localStorage.removeItem('swaf_routing_cache');
                showNotification('üíæ Routing-Cache geleert', 'success');
            }
        }

        // ===============================
        // DATENBEREINIGUNG
        // ===============================
        function cleanProfileAnswer(answer) {
            if (!answer || typeof answer !== 'string') {
                return '';
            }

            let cleaned = answer.trim();

            // Liste der zu entfernenden Formulierungen
            const unwantedPhrases = [
                // Standardformulierungen
                '-- Hier kannst du etwas ausw√§hlen --',
                'Hier kannst du etwas ausw√§hlen',

                // Sonstiges-Eintr√§ge
                'sonstiges:,',
                'sonstiges:',
                'sonstiges,',
                'Sonstiges:,',
                'Sonstiges:',
                'Sonstiges,',

                // Andere Grund-Eintr√§ge
                'Anderer Grund:,',
                'Anderer Grund:',
                'anderer Grund:,',
                'anderer Grund:',
                'Anderer Grund,',
                'anderer Grund,',

                // Anderes-Eintr√§ge
                'anderes:,',
                'anderes:',
                'anderes,',
                'Anderes:,',
                'Anderes:',
                'Anderes,',

                // Beschreibungs-Aufforderungen
                'Etwas anderes (bitte genauer beschreiben),',
                'Etwas anderes (bitte genauer beschreiben)',
                'etwas anderes (bitte genauer beschreiben),',
                'etwas anderes (bitte genauer beschreiben)',
                'Bitte genauer beschreiben',
                'bitte genauer beschreiben',

                // Leere Auswahlen
                'Keine Auswahl',
                'keine Auswahl',
                'Nicht ausgew√§hlt',
                'nicht ausgew√§hlt',
                'Bitte ausw√§hlen',
                'bitte ausw√§hlen',

                // Weitere h√§ufige St√∂rer
                'Weitere Angaben:',
                'weitere Angaben:',
                'Weitere Angaben,',
                'weitere Angaben,',
                'Freitext:',
                'freitext:',
                'Kommentar:',
                'kommentar:',

                // Leer-Indikatoren
                '---',
                'n/a',
                'N/A',
                'k.A.',
                'k.a.',
                'unbekannt',
                'Unbekannt'
            ];

            // Entferne unwanted phrases
            unwantedPhrases.forEach(phrase => {
                // Case-insensitive Ersetzung am Anfang des Strings
                const regex1 = new RegExp('^\\s*' + escapeRegExp(phrase) + '\\s*', 'gi');
                cleaned = cleaned.replace(regex1, '');

                // Case-sensitive Ersetzung √ºberall
                const regex2 = new RegExp('\\s*' + escapeRegExp(phrase) + '\\s*', 'g');
                cleaned = cleaned.replace(regex2, ' ');
            });

            // Zus√§tzliche Bereinigung f√ºr "Sonstige:" und "Andere:" Pr√§fixe
            cleaned = cleaned
                .replace(/^sonstige\s*:\s*/gi, '')
                .replace(/^andere\s*:\s*/gi, '')
                .replace(/^weitere\s*:\s*/gi, '')
                .replace(/^zus√§tzlich\s*:\s*/gi, '')
                .replace(/,\s*sonstige\s*:\s*/gi, ', ')
                .replace(/,\s*andere\s*:\s*/gi, ', ')
                .replace(/;\s*sonstige\s*:\s*/gi, '; ')
                .replace(/;\s*andere\s*:\s*/gi, '; ');

            // Bereinige weitere Muster
            cleaned = cleaned
                // Entferne f√ºhrende/trailing Kommas und Semikolons
                .replace(/^[,;:\s]+|[,;:\s]+$/g, '')
                // Entferne doppelte Kommas/Semikolons
                .replace(/[,;]{2,}/g, ',')
                // Entferne einzelne Kommas/Semikolons am Ende
                .replace(/[,;]\s*$/, '')
                // Entferne leere Klammern
                .replace(/\(\s*\)/g, '')
                // Entferne mehrfache Leerzeichen
                .replace(/\s{2,}/g, ' ')
                // Normalisiere Trennzeichen
                .replace(/[,;]\s*[,;]/g, ',')
                // Entferne f√ºhrende Punkte/Striche
                .replace(/^[\.\-\s]+/, '')
                .trim();

            // Spezielle Bereinigung f√ºr Liste-Felder
            if (cleaned.includes(',') || cleaned.includes(';')) {
                const items = cleaned.split(/[,;]/)
                    .map(item => item.trim())
                    .filter(item => item.length > 0)
                    .filter(item => !unwantedPhrases.some(phrase =>
                        item.toLowerCase() === phrase.toLowerCase()
                    ));

                cleaned = items.join(', ');
            }

            // Final cleanup
            cleaned = cleaned.trim();

            // Log bei signifikanten √Ñnderungen
            if (answer !== cleaned && cleaned.length < answer.length * 0.8) {
                console.log(`üßπ Bereinigung: "${answer}" ‚Üí "${cleaned}"`);
            }

            return cleaned;
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function testDataCleaning() {
            const testCases = [
                '-- Hier kannst du etwas ausw√§hlen --, Sport, Musik',
                'Fu√üball, sonstiges:, Tennis',
                'Anderer Grund:, Ich mag Filme schauen',
                'Kochen, anderes:, Wandern',
                'Etwas anderes (bitte genauer beschreiben), Yoga, Meditation',
                'Sport, Tennis, ---',
                'Musik h√∂ren, n/a, Konzerte besuchen',
                'sonstiges:, anderes:, Etwas anderes (bitte genauer beschreiben), Kochen'
            ];

            console.log('üßπ Datenbereinigung Tests:');
            testCases.forEach((testCase, index) => {
                const cleaned = cleanProfileAnswer(testCase);
                console.log(`${index + 1}. "${testCase}"`);
                console.log(`   ‚Üí "${cleaned}"`);
                console.log('');
            });

            showNotification('Datenbereinigung Tests in Konsole ausgegeben', 'info');
        }

        // ===============================
        // HILFSFUNKTIONEN
        // ===============================
        function saveProfiles() {
            localStorage.setItem('swaf_profiles', JSON.stringify(profiles));
        }

        function saveTandems() {
            localStorage.setItem('swaf_tandems', JSON.stringify(tandems));
            showAutoSaveIndicator();
        }

        function showAutoSaveIndicator() {
            // Erstelle oder aktualisiere Save-Indicator
            let indicator = document.getElementById('auto-save-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'auto-save-indicator';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #10b981;
                    color: white;
                    padding: 0.5rem 1rem;
                    border-radius: 6px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    font-size: 0.85rem;
                    z-index: 9999;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: none;
                `;
                indicator.textContent = 'üíæ Automatisch gespeichert';
                document.body.appendChild(indicator);
            }

            // Zeige Indicator
            indicator.style.opacity = '1';

            // Verstecke nach 2 Sekunden
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
        }

        function saveAllData() {
            saveProfiles();
            saveTandems();
            localStorage.setItem('swaf_selected_fields', JSON.stringify(selectedFields));
        }

        function quickSave() {
            saveAllData();
            showNotification('üíæ Daten gespeichert', 'success', 2000);

            const fab = document.querySelector('.fab');
            fab.style.transform = 'scale(1.2)';
            setTimeout(() => {
                fab.style.transform = 'scale(1)';
            }, 200);
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType + ';charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        function createModal(title, content, buttons) {
            // Entferne existierende Modals
            document.querySelectorAll('.modal-overlay').forEach(m => m.remove());

            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.setAttribute('data-modal-id', Date.now());

            // Erstelle Modal-HTML
            modal.innerHTML = `
                <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
                    <h3 style="color: var(--swaf-red); margin-bottom: 1rem;">${title}</h3>
                    ${content}
                    <div id="modal-buttons-${modal.getAttribute('data-modal-id')}" style="text-align: right; margin-top: 1.5rem; display: flex; gap: 0.5rem; justify-content: flex-end;">
                        <!-- Buttons werden via JavaScript hinzugef√ºgt -->
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // F√ºge Buttons programmatisch hinzu
            const buttonContainer = document.getElementById(`modal-buttons-${modal.getAttribute('data-modal-id')}`);
            
            buttons.forEach((btn, index) => {
                const button = document.createElement('button');
                button.className = `btn ${btn.class}`;
                button.textContent = btn.text;
                
                // Event Listener f√ºr Button-Aktionen
                button.addEventListener('click', function() {
                    if (typeof btn.action === 'string') {
                        if (btn.action === 'closeModal') {
                            closeModal();
                        } else {
                            // Versuche globale Funktion aufzurufen
                            try {
                                const func = window[btn.action];
                                if (typeof func === 'function') {
                                    func();
                                } else {
                                    console.error('Funktion nicht gefunden:', btn.action);
                                }
                            } catch (error) {
                                console.error('Fehler beim Ausf√ºhren der Funktion:', btn.action, error);
                            }
                        }
                    } else if (typeof btn.action === 'function') {
                        btn.action();
                    }
                });
                
                buttonContainer.appendChild(button);
            });

            return modal;
        }

        function debugModalSystem() {
            console.log('üîß Modal System Debug:');
            console.log('- Aktive Modals:', document.querySelectorAll('.modal-overlay').length);
            console.log('- Window functions verf√ºgbar:', {
                processDuplicateChoice: typeof window.processDuplicateChoice,
                confirmManualMerge: typeof window.confirmManualMerge,
                addNewProfile: typeof window.addNewProfile,
                closeModal: typeof window.closeModal
            });
            
            showNotification('Modal Debug-Info in Konsole ausgegeben', 'info');
        }

        function closeModal() {
            document.querySelectorAll('.modal-overlay').forEach(m => m.remove());
        }

        // ===============================
        // DEBUG-FUNKTIONEN
        // ===============================
        function showDebugInfo() {
            const info = `
=== SwaF Tandem Matcher Debug Info ===

Profile geladen: ${profiles.length}
Tandems erstellt: ${tandems.length}

Profile im Detail:
${profiles.map((p, i) => `${i + 1}. ${p.name} (${p.fields.length} Felder)`).join('\n')}

Tandems im Detail:
${tandems.map((t, i) => `${i + 1}. ${t.name} (${t.commonalities.length} Gemeinsamkeiten)`).join('\n')}

localStorage Status:
- Profiles: ${localStorage.getItem('swaf_profiles') ? 'Vorhanden' : 'Leer'}
- Tandems: ${localStorage.getItem('swaf_tandems') ? 'Vorhanden' : 'Leer'}
- Bookmarklet Daten: ${localStorage.getItem('swaf_bookmarklet_data') ? 'Vorhanden' : 'Leer'}
- Text Templates: ${localStorage.getItem('swaf_text_templates') ? textTemplates.length + ' St√ºck' : 'Leer'}

Datenqualit√§t:
- Durchschn. Antwortl√§nge: ${profiles.length > 0 ? Math.round(profiles.reduce((sum, p) => sum + p.fields.reduce((fSum, f) => fSum + f.answer.length, 0), 0) / profiles.reduce((sum, p) => sum + p.fields.length, 0)) : 0} Zeichen
- Leere Antworten: ${profiles.reduce((sum, p) => sum + p.fields.filter(f => !f.answer || f.answer.trim().length === 0).length, 0)}
- Profile mit > 10 Feldern: ${profiles.filter(p => p.fields.length > 10).length}
            `;

            alert(info);
            console.log(info);
        }

        function testLocalStorage() {
            try {
                localStorage.setItem('test', 'value');
                const result = localStorage.getItem('test');
                localStorage.removeItem('test');

                if (result === 'value') {
                    showNotification('‚úÖ localStorage funktioniert korrekt', 'success');
                } else {
                    showNotification('‚ùå localStorage-Problem erkannt', 'error');
                }
            } catch (e) {
                showNotification('‚ùå localStorage nicht verf√ºgbar: ' + e.message, 'error');
            }
        }

        function checkForBookmarkletData() {
            try {
                const data = localStorage.getItem('swaf_bookmarklet_data');
                if (data) {
                    console.log('üì• Fallback: Bookmarklet-Daten in localStorage gefunden:', data);
                    const profileData = JSON.parse(data);
                    receiveProfileData(profileData);
                    localStorage.removeItem('swaf_bookmarklet_data');
                    showNotification('üì• Profil √ºber localStorage empfangen (Fallback-Methode)', 'success');
                } else {
                    showNotification('‚ÑπÔ∏è Keine Bookmarklet-Daten in localStorage gefunden', 'info');
                }
            } catch (e) {
                console.error('‚ùå Fehler beim Pr√ºfen der localStorage-Daten:', e);
                showNotification('‚ùå Fehler beim Pr√ºfen der localStorage-Daten', 'error');
            }
        }

        function testClipboardFormat() {
            console.log('üß™ Teste Clipboard-Format...');

            // Erstelle Test-Daten im erwarteten Format
            const testProfile = {
                url: 'https://portal.startwithafriend.de/test',
                name: 'Test Clipboard Format',
                fields: [
                    { question: 'Test Frage 1', answer: 'Test Antwort 1' },
                    { question: 'Test Frage 2', answer: 'Test Antwort mit "Anf√ºhrungszeichen"' },
                    { question: 'Test Frage 3', answer: 'Test\nAntwort\nmit\nZeilenumbr√ºchen' }
                ]
            };

            const testData = 'SWAF_PROFILE_START' + JSON.stringify(testProfile) + 'SWAF_PROFILE_END';

            console.log('üìã Test-Daten erstellt:', testData);

            // Kopiere Test-Daten in Zwischenablage
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(testData).then(function () {
                    showNotification('‚úÖ Test-Daten in Zwischenablage kopiert. Pr√ºfe jetzt mit "üìã Zwischenablage pr√ºfen"', 'success', 5000);
                }).catch(function (error) {
                    console.error('Fehler beim Kopieren der Test-Daten:', error);
                    showTestDataManually(testData);
                });
            } else {
                showTestDataManually(testData);
            }
        }

        function showTestDataManually(testData) {
            createModal('üß™ Test-Daten f√ºr Clipboard', `
                <p>Kopiere diese Test-Daten manuell in die Zwischenablage:</p>
                <textarea readonly style="width: 100%; height: 150px; font-family: monospace; font-size: 0.8rem;">${testData}</textarea>
                <p>Danach verwende "üìã Zwischenablage pr√ºfen" um das Format zu testen.</p>
            `, [
                { text: 'Test-Daten kopiert', class: 'btn-primary', action: 'closeModal' }
            ]);
        }

        // ===============================
        // WEITERE UI-FUNKTIONEN
        // ===============================
        function addTestProfile() {
            const testProfile = {
                url: 'test://demo',
                name: `Test Person ${profiles.length + 1}`,
                fields: [
                    { question: 'Alter', answer: '25' },
                    { question: 'Wohnort', answer: 'Berlin' },
                    { question: 'Hobbys', answer: 'Fu√üball, Lesen, Musik' },
                    { question: 'Sprachen', answer: 'Deutsch, Englisch' },
                    { question: 'Beruf', answer: 'Student' }
                ]
            };

            receiveProfileData(testProfile);
        }

        function showManualInput() {
            const modal = createModal('‚úèÔ∏è Profil manuell eingeben', `
                <div class="form-group">
                    <label>Name der Person:</label>
                    <input type="text" id="manual-name" placeholder="z.B. Max Mustermann">
                </div>
                
                <div class="form-group">
                    <label>Profil-Daten (Format: Frage: Antwort, eine pro Zeile):</label>
                    <textarea id="manual-fields" rows="10" placeholder="Alter: 25&#10;Hobbys: Fu√üball, Lesen&#10;Wohnort: Berlin&#10;Sprachen: Deutsch, Englisch&#10;Beruf: Student"></textarea>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Profil speichern', class: 'btn-primary', action: 'saveManualProfile' }
            ]);
        }

        function saveManualProfile() {
            const name = document.getElementById('manual-name').value.trim();
            const fieldsText = document.getElementById('manual-fields').value.trim();

            if (!name) {
                alert('Bitte gib einen Namen ein.');
                return;
            }

            if (!fieldsText) {
                alert('Bitte gib mindestens ein Feld ein.');
                return;
            }

            const fields = [];
            const lines = fieldsText.split('\n');

            lines.forEach(line => {
                const colonIndex = line.indexOf(':');
                if (colonIndex > 0) {
                    const question = line.substring(0, colonIndex).trim();
                    let answer = line.substring(colonIndex + 1).trim();

                    // Bereinige auch manuell eingegebene Antworten
                    answer = cleanProfileAnswer(answer);

                    if (question && answer && answer.length > 0) {
                        fields.push({ question, answer });
                    }
                }
            });

            if (fields.length === 0) {
                alert('Keine g√ºltigen Felder gefunden. Format: "Frage: Antwort"');
                return;
            }

            const profileData = {
                url: 'manual_input',
                name: name,
                fields: fields
            };

            receiveProfileData(profileData);
            closeModal();
        }

        function pasteFromClipboard() {
            console.log('üìã Manuelles Einf√ºgen aus Zwischenablage...');

            if (navigator.clipboard && navigator.clipboard.readText) {
                navigator.clipboard.readText().then(function (text) {
                    if (text.includes('SWAF_PROFILE_START') && text.includes('SWAF_PROFILE_END')) {
                        processClipboardProfileData(text);
                    } else {
                        showManualPasteDialog();
                    }
                }).catch(function (error) {
                    console.error('Zwischenablage-Zugriff fehlgeschlagen:', error);
                    showManualPasteDialog();
                });
            } else {
                showManualPasteDialog();
            }
        }

        function showManualPasteDialog() {
            createModal('üìã Profildaten einf√ºgen', `
                <p>F√ºge die kopierten Profildaten hier ein:</p>
                <div class="form-group">
                    <textarea id="manual-paste-data" rows="6" placeholder="SWAF_PROFILE_START{...}SWAF_PROFILE_END" style="font-family: monospace; font-size: 0.9rem;"></textarea>
                </div>
                <div class="alert alert-info">
                    <strong>Tipp:</strong> Die Daten sollten mit "SWAF_PROFILE_START" beginnen und mit "SWAF_PROFILE_END" enden.
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Verarbeiten', class: 'btn-primary', action: 'processManualPasteData' }
            ]);
        }

        function processManualPasteData() {
            const text = document.getElementById('manual-paste-data').value;
            if (text.trim()) {
                processClipboardProfileData(text);
                closeModal();
            } else {
                alert('Bitte f√ºge die Profildaten ein.');
            }
        }

        function showDebugClipboardData(text, errorMessage) {
            const modal = createModal('üîß Debug: Zwischenablage-Daten', `
                <div class="alert alert-error">
                    <strong>Fehler:</strong> ${errorMessage}
                </div>
                
                <h4>üìã Rohdaten aus Zwischenablage:</h4>
                <textarea readonly style="width: 100%; height: 150px; font-family: monospace; font-size: 0.8rem;">${text}</textarea>
                
                <h4>üîç Debug-Informationen:</h4>
                <ul>
                    <li>Textl√§nge: ${text.length} Zeichen</li>
                    <li>Start-Marker gefunden: ${text.includes('SWAF_PROFILE_START') ? '‚úÖ' : '‚ùå'}</li>
                    <li>End-Marker gefunden: ${text.includes('SWAF_PROFILE_END') ? '‚úÖ' : '‚ùå'}</li>
                    <li>Enth√§lt JSON-Zeichen: ${text.includes('{') && text.includes('}') ? '‚úÖ' : '‚ùå'}</li>
                </ul>
                
                <div class="form-group">
                    <label>Korrigierte Daten (optional):</label>
                    <textarea id="debug-corrected-data" rows="4" placeholder="Korrigiere die Daten hier oder verwende das Bookmarklet erneut..."></textarea>
                </div>
            `, [
                { text: 'Bookmarklet erneut verwenden', class: 'btn-outline', action: 'closeModal' },
                { text: 'Korrigierte Daten verarbeiten', class: 'btn-primary', action: 'processCorrectedData' }
            ]);
        }

        function processCorrectedData() {
            const correctedData = document.getElementById('debug-corrected-data').value.trim();
            if (correctedData) {
                processClipboardProfileData(correctedData);
                closeModal();
            } else {
                alert('Bitte gib korrigierte Daten ein oder verwende das Bookmarklet erneut.');
            }
        }

        function showInstructions() {
            createModal('üìñ Detaillierte Anleitung', `
                <div style="text-align: left;">
                    <h4>üîÑ Neue Zwischenablage-Methode:</h4>
                    <p>Das Bookmarklet kopiert Profildaten automatisch in die Zwischenablage und diese App erkennt sie automatisch!</p>
                    
                    <h4>1. Bookmarklet installieren:</h4>
                    <p>Ziehe den roten "SwaF Sammler" Button in deine Lesezeichen-Leiste. Falls das nicht funktioniert, erstelle ein neues Lesezeichen und kopiere den JavaScript-Code hinein.</p>
                    
                    <h4>2. Portal √∂ffnen:</h4>
                    <p>Gehe zu <a href="https://portal.startwithafriend.de" target="_blank">portal.startwithafriend.de</a> und logge dich ein.</p>
                    
                    <h4>3. Profile sammeln:</h4>
                    <p>√ñffne ein Teilnehmer-Profil und klicke das "SwaF Sammler" Bookmarklet. Die Daten werden automatisch in die Zwischenablage kopiert.</p>
                    
                    <h4>4. Zur√ºck zur App:</h4>
                    <p>Wechsle zur√ºck zu dieser App. Die Profildaten werden automatisch erkannt und hinzugef√ºgt!</p>
                    
                    <h4>üìã Alternative Methoden:</h4>
                    <ul>
                        <li><strong>Strg+V:</strong> Profildaten aus Zwischenablage einf√ºgen</li>
                        <li><strong>Button "Aus Zwischenablage einf√ºgen":</strong> Manuelles Einf√ºgen</li>
                        <li><strong>Fenster-Fokus:</strong> Automatische Erkennung beim Zur√ºckkehren zur App</li>
                    </ul>
                    
                    <h4>üîß Problembehandlung:</h4>
                    <ul>
                        <li><strong>Bookmarklet funktioniert nicht:</strong> Erstelle manuell ein Lesezeichen mit dem JavaScript-Code</li>
                        <li><strong>Keine Daten√ºbertragung:</strong> Verwende "üìã Zwischenablage pr√ºfen" oder "üì• Manuell einf√ºgen"</li>
                        <li><strong>Cross-Domain-Probleme:</strong> Das neue System umgeht diese durch Zwischenablage-Transfer</li>
                        <li><strong>Felder werden nicht erkannt:</strong> Das Portal-Layout k√∂nnte sich ge√§ndert haben</li>
                    </ul>
                    
                    <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>‚ú® Automatische Erkennung:</strong> Die App erkennt SwaF-Profildaten automatisch in der Zwischenablage und beim Fokus-Wechsel!
                    </div>
                </div>
            `, [
                { text: 'Verstanden', class: 'btn-primary', action: 'closeModal' }
            ]);
        }

        function toggleBookmarkletStatus() {
            const checkbox = document.getElementById('bookmarklet-installed');
            const installSection = document.getElementById('bookmarklet-install-section');

            if (checkbox.checked) {
                installSection.style.display = 'none';
                localStorage.setItem('swaf_bookmarklet_installed', 'true');
                showNotification('‚úÖ Bookmarklet als installiert markiert', 'success', 3000);
            } else {
                installSection.style.display = 'block';
                localStorage.removeItem('swaf_bookmarklet_installed');
            }
        }

        function updateExportPreview() {
            // Optional: Preview implementation
        }

        function debugMatchingState() {
            console.log('üîç === MATCHING DEBUG INFO ===');
            console.log('üìä Anzahl Profile gesamt:', profiles.length);
            console.log('üìã Ausgew√§hlte Profile IDs:', selectedProfiles);
            console.log('üéØ Ausgew√§hltes Tandem:', selectedTandemPairId);
            console.log('ü§ù Anzahl Tandems:', tandems.length);

            // Pr√ºfe DOM-Elemente
            const selectedElements = document.querySelectorAll('.profile-item.selected');
            console.log('üé® Visuell ausgew√§hlte Profile:', selectedElements.length);

            selectedElements.forEach((el, index) => {
                const profileId = el.getAttribute('data-profile-id');
                console.log(`  ${index + 1}. Element mit ID: ${profileId}`);
            });

            // Validiere ausgew√§hlte Profile
            selectedProfiles.forEach((id, index) => {
                const profile = profiles.find(p => p.id == id);
                if (profile) {
                    console.log(`‚úÖ Profil ${index + 1}: ${profile.name} (ID: ${id}, Typ: ${typeof id})`);
                } else {
                    console.log(`‚ùå Profil ${index + 1}: ID ${id} (Typ: ${typeof id}) nicht gefunden!`);
                    console.log(`   Verf√ºgbare IDs: ${profiles.map(p => `${p.id}(${typeof p.id})`).join(', ')}`);
                }
            });

            const debugInfo = `
=== SwaF Matching Debug Info ===

üìä Statistiken:
- Profile geladen: ${profiles.length}
- Profile ausgew√§hlt: ${selectedProfiles.length}
- Tandems erstellt: ${tandems.length}
- Visuell markierte Profile: ${selectedElements.length}

üìã Ausgew√§hlte Profile:
${selectedProfiles.map((id, i) => {
                const profile = profiles.find(p => p.id == id);
                return `${i + 1}. ${profile ? profile.name : 'NICHT GEFUNDEN'} (ID: ${id}, Typ: ${typeof id})`;
            }).join('\n')}

üîß Profile-ID Debug:
${profiles.map(p => `- ${p.name}: ID ${p.id} (${typeof p.id})`).join('\n')}

üé® DOM-Status:
- Elemente mit .selected Klasse: ${selectedElements.length}
- Match-Button aktiviert: ${!document.getElementById('match-btn')?.disabled}

üîß M√∂gliche Probleme:
${selectedProfiles.length !== selectedElements.length ? '‚ùå Auswahl-Array und DOM nicht synchron!' : '‚úÖ Auswahl-Array und DOM synchron'}
${selectedProfiles.length > 2 ? '‚ùå Zu viele Profile ausgew√§hlt!' : '‚úÖ Anzahl Profile OK'}
${selectedProfiles.some(id => !profiles.find(p => p.id == id)) ? '‚ùå Nicht alle ausgew√§hlten Profile existieren!' : '‚úÖ Alle ausgew√§hlten Profile existieren'}
            `;

            alert(debugInfo);
            console.log(debugInfo);
        }

        function fixProfileSelection() {
            console.log('üîß Repariere Profile-Auswahl-IDs...');

            // Backup der alten Auswahl
            const oldSelection = [...selectedProfiles];
            console.log('üíæ Alte Auswahl:', oldSelection);

            // L√∂sche aktuelle Auswahl
            selectedProfiles = [];

            // Entferne alle visuellen Markierungen
            document.querySelectorAll('.profile-item.selected').forEach(el => {
                el.classList.remove('selected');
            });

            // Versuche die Auswahl zu rekonstruieren basierend auf DOM-Markierungen
            const selectedElements = document.querySelectorAll('.profile-item.selected');
            selectedElements.forEach(el => {
                const profileId = el.getAttribute('data-profile-id');
                if (profileId) {
                    selectedProfiles.push(profileId);
                    console.log('üîß Wiederhergestellt:', profileId);
                }
            });

            // Falls keine DOM-Markierungen, versuche die alten IDs zu konvertieren
            if (selectedProfiles.length === 0 && oldSelection.length > 0) {
                console.log('üîÑ Konvertiere alte IDs...');
                oldSelection.forEach(oldId => {
                    // Finde Profile mit flexiblem Typ-Vergleich
                    const profile = profiles.find(p => p.id == oldId);
                    if (profile) {
                        selectedProfiles.push(profile.id);
                        console.log(`‚úÖ Konvertiert: ${oldId} -> ${profile.id} (${profile.name})`);
                    } else {
                        console.log(`‚ùå Konnte nicht konvertieren: ${oldId}`);
                    }
                });
            }

            console.log('‚úÖ Neue Auswahl:', selectedProfiles);

            // UI aktualisieren
            loadAvailableProfiles();
            updateMatchingStatus();

            if (selectedProfiles.length > 0) {
                showNotification(`üîß ${selectedProfiles.length} Profile-IDs repariert und wiederhergestellt`, 'success');
            } else {
                showNotification('üîß IDs repariert - Profile-Auswahl zur√ºckgesetzt', 'info');
            }
        }

        function testPLZDistance() {
            const testCases = [
                ['10115', '10117'], 
                ['80331', '10115'], 
                ['50667', '40210']  
            ];

            console.log('üìç PLZ-Distanz Tests (Synchron):');
            testCases.forEach(([plz1, plz2]) => {
                // Zeige nur synchrone Berechnungen
                console.log(`${plz1} ‚Üî ${plz2}: Berechnung l√§uft...`);
            });

            showNotification('PLZ-Distanz Tests werden in Konsole ausgegeben', 'info');
        }

        function generateContextualTemplatesHTML() {
            let html = '';
            
            // Extrahiere Fragen aus Profilen
            const profileQuestions = extractQuestionsFromProfiles();
            
            // Zeige Info √ºber gefundene Fragen
            html += `
                <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">
                    <h4 style="margin-top: 0;">üìä Gefundene Fragen in Profilen</h4>
                    <p style="font-size: 0.9rem; margin: 0.5rem 0;">
                        <strong>${profileQuestions.length} einzigartige Fragen</strong> in ${profiles.length} Profilen gefunden.
                    </p>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem;">
                        <button class="btn btn-primary btn-small" onclick="showQuestionAssignmentDialog()">
                            üîó Fragen zuordnen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="assignQuestionsToCategories()">
                            ‚ö° Auto-Zuordnung
                        </button>
                        <button class="btn btn-outline btn-small" onclick="showUnassignedQuestions()">
                            ‚ùì Nicht zugeordnet
                        </button>
                    </div>
                </div>
            `;

            Object.keys(contextualTemplates).forEach(category => {
                const templates = contextualTemplates[category];
                const categoryDisplayName = getCategoryDisplayName(category);
                
                // Finde zugeordnete Fragen f√ºr diese Kategorie
                const assignedQuestions = getQuestionsForCategory(category, profileQuestions);

                html += `
                    <div class="contextual-category-section" style="border: 2px solid var(--swaf-teal); border-radius: 8px; margin: 1rem 0; padding: 1rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h3 style="margin: 0; color: var(--swaf-teal);">${categoryDisplayName}</h3>
                            <div style="display: flex; gap: 0.5rem;">
                                <button class="btn btn-outline btn-small" onclick="addTemplateToCategory('${category}')">‚ûï Template</button>
                                <button class="btn btn-outline btn-small" onclick="deleteCategory('${category}')" style="background: var(--swaf-red); color: white;">üóëÔ∏è</button>
                            </div>
                        </div>
                        
                        <!-- Zugeordnete Fragen anzeigen -->
                        ${assignedQuestions.length > 0 ? `
                            <div style="background: var(--swaf-lightest-teal); padding: 0.5rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                    <strong>üîó Zugeordnete Fragen (${assignedQuestions.length}):</strong>
                                    <button class="btn btn-outline btn-small" onclick="showQuestionAssignmentDialog()" style="font-size: 0.75rem; padding: 0.2rem 0.5rem;">
                                        ‚úèÔ∏è Bearbeiten
                                    </button>
                                </div>
                                <div style="max-height: 100px; overflow-y: auto; margin-top: 0.5rem;">
                                    ${assignedQuestions.map(q => {
                                        const isManual = questionCategoryMapping[q] === category;
                                        return `<div style="margin: 0.2rem 0;">
                                            ${isManual ? 'üîó' : '‚ö°'} ${q}
                                            ${isManual ? `<button onclick="removeQuestionFromCategory('${q.replace(/'/g, "\\'")}'); event.stopPropagation();" style="background: none; border: none; color: var(--swaf-red); cursor: pointer; font-size: 0.8rem;" title="Zuordnung entfernen">‚ùå</button>` : ''}
                                        </div>`;
                                    }).join('')}
                                </div>
                                <div style="font-size: 0.75rem; color: var(--swaf-dark-gray); margin-top: 0.5rem;">
                                    üîó = Manuell zugeordnet | ‚ö° = Automatisch erkannt
                                </div>
                            </div>
                        ` : `<p style="font-size: 0.85rem; color: var(--swaf-dark-gray); font-style: italic;">
                            Keine Fragen zugeordnet. 
                            <button class="btn btn-outline btn-small" onclick="showQuestionAssignmentDialog()" style="font-size: 0.75rem; padding: 0.2rem 0.5rem; margin-left: 0.5rem;">
                                ‚ûï Zuordnen
                            </button>
                        </p>`}                        
                        <!-- Templates-Tabelle -->
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: var(--swaf-lightest-teal);">
                                        <th style="padding: 0.5rem; text-align: left; width: 60px;">Priorit√§t</th>
                                        <th style="padding: 0.5rem; text-align: left;">Formulierungstext</th>
                                        <th style="padding: 0.5rem; text-align: center; width: 150px;">Aktionen</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${templates.map((template, index) => `
                                        <tr style="border-bottom: 1px solid #ddd;">
                                            <td style="padding: 0.5rem; text-align: center;">
                                                <input type="checkbox" 
                                                    class="template-priority-checkbox" 
                                                    ${template.priority ? 'checked' : ''} 
                                                    onchange="toggleTemplatePriority('${category}', ${index}); refreshContextualTemplatesEditor();"
                                                    title="Priorisiert = wird zuerst angezeigt">
                                            </td>
                                            <td style="padding: 0.5rem;">
                                                <textarea rows="2" 
                                                        style="width: 100%; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem;"
                                                        onchange="updateTemplateText('${category}', ${index}, this.value)"
                                                        onblur="saveContextualTemplates()">${template.text}</textarea>
                                            </td>
                                            <td style="padding: 0.5rem; text-align: center;">
                                                <div style="display: flex; gap: 0.3rem; justify-content: center; flex-wrap: wrap;">
                                                    <button class="btn btn-outline btn-small" 
                                                            onclick="moveTemplate('${category}', ${index}, -1)" 
                                                            ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                                                    <button class="btn btn-outline btn-small" 
                                                            onclick="moveTemplate('${category}', ${index}, 1)" 
                                                            ${index === templates.length - 1 ? 'disabled' : ''}>‚Üì</button>
                                                    <button class="btn btn-outline btn-small" 
                                                            onclick="deleteTemplate('${category}', ${index})" 
                                                            style="background: var(--swaf-red); color: white;">üóëÔ∏è</button>
                                                </div>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            });

            return html;
        }

        // ===============================
        // ERWEITERTE FRAGEN-VERWALTUNG
        // ===============================
        function extractQuestionsFromProfiles() {
            const questions = new Set();
            
            profiles.forEach(profile => {
                profile.fields.forEach(field => {
                    // Normalisiere Frage f√ºr besseres Matching
                    const normalizedQuestion = normalizeQuestion(field.question);
                    questions.add(normalizedQuestion);
                });
            });
            
            return Array.from(questions).sort();
        }

        function getQuestionsForCategory(category, profileQuestions = null) {
            if (!profileQuestions) {
                profileQuestions = extractQuestionsFromProfiles();
            }
            
            // Erst manuell zugeordnete Fragen pr√ºfen
            const manuallyAssigned = [];
            Object.keys(questionCategoryMapping).forEach(question => {
                if (questionCategoryMapping[question] === category) {
                    manuallyAssigned.push(question);
                }
            });
            
            // Mapping von Kategorien zu Schl√ºsselw√∂rtern f√ºr automatische Zuordnung
            const categoryKeywords = {
                'alter': ['alter', 'geburtstag', 'altersunterschied', 'geboren', 'jahr'],
                'hobby': ['hobby', 'hobbys', 'interesse', 'freizeit', 'sport', 'aktivit√§t', 'machst du gerne', 'lieblings'],
                'sprache': ['sprache', 'sprachen', 'sprichst', 'deutsch', 'englisch', 'muttersprache'],
                'postleitzahl': ['postleitzahl', 'plz'],
                'wohnort': ['wohnort', 'standort', 'ort', 'stadt', 'region', 'adresse'],
                'beruf': ['beruf', 'arbeit', 'job', 'branche', 't√§tig', 'arbeiten'],
                'studium': ['studium', 'ausbildung', 'schule', 'universit√§t', 'bildung', 'abschluss'],
                'zeit': ['zeit', 'treffen', 'verf√ºgbar', 'wann', 'zeitpunkt', 'wochenende'],
                'verkehr': ['verkehr', 'bewegst', 'transport', 'anreisen', 'fahrrad', 'bus', 'bahn']
            };
            
            const keywords = categoryKeywords[category] || [];
            
            const autoAssigned = profileQuestions.filter(question => {
                const lowerQuestion = question.toLowerCase();
                return keywords.some(keyword => lowerQuestion.includes(keyword));
            });
            
            // Kombiniere manuelle und automatische Zuordnungen (ohne Duplikate)
            const combined = [...new Set([...manuallyAssigned, ...autoAssigned])];
            
            return combined.filter(q => profileQuestions.includes(q));
        }

        function assignQuestionsToCategories() {
            const profileQuestions = extractQuestionsFromProfiles();
            let assignedCount = 0;
            let unassignedQuestions = [];
            
            profileQuestions.forEach(question => {
                let assigned = false;
                
                // Versuche automatische Zuordnung
                for (const category of Object.keys(contextualTemplates)) {
                    const assignedQuestions = getQuestionsForCategory(category, [question]);
                    if (assignedQuestions.length > 0) {
                        assigned = true;
                        assignedCount++;
                        break;
                    }
                }
                
                if (!assigned) {
                    unassignedQuestions.push(question);
                }
            });
            
            if (unassignedQuestions.length > 0) {
                showNotification(
                    `‚úÖ ${assignedCount} Fragen zugeordnet, ${unassignedQuestions.length} noch nicht zugeordnet`,
                    'info',
                    5000
                );
                
                // Frage ob neue Kategorien erstellt werden sollen
                if (confirm(`${unassignedQuestions.length} Fragen konnten nicht zugeordnet werden.\n\nM√∂chtest du diese Fragen sehen und ggf. neue Kategorien erstellen?`)) {
                    showUnassignedQuestions();
                }
            } else {
                showNotification(`‚úÖ Alle ${assignedCount} Fragen erfolgreich zugeordnet!`, 'success');
            }
            
            refreshContextualTemplatesEditor();
        }

        function showUnassignedQuestions() {
            const profileQuestions = extractQuestionsFromProfiles();
            const unassignedQuestions = [];
            
            profileQuestions.forEach(question => {
                let assigned = false;
                
                for (const category of Object.keys(contextualTemplates)) {
                    const assignedQuestions = getQuestionsForCategory(category, [question]);
                    if (assignedQuestions.length > 0) {
                        assigned = true;
                        break;
                    }
                }
                
                if (!assigned) {
                    unassignedQuestions.push(question);
                }
            });
            
            if (unassignedQuestions.length === 0) {
                showNotification('‚úÖ Alle Fragen sind Kategorien zugeordnet!', 'success');
                return;
            }
            
            const modal = createModal('‚ùì Nicht zugeordnete Fragen', `
                <div style="max-height: 500px; overflow-y: auto;">
                    <p>Diese ${unassignedQuestions.length} Fragen aus deinen Profilen sind noch keiner Kategorie zugeordnet:</p>
                    <ul style="list-style: none; padding: 0;">
                        ${unassignedQuestions.map(q => `
                            <li style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; margin: 0.5rem 0; background: white;">
                                <strong>${q}</strong>
                                <button class="btn btn-outline btn-small" 
                                        onclick="createCategoryForQuestion('${q.replace(/'/g, "\\'")}'); closeModal();" 
                                        style="float: right;">
                                    ‚ûï Neue Kategorie erstellen
                                </button>
                            </li>
                        `).join('')}
                    </ul>
                </div>
            `, [
                { text: 'Schlie√üen', class: 'btn-outline', action: 'closeModal' }
            ]);
        }

        function createCategoryForQuestion(question) {
            const categoryKey = prompt(`Neue Kategorie f√ºr Frage erstellen:\n"${question}"\n\nKategorie-ID eingeben (z.B. "musik", "familie"):`);
            
            if (!categoryKey || categoryKey.trim() === '') return;
            
            const cleanKey = categoryKey.toLowerCase().trim().replace(/[^a-z0-9]/g, '');
            
            if (contextualTemplates[cleanKey]) {
                alert('Kategorie existiert bereits!');
                return;
            }
            
            // Erstelle neue Kategorie mit Standard-Template
            contextualTemplates[cleanKey] = [
                { text: `Passt gut zusammen!`, priority: true },
                { text: `K√∂nnt ihr euch dr√ºber austauschen`, priority: false }
            ];
            
            saveContextualTemplates();
            editContextualTemplates();
            showNotification(`‚úÖ Kategorie "${cleanKey}" erstellt!`, 'success');
        }

        function assignQuestionToCategory(question, category) {
            questionCategoryMapping[question] = category;
            localStorage.setItem('swaf_question_category_mapping', JSON.stringify(questionCategoryMapping));
            showNotification(`‚úÖ Frage "${question}" zu "${getCategoryDisplayName(category)}" zugeordnet`, 'success');
            refreshContextualTemplatesEditor();
        }

        function removeQuestionFromCategory(question) {
            delete questionCategoryMapping[question];
            localStorage.setItem('swaf_question_category_mapping', JSON.stringify(questionCategoryMapping));
            showNotification(`‚ùå Zuordnung f√ºr "${question}" entfernt`, 'info');
            refreshContextualTemplatesEditor();
        }

        function showQuestionAssignmentDialog() {
            const profileQuestions = extractQuestionsFromProfiles();
            const categories = Object.keys(contextualTemplates);
            
            if (profileQuestions.length === 0) {
                showNotification('Keine Fragen in Profilen gefunden. Bitte zuerst Profile importieren.', 'warning');
                return;
            }
            
            const modal = createModal('üîó Fragen zu Kategorien zuordnen', `
                <div style="max-height: 600px; overflow-y: auto;">
                    <p style="margin-bottom: 1rem;">
                        <strong>${profileQuestions.length} Fragen gefunden.</strong> 
                        W√§hle eine Frage und ordne sie einer Kategorie zu.
                    </p>
                    
                    <div style="display: grid; gap: 1rem;">
                        ${profileQuestions.map(question => {
                            const currentCategory = questionCategoryMapping[question];
                            const isAssigned = !!currentCategory;
                            
                            return `
                                <div style="border: 2px solid ${isAssigned ? 'var(--swaf-teal)' : '#ddd'}; border-radius: 8px; padding: 1rem; background: ${isAssigned ? 'var(--swaf-lightest-teal)' : 'white'};">
                                    <div style="margin-bottom: 0.5rem;">
                                        <strong style="color: var(--swaf-red);">${question}</strong>
                                    </div>
                                    
                                    <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                        <select id="category-select-${question.replace(/[^a-z0-9]/gi, '')}" 
                                                style="flex: 1; min-width: 200px;"
                                                onchange="assignQuestionToCategory('${question.replace(/'/g, "\\'")}', this.value); closeModal();">
                                            <option value="">-- Kategorie w√§hlen --</option>
                                            ${categories.map(cat => `
                                                <option value="${cat}" ${currentCategory === cat ? 'selected' : ''}>
                                                    ${getCategoryDisplayName(cat)}
                                                </option>
                                            `).join('')}
                                        </select>
                                        
                                        ${isAssigned ? `
                                            <button class="btn btn-outline btn-small" 
                                                    onclick="removeQuestionFromCategory('${question.replace(/'/g, "\\'")}'); closeModal();"
                                                    style="background: var(--swaf-red); color: white;">
                                                üóëÔ∏è Entfernen
                                            </button>
                                        ` : ''}
                                        
                                        ${isAssigned ? `
                                            <span style="font-size: 0.85rem; color: var(--swaf-teal); font-weight: 600;">
                                                ‚úì Zugeordnet zu: ${getCategoryDisplayName(currentCategory)}
                                            </span>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `, [
                { text: 'Schlie√üen', class: 'btn-outline', action: 'closeModal' }
            ]);
        }        

        function getCategoryDisplayName(category) {
            const displayNames = {
                'alter': 'Alter & Lebenssituation',
                'hobby': 'Hobbys & Interessen',
                'sprache': 'Sprachen & Kommunikation',
                'postleitzahl': 'Postleitzahl & Entfernung',
                'wohnort': 'Wohnort & Region',
                'beruf': 'Beruf & Arbeit',
                'studium': 'Bildung & Studium',
                'zeit': 'Zeit & Verf√ºgbarkeit',
                'verkehr': 'Mobilit√§t & Transport'
            };

            return displayNames[category] || category.charAt(0).toUpperCase() + category.slice(1);
        }

        function addNewContextCategory() {
            const categoryKey = prompt('Neue Kategorie-ID eingeben (z.B. "musik", "familie"):\n\nHinweis: Verwende nur Kleinbuchstaben ohne Leerzeichen');
            if (!categoryKey || categoryKey.trim() === '') return;

            const cleanKey = categoryKey.toLowerCase().trim().replace(/[^a-z0-9]/g, '');

            if (contextualTemplates[cleanKey]) {
                alert('Kategorie existiert bereits!');
                return;
            }

            contextualTemplates[cleanKey] = [
                { text: `Ihr habt Gemeinsamkeiten im Bereich ${cleanKey}`, priority: true }
            ];

            refreshContextualTemplatesEditor();
        }

        function addTemplateToCategory(category) {
            const text = prompt('Neuen Formulierungstext eingeben:');
            if (!text || text.trim() === '') return;

            contextualTemplates[category].push({
                text: text.trim(),
                priority: false
            });

            refreshContextualTemplatesEditor();
        }

        function deleteCategory(category) {
            if (confirm(`Kategorie "${category}" mit allen Templates l√∂schen?`)) {
                delete contextualTemplates[category];
                refreshContextualTemplatesEditor();
            }
        }

        function deleteTemplate(category, index) {
            if (confirm('Template wirklich l√∂schen?')) {
                contextualTemplates[category].splice(index, 1);
                refreshContextualTemplatesEditor();
            }
        }

        function toggleTemplatePriority(category, index) {
            contextualTemplates[category][index].priority = !contextualTemplates[category][index].priority;
        }

        function updateTemplateText(category, index, newText) {
            contextualTemplates[category][index].text = newText;
        }

        function moveTemplate(category, index, direction) {
            const templates = contextualTemplates[category];

            if (direction === -1 && index > 0) {
                // Nach oben
                [templates[index - 1], templates[index]] = [templates[index], templates[index - 1]];
            } else if (direction === 1 && index < templates.length - 1) {
                // Nach unten
                [templates[index], templates[index + 1]] = [templates[index + 1], templates[index]];
            }

            refreshContextualTemplatesEditor();
        }

        function refreshContextualTemplatesEditor() {
            const container = document.getElementById('contextual-templates-editor');
            if (container) {
                container.innerHTML = generateContextualTemplatesHTML();
            }
        }

        function resetContextualTemplates() {
            if (confirm('Alle fragespezifischen Formulierungen auf Standardwerte zur√ºcksetzen?')) {
                contextualTemplates = getDefaultContextualTemplates();
                localStorage.setItem('swaf_contextual_templates', JSON.stringify(contextualTemplates));
                refreshContextualTemplatesEditor();
                showNotification('‚úÖ Fragespezifische Formulierungen zur√ºckgesetzt', 'success');
            }
        }

        function exportContextualTemplates() {
            const data = {
                contextualTemplates: contextualTemplates,
                predefinedTemplates: predefinedTemplates,
                questionCategoryMapping: questionCategoryMapping,
                exported: new Date().toISOString(),
                version: '2.2',
                type: 'swaf_combined_templates'
            };

            downloadFile(
                JSON.stringify(data, null, 2),
                `SwaF_Fragespezifische_Formulierungen_${new Date().toISOString().split('T')[0]}.json`,
                'application/json'
            );

            showNotification('‚úÖ Fragespezifische Formulierungen exportiert', 'success');
        }

        function importContextualTemplates() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function (event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const data = JSON.parse(e.target.result);

                        let importMessages = [];
                        
                        // Import fragespezifische Templates
                        if (data.contextualTemplates && typeof data.contextualTemplates === 'object') {
                            contextualTemplates = data.contextualTemplates;
                            localStorage.setItem('swaf_contextual_templates', JSON.stringify(contextualTemplates));
                            importMessages.push('Fragespezifische Formulierungen');
                        }
                        
                        // Import allgemeine Templates (falls vorhanden)
                        if (data.predefinedTemplates && Array.isArray(data.predefinedTemplates)) {
                            predefinedTemplates.length = 0;
                            predefinedTemplates.push(...data.predefinedTemplates);
                            localStorage.setItem('swaf_predefined_templates', JSON.stringify(predefinedTemplates));
                            importMessages.push('Allgemeine Formulierungen');
                        }

                        // Import Fragen-Zuordnungen (falls vorhanden)
                        if (data.questionCategoryMapping && typeof data.questionCategoryMapping === 'object') {
                            questionCategoryMapping = data.questionCategoryMapping;
                            localStorage.setItem('swaf_question_category_mapping', JSON.stringify(questionCategoryMapping));
                            importMessages.push('Fragen-Zuordnungen');
                        }                        
                        
                        if (importMessages.length > 0) {
                            if (confirm(`${importMessages.join(' und ')} importieren?\n\n(Vorhandene werden √ºberschrieben)`)) {
                                refreshContextualTemplatesEditor();
                                loadPredefinedTemplates();
                                showNotification(`‚úÖ ${importMessages.join(' und ')} importiert`, 'success');
                            }
                        } else {
                            throw new Error('Keine g√ºltigen fragespezifischen Templates gefunden');
                        }
                    } catch (error) {
                        showNotification('‚ùå Import-Fehler: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function getDefaultContextualTemplates() {
            return {
                'alter': [
                    { text: 'So, wie ihr es euch vorgestellt habt.', priority: true },
                    { text: 'Altersunterschiede k√∂nnen auch super spannend sein! :)', priority: true },
                    { text: 'Ihr seid etwa gleich alt', priority: false },
                    { text: 'Generationsunterschied kann bereichernd sein', priority: false }
                ],
                'hobby': [
                    { text: 'Das sind nur die Hobbies, die ihr aus unserem Vorschl√§gen w√§hlen konntet - mehr findet ihr weiter unten.', priority: true },
                    { text: 'Ihr k√∂nnt euch gegenseitig neue Hobbys zeigen', priority: true },
                    { text: 'Ihr habt √§hnliche Hobbys', priority: false },
                    { text: 'Ihr interessiert euch beide f√ºr Sport', priority: false }
                ],
                'sprache': [
                    { text: 'Eine gemeinsame Sprache habt ihr also :)', priority: true },
                    { text: 'Ihr sprecht beide mehrere Sprachen', priority: false },
                    { text: 'Ihr k√∂nnt euch beim Deutschlernen helfen', priority: false }
                ],
                'postleitzahl': [
                    { text: 'Wenn ihr euch in der Mitte trefft, wird es noch k√ºrzer :)', priority: true },
                    { text: 'Ihr seid ja sogar fast Nachbarn! :)', priority: true },
                    { text: 'Ihr wohnt nah beieinander', priority: false },
                    { text: 'Kurze Wege f√ºr Treffen', priority: false }
                ],
                'wohnort': [
                    { text: 'Ihr wohnt in der gleichen Gegend', priority: true },
                    { text: 'Ihr kennt die gleichen Orte', priority: false }
                ],
                'beruf': [
                    { text: 'Ihr arbeitet in √§hnlichen Bereichen', priority: true },
                    { text: 'Unterschiedliche Berufe - kann spannend sein sich dar√ºber auszutauschen :)', priority: true },
                    { text: 'Upsi, da haben wir vergessen nachzufragen - aber wir wollen ja auch nicht alles vor dem ersten Treffen verraten :D', priority: false }
                ],
                'studium': [
                    { text: 'Unterschiedlich - aber auch guter Gespr√§chsstoff!', priority: true },
                    { text: 'Ist das nicht √§hnlich?', priority: true },
                    { text: 'Ihr habt beide studiert', priority: false }
                ],
                'zeit': [
                    { text: 'Na, einen Zeitpunkt f√ºr ein Treffen findet ihr doch, oder? :D', priority: true },
                    { text: 'Ihr habt zur gleichen Zeit frei', priority: false },
                    { text: 'Eure Zeitpl√§ne passen gut zusammen', priority: false }
                ],
                'verkehr': [
                    { text: 'Der Weg ist das Ziel :D', priority: true },
                    { text: 'Ihr nutzt die gleichen Verkehrsmittel', priority: false },
                    { text: 'Ihr kommt gut zueinander', priority: false }
                ],             
                // NEUE KATEGORIEN:
                'motivation': [
                    { text: 'Ihr habt √§hnliche Gr√ºnde f√ºr SwaF! :)', priority: true },
                    { text: 'Unterschiedliche Motivationen - spannend zum Austauschen!', priority: true },
                    { text: 'Ihr wisst beide, warum ihr hier seid', priority: false }
                ],
                'herkunft_swaf': [
                    { text: 'Ihr habt SwaF auf √§hnliche Weise kennengelernt', priority: true },
                    { text: 'Unterschiedliche Wege zu SwaF - aber ihr seid da! :)', priority: false }
                ],
                'einwanderung': [
                    { text: 'Ihr habt √§hnliche Erfahrungen mit dem Leben in Deutschland', priority: true },
                    { text: 'Unterschiedliche Hintergr√ºnde - perfekt zum Austauschen!', priority: true },
                    { text: 'Verschiedene Perspektiven k√∂nnen sehr bereichernd sein', priority: false }
                ],
                'zukunft': [
                    { text: 'Ihr habt √§hnliche Pl√§ne f√ºr die Zukunft!', priority: true },
                    { text: 'Unterschiedliche Tr√§ume - k√∂nnt euch gegenseitig inspirieren! :)', priority: true },
                    { text: 'Spannend, was ihr beide vorhabt', priority: false }
                ],
                'themen': [
                    { text: 'Ihr interessiert euch f√ºr √§hnliche Themen!', priority: true },
                    { text: 'Verschiedene Interessen - perfekt f√ºr spannende Gespr√§che', priority: true },
                    { text: 'Da werdet ihr viel zu bereden haben! :)', priority: false }
                ],
                'name': [
                    { text: 'Sch√∂ne Namen habt ihr beide! :)', priority: false }
                ],
                'gruppe': [
                    { text: 'Ihr seid in den perfekten Gruppen! :)', priority: true },
                    { text: 'Local und Einwander*in - genau wie es sein soll!', priority: true }
                ],
                'matching_hinweise': [
                    { text: 'Die Hinweise passen gut zusammen', priority: true },
                    { text: 'Wir haben auf alles geachtet! :)', priority: false }
                ],
                'herausforderungen': [
                    { text: 'Herausforderungen meistert ihr zusammen bestimmt! :)', priority: true },
                    { text: 'Ihr k√∂nnt euch gegenseitig unterst√ºtzen', priority: false }
                ],
                'eindruck': [
                    { text: 'Ihr macht beide einen tollen Eindruck!', priority: true },
                    { text: 'Sympathische Menschen, die gut zusammenpassen', priority: false }
                ],
                'kontakt': [
                    { text: 'Eure Kontaktdaten sind ausgetauscht - los geht\'s! :)', priority: true }
                ],
                'termine': [
                    { text: 'Die Termine haben gut geklappt', priority: false }
                ],
                'status': [
                    { text: 'Alles ist bereit f√ºr euer Tandem! :)', priority: true }
                ]
            };
        }

        function editPredefinedTemplates() {
            const modal = createModal('‚úèÔ∏è Formulierungsvorschl√§ge bearbeiten', `
                <div style="max-height: 400px; overflow-y: auto;">
                    <div id="edit-templates-list">
                        ${predefinedTemplates.map((template, index) => `
                            <div class="template-edit-item" style="border: 1px solid #ddd; padding: 1rem; margin: 0.5rem 0; border-radius: 4px;">
                                <div style="display: flex; gap: 1rem; align-items: flex-start;">
                                    <div style="flex: 1;">
                                        <div class="form-group">
                                            <label>Titel:</label>
                                            <input type="text" value="${template.title}" 
                                                onchange="updatePredefinedTemplate(${index}, 'title', this.value)"
                                                style="width: 100%;">
                                        </div>
                                        <div class="form-group">
                                            <label>Text:</label>
                                            <textarea rows="2" 
                                                    onchange="updatePredefinedTemplate(${index}, 'text', this.value)"
                                                    style="width: 100%;">${template.text}</textarea>
                                        </div>
                                    </div>
                                    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                        <button onclick="movePredefinedTemplate(${index}, -1)" 
                                                class="btn btn-outline btn-small" 
                                                ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                                        <button onclick="movePredefinedTemplate(${index}, 1)" 
                                                class="btn btn-outline btn-small"
                                                ${index === predefinedTemplates.length - 1 ? 'disabled' : ''}>‚Üì</button>
                                        <button onclick="deletePredefinedTemplate(${index})" 
                                                class="btn btn-outline btn-small"
                                                style="background: var(--swaf-red); color: white;">üóëÔ∏è</button>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--swaf-lightest-teal); border-radius: 4px;">
                        <h4>‚ûï Neue Formulierung hinzuf√ºgen:</h4>
                        <div style="display: flex; gap: 1rem; align-items: flex-end;">
                            <div class="form-group" style="flex: 1;">
                                <label>Titel:</label>
                                <input type="text" id="new-predefined-title" placeholder="z.B. Reisen">
                            </div>
                            <div class="form-group" style="flex: 2;">
                                <label>Text:</label>
                                <input type="text" id="new-predefined-text" placeholder="z.B. Ihr reist beide gerne und entdeckt neue Orte">
                            </div>
                            <button onclick="addPredefinedTemplate()" class="btn btn-primary">‚ûï Hinzuf√ºgen</button>
                        </div>
                    </div>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Speichern & Schlie√üen', class: 'btn-primary', action: 'savePredefinedTemplates' }
            ]);
        }

        function updatePredefinedTemplate(index, field, value) {
            if (predefinedTemplates[index]) {
                predefinedTemplates[index][field] = value;
                console.log(`Updated template ${index}.${field} = "${value}"`);
            }
        }

        function movePredefinedTemplate(index, direction) {
            if (direction === -1 && index > 0) {
                [predefinedTemplates[index - 1], predefinedTemplates[index]] =
                    [predefinedTemplates[index], predefinedTemplates[index - 1]];
            } else if (direction === 1 && index < predefinedTemplates.length - 1) {
                [predefinedTemplates[index], predefinedTemplates[index + 1]] =
                    [predefinedTemplates[index + 1], predefinedTemplates[index]];
            }

            editPredefinedTemplates();
        }

        function deletePredefinedTemplate(index) {
            const template = predefinedTemplates[index];
            if (confirm(`Formulierung "${template.title}" wirklich l√∂schen?`)) {
                predefinedTemplates.splice(index, 1);
                editPredefinedTemplates();
            }
        }

        function addPredefinedTemplate() {
            const title = document.getElementById('new-predefined-title').value.trim();
            const text = document.getElementById('new-predefined-text').value.trim();

            if (!title || !text) {
                alert('Bitte Titel und Text eingeben.');
                return;
            }

            predefinedTemplates.push({ title, text });

            document.getElementById('new-predefined-title').value = '';
            document.getElementById('new-predefined-text').value = '';

            editPredefinedTemplates();
        }

        function savePredefinedTemplates() {
            localStorage.setItem('swaf_predefined_templates', JSON.stringify(predefinedTemplates));
            loadPredefinedTemplates();
            closeModal();
            showNotification('‚úÖ Formulierungsvorschl√§ge gespeichert', 'success');
        }

        function loadPredefinedTemplates() {
            console.log('üîÑ Lade vordefinierte Templates...');
            
            // Stelle sicher, dass Container existiert
            let container = ensurePredefinedTemplatesContainer();
            
            if (!container) {
                console.error('‚ùå Container "predefined-templates" konnte nicht erstellt werden');
                return;
            }

            console.log('‚úÖ Container gefunden, lade', predefinedTemplates.length, 'Templates');

            container.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h4 style="margin: 0; color: var(--swaf-red);">üìù Vordefinierte Formulierungen (${predefinedTemplates.length})</h4>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-outline btn-small" onclick="editPredefinedTemplates()">‚úèÔ∏è Bearbeiten</button>
                        <button class="btn btn-outline btn-small" onclick="resetPredefinedTemplates()">üîÑ Zur√ºcksetzen</button>
                        <button class="btn btn-secondary btn-small" onclick="exportPredefinedTemplates()">üì§ Exportieren</button>
                        <button class="btn btn-secondary btn-small" onclick="importPredefinedTemplates()">üì• Importieren</button>
                    </div>
                </div>
                <div id="predefined-templates-grid" style="display: flex; flex-wrap: wrap; gap: 0.3rem; max-height: 150px; overflow-y: auto; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; background: white;">
                    ${predefinedTemplates.map((template, index) => `
                        <button class="btn btn-outline btn-small template-btn" 
                                onclick="insertTemplate('${template.text.replace(/'/g, "\\'")}')"
                                data-index="${index}"
                                style="margin: 0.1rem; font-size: 0.8rem;"
                                title="${template.text}">
                            ${template.title}
                        </button>
                    `).join('')}
                </div>
                <div style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                    üí° <strong>Verwendung:</strong> Doppelklick auf eine Formulierung um sie in eine ausgew√§hlte Gemeinsamkeiten-Zelle einzuf√ºgen.
                </div>
            `;
            
            console.log('‚úÖ Allgemeine Templates erfolgreich geladen');
        }

        // Hilfsfunktion um sicherzustellen, dass Container existiert
        function ensurePredefinedTemplatesContainer() {
            const container = document.getElementById('predefined-templates');
            if (!container) {
                console.warn('‚ö†Ô∏è Container "predefined-templates" nicht gefunden - wird erstellt');
                
                // Suche den Parent-Container und f√ºge hinzu
                const parentContainer = document.querySelector('#tab-3 .card:last-child');
                if (parentContainer) {
                    const newContainer = document.createElement('div');
                    newContainer.innerHTML = `
                        <div style="margin-top: 2rem; padding: 1.5rem; border: 2px solid var(--swaf-red); border-radius: 8px; background: var(--swaf-lightest-red);">
                            <h4 style="color: var(--swaf-red); margin-top: 0;">üìã Allgemeine Formulierungsvorschl√§ge</h4>
                            <p style="margin-bottom: 1rem; font-size: 0.9rem;">Diese Vorschl√§ge stehen in allen Tandem-Bearbeitungen zur Verf√ºgung:</p>
                            
                            <div id="predefined-templates">
                                <!-- Wird dynamisch gef√ºllt -->
                            </div>
                        </div>
                    `;
                    parentContainer.appendChild(newContainer);
                    return document.getElementById('predefined-templates');
                }
            }
            return container;
        }

        function resetPredefinedTemplates() {
            if (confirm('Alle Formulierungsvorschl√§ge auf Standardwerte zur√ºcksetzen?')) {
                predefinedTemplates.length = 0;
                predefinedTemplates.push(...getDefaultPredefinedTemplates());
                localStorage.setItem('swaf_predefined_templates', JSON.stringify(predefinedTemplates));
                loadPredefinedTemplates();
                showNotification('‚úÖ Formulierungsvorschl√§ge zur√ºckgesetzt', 'success');
            }
        }

        function exportPredefinedTemplates() {
            console.log('üì§ Exportiere vordefinierte Templates:', predefinedTemplates.length);
            
            const data = {
                templates: predefinedTemplates,
                exported: new Date().toISOString(),
                version: '2.0',
                type: 'swaf_predefined_templates'
            };

            const filename = `SwaF_Allgemeine_Formulierungen_${new Date().toISOString().split('T')[0]}.json`;
            
            downloadFile(
                JSON.stringify(data, null, 2),
                filename,
                'application/json'
            );

            showNotification(`‚úÖ ${predefinedTemplates.length} allgemeine Formulierungsvorschl√§ge exportiert`, 'success', 4000);
            console.log('‚úÖ Export erfolgreich:', filename);
        }

        function importPredefinedTemplates() {
            console.log('üì• Starte Import von vordefinierten Templates...');
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function (event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        console.log('üìÑ Geladene Daten:', data);

                        if (data.templates && Array.isArray(data.templates)) {
                            const message = `${data.templates.length} allgemeine Formulierungen importieren?\n\n` +
                                        `Vorhandene ${predefinedTemplates.length} Formulierungen werden √ºberschrieben!\n\n` +
                                        `Erste 3 Beispiele:\n` +
                                        data.templates.slice(0, 3).map(t => `‚Ä¢ ${t.title}`).join('\n');
                            
                            if (confirm(message)) {
                                const oldCount = predefinedTemplates.length;
                                predefinedTemplates.length = 0;
                                predefinedTemplates.push(...data.templates);
                                localStorage.setItem('swaf_predefined_templates', JSON.stringify(predefinedTemplates));
                                loadPredefinedTemplates();
                                
                                console.log('‚úÖ Import erfolgreich:', predefinedTemplates.length, 'Templates');
                                showNotification(`‚úÖ ${data.templates.length} allgemeine Formulierungen importiert (vorher: ${oldCount})`, 'success', 5000);
                            }
                        } else {
                            throw new Error('Keine g√ºltige Template-Datei gefunden. Erwartet: { templates: [...] }');
                        }
                    } catch (error) {
                        console.error('‚ùå Import-Fehler:', error);
                        showNotification('‚ùå Import-Fehler: ' + error.message, 'error', 6000);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function getDefaultPredefinedTemplates() {
            return [
                // Sport & Bewegung
                { title: 'Sport allgemein', text: 'Ihr habt beide Interesse an Sport und Bewegung' },
                { title: 'Fu√üball', text: 'Ihr interessiert euch beide f√ºr Fu√üball' },
                { title: 'Fitnessstudio', text: 'Ihr geht beide gerne ins Fitnessstudio' },
                { title: 'Wandern', text: 'Ihr wandert beide gerne und m√∂gt die Natur' },
                { title: 'Laufen', text: 'Ihr lauft beide gerne und haltet euch fit' },
                // ... alle anderen Templates
                { title: 'Gegenseitige Unterst√ºtzung', text: 'Ihr k√∂nnt euch gegenseitig unterst√ºtzen und motivieren' }
            ];
        }

        function initializePredefinedTemplates() {
            const saved = localStorage.getItem('swaf_predefined_templates');
            if (saved) {
                try {
                    const savedTemplates = JSON.parse(saved);
                    if (Array.isArray(savedTemplates) && savedTemplates.length > 0) {
                        predefinedTemplates.length = 0;
                        predefinedTemplates.push(...savedTemplates);
                        console.log('‚úÖ Gespeicherte Formulierungsvorschl√§ge geladen:', savedTemplates.length);
                    }
                } catch (error) {
                    console.error('‚ùå Fehler beim Laden der gespeicherten Templates:', error);
                }
            }
        }

        // ===============================
        // EVENT LISTENERS
        // ===============================
        window.addEventListener('beforeunload', function (e) {
            if (profiles.length > 0 || tandems.length > 0) {
                // Automatisches Backup erstellen
                const backupCreated = createAutoBackup();
                
                if (!backupCreated) {
                    e.preventDefault();
                    e.returnValue = 'Warnung: Backup konnte nicht erstellt werden. M√∂chtest du wirklich die Seite verlassen?';
                } else {
                    // Optional: Warnung trotzdem anzeigen
                    e.preventDefault();
                    e.returnValue = 'Deine Daten wurden automatisch gesichert. Trotzdem die Seite verlassen?';
                }
            }
        });

        // Auto-Restore beim Laden der Seite pr√ºfen
        window.addEventListener('load', function() {
            // Gamification initialisieren
            initializeGamification();

            // Kurze Verz√∂gerung, damit die UI vollst√§ndig geladen ist
            setTimeout(() => {
                checkForAutoRestore();
            }, 500);
        });

        // Keyboard Shortcuts
        // Enhanced Keyboard Shortcuts
        document.addEventListener('keydown', function (e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 's':
                        e.preventDefault();
                        quickSave();
                        showShortcutFeedback('üíæ Gespeichert!');
                        break;
                    case 'l':
                        e.preventDefault();
                        clearAllCommonalities();
                        showShortcutFeedback('üßπ Gemeinsamkeiten geleert!');
                        break;
                    case 'b':
                        e.preventDefault();
                        toggleBulkEditMode();
                        showShortcutFeedback('üöÄ Bulk-Edit Modus!');
                        break;
                    case 'v':
                        if (!e.target.matches('input, textarea, [contenteditable]')) {
                            e.preventDefault();
                            pasteFromClipboard();
                            showShortcutFeedback('üìã Eingef√ºgt!');
                        }
                        break;
                    case '1':
                        e.preventDefault();
                        switchTab(0);
                        break;
                    case '2':
                        e.preventDefault();
                        switchTab(1);
                        break;
                }
            }
            
            // Escape-Taste f√ºr verschiedene Schlie√ü-Aktionen
            if (e.key === 'Escape') {
                if (document.getElementById('bulk-edit-toolbar').classList.contains('visible')) {
                    exitBulkEditMode();
                } else if (floatingTemplatesVisible) {
                    hideFloatingTemplates();
                } else {
                    hideShortcutInfo();
                }
            }
            
            // Zeige Shortcuts bei Shift+?
            if (e.key === '?' && e.shiftKey && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName) && document.activeElement.contentEditable !== 'true') {
                e.preventDefault();
                toggleShortcutInfo();
            }
        });

        function toggleAutoClipboardDetection() {
            const checkbox = document.getElementById('auto-clipboard-detection');
            
            if (checkbox.checked) {
                localStorage.setItem('swaf_auto_clipboard_detection', 'true');
                showNotification('‚úÖ Automatische Zwischenablage-Erkennung aktiviert', 'success', 3000);
            } else {
                localStorage.setItem('swaf_auto_clipboard_detection', 'false');
                showNotification('‚ö†Ô∏è Automatische Erkennung deaktiviert. Verwende "üìã Aus Zwischenablage einf√ºgen" manuell.', 'warning', 5000);
            }
        }

        // ===============================
        // GLOBALE FUNKTIONEN VERF√úGBAR MACHEN
        // ===============================
        window.switchTab = switchTab;
        window.removeProfile = removeProfile;
        window.clearAllProfiles = clearAllProfiles;
        window.addTestProfile = addTestProfile;
        window.showManualInput = showManualInput;
        window.pasteFromClipboard = pasteFromClipboard;
        window.checkClipboardForProfileData = checkClipboardForProfileData;
        window.testClipboardFormat = testClipboardFormat;
        window.checkForBookmarkletData = checkForBookmarkletData;
        window.showDebugInfo = showDebugInfo;
        window.testLocalStorage = testLocalStorage;
        window.testDataCleaning = testDataCleaning;
        window.showInstructions = showInstructions;
        window.testPLZDistanceAPI = testPLZDistanceAPI;
        window.testAdvancedPLZFeatures = testAdvancedPLZFeatures;
        window.interactivePLZTest = interactivePLZTest;
        window.debugRoutingCache = debugRoutingCache;
        window.clearRoutingCache = clearRoutingCache;
        window.updatePLZDistancesOnly = updatePLZDistancesOnly;
        window.showNavigationOptions = showNavigationOptions;
        window.copyToClipboard = copyToClipboard;
        window.enhancePLZCell = enhancePLZCell;
        window.getRegionInfo = getRegionInfo;
        window.testPLZDistance = testPLZDistance;
        window.loadAvailableProfiles = loadAvailableProfiles;
        window.filterProfiles = filterProfiles;
        window.clearFilters = clearFilters;
        window.matchSelectedProfiles = matchSelectedProfiles;
        window.suggestAutoMatches = suggestAutoMatches;
        window.clearProfileSelection = clearProfileSelection;
        window.debugMatchingState = debugMatchingState;
        window.fixProfileSelection = fixProfileSelection;
        window.removeSelectedPair = removeSelectedPair;
        window.clearAllTandems = clearAllTandems;
        window.selectAllFields = selectAllFields;
        window.loadTandemForEditing = loadTandemForEditing;
        window.deleteRow = deleteRow;
        window.saveTandem = saveTandem;
        window.generateCompleteEmail = generateCompleteEmail;
        window.copyTandemToClipboard = copyTandemToClipboard;
        window.recomputeCommonalities = recomputeCommonalities;
        window.previewEmail = previewEmail;
        window.hideEmailPreview = hideEmailPreview;
        window.copyCompleteEmailToClipboard = copyCompleteEmailToClipboard;
        window.downloadEmailAsHTML = downloadEmailAsHTML;
        window.saveEmailTemplate = saveEmailTemplate;
        window.loadEmailTemplate = loadEmailTemplate;
        window.resetEmailTemplate = resetEmailTemplate;
        window.formatText = formatText;
        window.insertText = insertText;
        window.insertPlaceholder = insertPlaceholder;
        window.editTandem = editTandem;
        window.deleteSavedTandem = deleteSavedTandem;
        window.exportAllTandems = exportAllTandems;
        window.exportAppData = exportAppData;
        window.importAppData = importAppData;
        window.clearProfiles = clearProfiles;
        window.clearTandems = clearTandems;
        window.resetAllData = resetAllData;
        window.loadSavedTandems = loadSavedTandems;
        window.saveTextTemplate = saveTextTemplate;
        window.loadTextTemplates = loadTextTemplates;
        window.clearAllTemplates = clearAllTemplates;
        window.editContextualTemplates = editContextualTemplates;
        window.extractQuestionsFromProfiles = extractQuestionsFromProfiles;
        window.getQuestionsForCategory = getQuestionsForCategory;
        window.assignQuestionsToCategories = assignQuestionsToCategories;
        window.showUnassignedQuestions = showUnassignedQuestions;
        window.createCategoryForQuestion = createCategoryForQuestion;
        window.assignQuestionToCategory = assignQuestionToCategory;
        window.removeQuestionFromCategory = removeQuestionFromCategory;
        window.showQuestionAssignmentDialog = showQuestionAssignmentDialog;
        window.editPredefinedTemplates = editPredefinedTemplates;
        window.toggleBookmarkletStatus = toggleBookmarkletStatus;
        window.handleCellFocus = handleCellFocus;
        window.toggleFloatingTemplates = toggleFloatingTemplates;
        window.selectProfile = selectProfile;
        window.selectTandemPair = selectTandemPair;
        window.removeTandem = removeTandem;
        window.toggleField = toggleField;
        window.removeTemplate = removeTemplate;
        window.insertTemplate = insertTemplate;
        window.insertFloatingTemplate = insertFloatingTemplate;
        window.quickSave = quickSave;
        window.handleDataImport = handleDataImport;
        window.saveManualProfile = saveManualProfile;
        window.processManualPasteData = processManualPasteData;
        window.closeModal = closeModal;
        window.processCorrectedData = processCorrectedData;
        window.addNewContextCategory = addNewContextCategory;
        window.addTemplateToCategory = addTemplateToCategory;
        window.deleteCategory = deleteCategory;
        window.deleteTemplate = deleteTemplate;
        window.toggleTemplatePriority = toggleTemplatePriority;
        window.updateTemplateText = updateTemplateText;
        window.moveTemplate = moveTemplate;
        window.saveContextualTemplates = saveContextualTemplates;
        window.resetContextualTemplates = resetContextualTemplates;
        window.exportContextualTemplates = exportContextualTemplates;
        window.importContextualTemplates = importContextualTemplates;
        window.updatePredefinedTemplate = updatePredefinedTemplate;
        window.movePredefinedTemplate = movePredefinedTemplate;
        window.deletePredefinedTemplate = deletePredefinedTemplate;
        window.addPredefinedTemplate = addPredefinedTemplate;
        window.savePredefinedTemplates = savePredefinedTemplates;
        window.resetPredefinedTemplates = resetPredefinedTemplates;
        window.exportPredefinedTemplates = exportPredefinedTemplates;
        window.importPredefinedTemplates = importPredefinedTemplates;
        window.applyAutoMatches = applyAutoMatches;
        window.toggleAutoClipboardDetection = toggleAutoClipboardDetection;
        window.updateMergeProfileLists = updateMergeProfileLists;
        window.showMergePreview = showMergePreview;
        window.manualMergeProfiles = manualMergeProfiles;
        window.showPossibleDuplicatesDialog = showPossibleDuplicatesDialog;
        window.processDuplicateChoice = processDuplicateChoice;
        window.mergeProfiles = mergeProfiles;
        window.confirmManualMerge = confirmManualMerge;
        window.addNewProfile = addNewProfile;
        window.debugModalSystem = debugModalSystem;
        window.migrateExistingProfiles = migrateExistingProfiles;
        window.createDataBackup = createDataBackup;
        window.analyzeCurrentData = analyzeCurrentData;
        window.debugQuestionSimilarity = debugQuestionSimilarity;
        window.ensurePredefinedTemplatesContainer = ensurePredefinedTemplatesContainer;
        window.resetBatch = resetBatch;
        window.showBatchStatus = showBatchStatus;
        window.transferBatchToClipboard = transferBatchToClipboard;
        window.cleanupBatchStorage = cleanupBatchStorage;
        window.importCurrentBatch = importCurrentBatch;
        window.countUniquePersons = countUniquePersons;
        window.clearClipboard = clearClipboard;
        window.clearBatchAndClipboard = clearBatchAndClipboard;
        window.clearBatchOnFocus = clearBatchOnFocus;


        function showAllFields() {
            console.log('üîÑ Zeige alle Felder ohne Filter...');
            
            const tbody = document.querySelector('#tandem-table tbody');
            tbody.innerHTML = '';

            currentTandem.commonalities.forEach(c => {
                const isPLZField = c.question.toLowerCase().includes('postleitzahl') || c.question.toLowerCase().includes('plz');
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${c.question}</td>
                    <td contenteditable="true">${c.answer1}</td>
                    <td contenteditable="true">${c.answer2}</td>
                    <td contenteditable="true" 
                        style="background: var(--swaf-lightest-teal); cursor: text; ${isPLZField ? 'padding-right: 90px; position: relative;' : ''}" 
                        title="${isPLZField ? 'üîÑ Distanz wird automatisch berechnet' : 'Klick hier f√ºr passende Formulierungsvorschl√§ge'}"
                        onfocus="handleCellFocus(this)"
                        data-is-plz="${isPLZField}"
                        data-answer1="${(c.answer1 || '').replace(/"/g, '&quot;')}"
                        data-answer2="${(c.answer2 || '').replace(/"/g, '&quot;')}">
                        ${isPLZField ? 'üîÑ Berechne Distanz...' : c.commonality}
                    </td>
                    <td style="position: relative;">
                        ${!isPLZField ? `<button class="ai-assist-btn btn btn-outline btn-small" style="margin-right: 0.5rem;" title="KI-Unterst√ºtzung" data-question="${c.question.replace(/"/g, '&quot;')}" data-answer1="${(c.answer1 || '').replace(/"/g, '&quot;')}" data-answer2="${(c.answer2 || '').replace(/"/g, '&quot;')}">ü§ñ KI</button>` : ''}
                        <button onclick="deleteRow(this)" class="btn btn-outline btn-small">üóëÔ∏è</button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            // Event Listener f√ºr KI-Buttons
            setTimeout(() => {
                const aiButtons = document.querySelectorAll('.ai-assist-btn');
                aiButtons.forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const question = this.getAttribute('data-question');
                        const answer1 = this.getAttribute('data-answer1');
                        const answer2 = this.getAttribute('data-answer2');
                        openAIAssistant(question, answer1, answer2);
                    });
                });
            }, 100);

            setTimeout(() => {
                autoCalculatePLZDistances();
            }, 300);

            showNotification('üìä Alle Felder werden angezeigt (Feldkonfiguration tempor√§r ignoriert)', 'info', 3000);
        }

        async function autoCalculatePLZDistances() {
            const table = document.getElementById('tandem-table');
            if (!table) return;
            
            const plzCells = table.querySelectorAll('td[data-is-plz="true"]');
            
            for (const cell of plzCells) {
                const answer1 = cell.getAttribute('data-answer1');
                const answer2 = cell.getAttribute('data-answer2');
                
                const plz1 = extractPLZ(answer1);
                const plz2 = extractPLZ(answer2);
                
                if (plz1 && plz2) {
                    try {
                        const result = await calculatePLZDistanceAdvanced(plz1, plz2);
                        
                        if (result && result.distance !== null) {
                            let distanceText = '';
                            
                            if (result.distance === 0) {
                                distanceText = 'Ihr wohnt in derselben PLZ';
                            } else {
                                if (result.distance <= 10) {
                                    distanceText = `Sehr nah (${result.distance} km)`;
                                } else if (result.distance <= 25) {
                                    distanceText = `Gleiche Region (ca. ${result.distance} km)`;
                                } else {
                                    distanceText = `√Ñhnliche Region (ca. ${result.distance} km)`;
                                }
                            }
                            
                            const mapsLinks = generateMapsLinks(plz1, plz2);
                            const mapsLinksJSON = JSON.stringify(mapsLinks).replace(/"/g, '&quot;');
                            
                            // Erstelle editierbaren Text + Navigation Button
                            cell.innerHTML = `
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span contenteditable="true" style="flex: 1;">${distanceText}</span>
                                    <button onclick="event.stopPropagation(); showNavigationOptions(JSON.parse('${mapsLinksJSON}'), '${plz1}', '${plz2}');" 
                                            class="btn btn-outline btn-small" 
                                            style="padding: 0.3rem 0.6rem; white-space: nowrap; position: absolute; right: 0.5rem;"
                                            title="Navigation √∂ffnen">
                                        üó∫Ô∏è Navi
                                    </button>
                                </div>
                            `;
                            cell.style.background = 'var(--swaf-lightest-teal)';
                        }
                    } catch (error) {
                        console.error('Fehler bei PLZ-Berechnung:', error);
                        cell.textContent = 'Distanz nicht berechenbar';
                    }
                } else {
                    cell.textContent = 'Keine g√ºltigen PLZ gefunden';
                }
            }
        }

        function openAIAssistant(question, answer1, answer2) {
            console.log('ü§ñ openAIAssistant aufgerufen');
            console.log('Question:', question);
            console.log('Answer1:', answer1);
            console.log('Answer2:', answer2);
            
            const promptTemplate = localStorage.getItem('swaf_ai_prompt') || 'Schreibe hierzu einen kurzen Text. Die Frage zu den Antworten lautet {Frage}. Schreibe, wie die Antworten zusammenpassen k√∂nnten bzw. gebe Beispiele aus. Hier die Antworten: Person 1 - {Antwort1}, Person 2 - {Antwort2}. Schreibe den Text nach diesem Beispiel: "Ihr habt beide angegeben, dass ihr gerne kocht - ob mit Freund*innen oder alleine. Also los! Probiert doch einmal gemeinsam neue Rezepte. Au√üerdem geht ihr beide gerne Spazieren. "Nach dem Essen sollst du Ruhn, oder 1.000 Schritte tun." Also habt ihr ja quasi schon einen Tagesplan ;) Weil ihr beide gerne auch kulturelle Dinge macht, wie in das Theater/Museum/oder auf andere Kulturveranstaltungen geht - schaut doch mal auf rausgegangen.de was es in K√∂ln so die n√§chsten Tage gibt. Oder guckt bei uns im Eventportal: www.startwithafriend.de/events" - Nenne KEINE Namen oder andere Personenbezeichnungen.';
            
            console.log('Prompt Template L√§nge:', promptTemplate.length);
            
            // Ersetze leere Antworten mit "Keine Angabe"
            const cleanAnswer1 = (answer1 && answer1.trim()) ? answer1 : 'Keine Angabe';
            const cleanAnswer2 = (answer2 && answer2.trim()) ? answer2 : 'Keine Angabe';
            
            console.log('Clean Answer1:', cleanAnswer1);
            console.log('Clean Answer2:', cleanAnswer2);
            
            const prompt = promptTemplate
                .replace('{Frage}', question)
                .replace('{Antwort1}', cleanAnswer1)
                .replace('{Antwort2}', cleanAnswer2);
            
            console.log('Finaler Prompt:', prompt);
            console.log('Prompt L√§nge:', prompt.length);
            
            // Speichere Prompt tempor√§r
            window._currentAIPrompt = prompt;
            console.log('Prompt in window gespeichert');
            
            const escapedPrompt = prompt.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            
            createModal('ü§ñ KI-Unterst√ºtzung', `
                <p style="margin-bottom: 1rem;">W√§hle deinen bevorzugten KI-Assistenten:</p>
                
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <button class="btn btn-primary" id="open-chatgpt-btn" style="padding: 1rem;">
                        üí¨ ChatGPT √∂ffnen
                    </button>
                    <button class="btn btn-secondary" id="open-claude-btn" style="padding: 1rem;">
                        ü§ñ Claude.ai √∂ffnen
                    </button>
                </div>
                
                <div style="margin-top: 1.5rem; padding: 1rem; background: #f8f9fa; border-radius: 4px;">
                    <h4 style="margin-top: 0;">üìã Prompt-Vorschau:</h4>
                    <textarea id="ai-prompt-preview" readonly style="width: 100%; height: 150px; font-family: monospace; font-size: 0.85rem; resize: vertical;">${escapedPrompt}</textarea>
                    <button class="btn btn-outline btn-small" id="copy-prompt-btn" style="margin-top: 0.5rem;">
                        üìã Prompt kopieren
                    </button>
                </div>
            `, [
                { text: 'Schlie√üen', class: 'btn-outline', action: 'closeModal' }
            ]);
            
            // Event Listener nach Modal-Erstellung hinzuf√ºgen
            setTimeout(() => {
                const chatgptBtn = document.getElementById('open-chatgpt-btn');
                const claudeBtn = document.getElementById('open-claude-btn');
                const copyBtn = document.getElementById('copy-prompt-btn');
                
                console.log('Event Listener werden hinzugef√ºgt...');
                console.log('ChatGPT Button gefunden:', !!chatgptBtn);
                console.log('Claude Button gefunden:', !!claudeBtn);
                
                if (chatgptBtn) {
                    chatgptBtn.addEventListener('click', function() {
                        console.log('ChatGPT Button geklickt!');
                        console.log('Prompt aus window:', window._currentAIPrompt);
                        openChatGPT(window._currentAIPrompt);
                    });
                }
                
                if (claudeBtn) {
                    claudeBtn.addEventListener('click', function() {
                        console.log('Claude Button geklickt!');
                        console.log('Prompt aus window:', window._currentAIPrompt);
                        openClaude(window._currentAIPrompt);
                    });
                }
                
                if (copyBtn) {
                    copyBtn.addEventListener('click', function() {
                        const textarea = document.getElementById('ai-prompt-preview');
                        navigator.clipboard.writeText(textarea.value).then(() => {
                            showNotification('üìã Prompt kopiert', 'success', 2000);
                        });
                    });
                }
            }, 100);
        }

        function openChatGPT(prompt) {
            console.log('üí¨ √ñffne ChatGPT...');
            navigator.clipboard.writeText(prompt).then(() => {
                window.open('https://chat.openai.com/', '_blank');
                closeModal();
                showNotification('üí¨ ChatGPT ge√∂ffnet - Prompt wurde in Zwischenablage kopiert. Einfach einf√ºgen (Strg+V)!', 'success', 4000);
            }).catch(err => {
                console.error('Fehler beim Kopieren:', err);
                window.open('https://chat.openai.com/', '_blank');
                closeModal();
                showNotification('üí¨ ChatGPT ge√∂ffnet - Bitte Prompt manuell kopieren', 'warning', 4000);
            });
        }

        function openClaude(prompt) {
            console.log('ü§ñ √ñffne Claude.ai...');
            navigator.clipboard.writeText(prompt).then(() => {
                window.open('https://claude.ai/new', '_blank');
                closeModal();
                showNotification('ü§ñ Claude.ai ge√∂ffnet - Prompt wurde in Zwischenablage kopiert. Einfach einf√ºgen (Strg+V)!', 'success', 4000);
            }).catch(err => {
                console.error('Fehler beim Kopieren:', err);
                window.open('https://claude.ai/new', '_blank');
                closeModal();
                showNotification('ü§ñ Claude.ai ge√∂ffnet - Bitte Prompt manuell kopieren', 'warning', 4000);
            });
        }

        function saveAIPrompt() {
            const prompt = document.getElementById('ai-prompt-template').value;
            localStorage.setItem('swaf_ai_prompt', prompt);
            showNotification('‚úÖ KI-Prompt gespeichert', 'success');
        }

        function resetAIPrompt() {
            const defaultPrompt = 'Schreibe hierzu einen kurzen Text. Die Frage zu den Antworten lautet {Frage}. Schreibe, wie die Antworten zusammenpassen k√∂nnten bzw. gebe Beispiele aus. Hier die Antworten: Person 1 - {Antwort1}, Person 2 - {Antwort2}. Schreibe den Text nach diesem Beispiel: "Ihr habt beide angegeben, dass ihr gerne kocht - ob mit Freund*innen oder alleine. Also los! Probiert doch einmal gemeinsam neue Rezepte. Au√üerdem geht ihr beide gerne Spazieren. "Nach dem Essen sollst du Ruhn, oder 1.000 Schritte tun." Also habt ihr ja quasi schon einen Tagesplan ;) Weil ihr beide gerne auch kulturelle Dinge macht, wie in das Theater/Museum/oder auf andere Kulturveranstaltungen geht - schaut doch mal auf rausgegangen.de was es in K√∂ln so die n√§chsten Tage gibt. Oder guckt bei uns im Eventportal: www.startwithafriend.de/events" - Nenne KEINE Namen oder andere Personenbezeichnungen.';
            document.getElementById('ai-prompt-template').value = defaultPrompt;
            localStorage.setItem('swaf_ai_prompt', defaultPrompt);
            showNotification('‚úÖ KI-Prompt zur√ºckgesetzt', 'success');
        }

        // Globale Funktion verf√ºgbar machen
        window.showAllFields = showAllFields;

        window.autoCalculatePLZDistances = autoCalculatePLZDistances;
        window.openAIAssistant = openAIAssistant;
        window.openChatGPT = openChatGPT;
        window.openClaude = openClaude;
        window.saveAIPrompt = saveAIPrompt;
        window.resetAIPrompt = resetAIPrompt;

        window.loadFieldsWithOrder = loadFieldsWithOrder;
        window.moveFieldUp = moveFieldUp;
        window.moveFieldDown = moveFieldDown;

        // ===============================
        // SCHNELLES TEXTING - NEUE FUNKTIONEN
        // ===============================

        let bulkEditMode = false;
        let shortcutInfoVisible = false;

        // Zeige Quick Actions nur bei Tandem-Bearbeitung
        function showQuickActions() {
            const quickActions = document.getElementById('quick-actions');
            const currentTab = document.querySelector('.tab.active');
            const isEditingTab = currentTab && currentTab.textContent.includes('Bearbeitung');
            
            if (isEditingTab && currentTandem) {
                quickActions.style.display = 'flex';
            } else {
                quickActions.style.display = 'none';
            }
        }

        // Leere alle Gemeinsamkeiten f√ºr Neustart
        function clearAllCommonalities() {
            if (!currentTandem) {
                showNotification('‚ùå Bitte zuerst ein Tandem ausw√§hlen', 'error');
                return;
            }
            
            if (!confirm('Alle Gemeinsamkeiten-Texte l√∂schen?')) return;
            
            const table = document.getElementById('tandem-table');
            const rows = table.querySelectorAll('tbody tr');
            let cleared = 0;
            
            rows.forEach(row => {
                const commonalityCell = row.querySelector('td:nth-child(4)[contenteditable]');
                if (commonalityCell && commonalityCell.textContent.trim()) {
                    commonalityCell.textContent = '';
                    cleared++;
                }
            });
            
            showNotification(`üßπ ${cleared} Gemeinsamkeiten geleert`, 'success', 2000);
        }

        // Bulk-Edit Modus
        function toggleBulkEditMode() {
            bulkEditMode = !bulkEditMode;
            const toolbar = document.getElementById('bulk-edit-toolbar');
            const table = document.getElementById('tandem-table');
            
            if (bulkEditMode) {
                table.classList.add('bulk-edit-mode');
                toolbar.classList.add('visible');
                showNotification('üöÄ Bulk-Edit Modus aktiviert', 'info', 3000);
            } else {
                exitBulkEditMode();
            }
        }

        function exitBulkEditMode() {
            bulkEditMode = false;
            const toolbar = document.getElementById('bulk-edit-toolbar');
            const table = document.getElementById('tandem-table');
            
            table.classList.remove('bulk-edit-mode');
            toolbar.classList.remove('visible');
            showNotification('Bulk-Edit Modus beendet', 'info', 2000);
        }

        function applyBulkTemplate() {
            const select = document.getElementById('bulk-template-select');
            const template = select.value;
            
            if (!template) {
                alert('Bitte w√§hle einen Text aus.');
                return;
            }
            
            const table = document.getElementById('tandem-table');
            const rows = table.querySelectorAll('tbody tr');
            let applied = 0;
            
            rows.forEach(row => {
                const commonalityCell = row.querySelector('td:nth-child(4)[contenteditable]');
                if (commonalityCell && !commonalityCell.textContent.trim()) {
                    commonalityCell.textContent = template;
                    applied++;
                }
            });
            
            showNotification(`üìù ${applied} Zellen mit "${template}" gef√ºllt`, 'success', 3000);
            exitBulkEditMode();
        }

        // Shortcuts Info ein/ausblenden
        function toggleShortcutInfo() {
            shortcutInfoVisible = !shortcutInfoVisible;
            const shortcuts = document.getElementById('keyboard-shortcuts');
            shortcuts.classList.toggle('visible', shortcutInfoVisible);
            
            if (shortcutInfoVisible) {
                setTimeout(hideShortcutInfo, 5000); // Auto-hide nach 5 Sekunden
            }
        }

        function hideShortcutInfo() {
            shortcutInfoVisible = false;
            document.getElementById('keyboard-shortcuts').classList.remove('visible');
        }

        function showShortcutFeedback(message) {
            // Kurze Feedback-Nachricht
            const feedback = document.createElement('div');
            feedback.textContent = message;
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--swaf-teal);
                color: white;
                padding: 1rem 2rem;
                border-radius: 8px;
                font-weight: bold;
                font-size: 1.2rem;
                z-index: 10000;
                animation: fadeInOut 1.5s ease-in-out forwards;
            `;
            
            // CSS Animation
            if (!document.querySelector('#feedback-animation-css')) {
                const style = document.createElement('style');
                style.id = 'feedback-animation-css';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(feedback);
            setTimeout(() => feedback.remove(), 1500);
        }

        // Update showQuickActions wenn Tab gewechselt wird
        const originalSwitchTab = switchTab;
        switchTab = function(tabIndex) {
            originalSwitchTab(tabIndex);
            setTimeout(showQuickActions, 100);
        };

        // Update showQuickActions wenn Tandem ausgew√§hlt wird  
        const originalLoadTandemForEditing = loadTandemForEditing;
        loadTandemForEditing = function() {
            originalLoadTandemForEditing();
            showQuickActions();
        };

        // ===============================
        // INTELLIGENTE LOKALE TEXTGENERIERUNG
        // ===============================

        function extractFirstNameSmart(fullName) {
            if (!fullName || typeof fullName !== 'string') {
                return 'die Person';
            }

            console.log(`üìõ Analysiere Vollname: "${fullName}"`);

            // 1. Suche nach Namen in Klammern (h√∂chste Priorit√§t)
            const bracketMatch = fullName.match(/\(([^)]+)\)/);
            if (bracketMatch) {
                const nameInBrackets = bracketMatch[1].trim();
                const firstName = nameInBrackets.split(/[\s,]+/)[0];
                if (firstName && firstName.length > 1 && !firstName.match(/^(locals?|einwander|interview|gespr√§ch)/i)) {
                    console.log(`‚úÖ Name aus Klammern: "${firstName}"`);
                    return firstName;
                }
            }

            // 2. Pr√ºfe ob es ein Profilname ohne Pr√§fix ist (z.B. nur "Sara Mustermann")
            if (!fullName.match(/^(aufnahmegespr√§ch|interview|gespr√§ch)/i)) {
                const firstName = fullName.split(/[\s,]+/)[0];
                if (firstName && firstName.length > 1) {
                    console.log(`‚úÖ Direkter Name: "${firstName}"`);
                    return firstName;
                }
            }

            // 3. Extrahiere Namen nach Pr√§fix-Mustern
            const prefixPatterns = [
                /^aufnahmegespr√§ch\s+einwander\*innen\s+\(([^)]+)\)/i,
                /^aufnahmegespr√§ch\s+locals?\s+\(([^)]+)\)/i,
                /^interview\s+(.+?)$/i,
                /^gespr√§ch\s+(.+?)$/i
            ];

            for (const pattern of prefixPatterns) {
                const match = fullName.match(pattern);
                if (match) {
                    const extractedName = match[1].trim();
                    const firstName = extractedName.split(/[\s,]+/)[0];
                    if (firstName && firstName.length > 1) {
                        console.log(`‚úÖ Name nach Muster: "${firstName}" aus "${extractedName}"`);
                        return firstName;
                    }
                }
            }

            console.log(`‚ö†Ô∏è Fallback f√ºr: "${fullName}"`);
            return 'die Person';
        }

        function generateSmartTextsLocally() {
            if (!currentTandem) {
                showNotification('‚ùå Bitte w√§hle zuerst ein Tandem aus', 'error');
                return;
            }

            const table = document.getElementById('tandem-table');
            const rows = table.querySelectorAll('tbody tr');
            let generated = 0;

            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 4) {
                    const question = cells[0].textContent.trim();
                    const answer1 = cells[1].textContent.trim();
                    const answer2 = cells[2].textContent.trim();
                    const currentText = cells[3].textContent.trim();

                    // Nur leere oder Standard-Texte √ºberschreiben, aber NIE ausgeschlossene Felder
                    if ((!currentText || currentText === 'Keine √úbereinstimmung' || currentText.length < 5) && 
                        !shouldExcludeFromMatching(question)) {
                        const smartText = generateIntelligentText(question, answer1, answer2);
                        if (smartText) {
                            cells[3].textContent = smartText;
                            cells[3].style.background = 'var(--swaf-lightest-teal)';
                            setTimeout(() => cells[3].style.background = '', 2000);
                            generated++;
                        }
                    }
                }
            });

            if (generated > 0) {
                showNotification(`üß† ${generated} intelligente Texte generiert!`, 'success', 4000);

                // Gamification: Smart-Text verwendet
                trackActivity('smart_text_used');
            } else {
                showNotification('‚ÑπÔ∏è Alle Zellen sind bereits gef√ºllt', 'info', 2000);
            }
        }

        function generateIntelligentText(question, answer1, answer2, profile1 = null, profile2 = null) {
            // Normalisiere Antworten und erkenne leere/fehlende Werte
            const a1 = cleanAnswer(answer1);
            const a2 = cleanAnswer(answer2);
            const q = question.toLowerCase();
            
            // Pr√ºfe ob Frage von der intelligenten Analyse ausgeschlossen werden soll
            if (shouldExcludeFromMatching(question)) {
                console.log(`üö´ Intelligente Analyse √ºbersprungen f√ºr: "${question}"`);
                return ''; // Leer lassen f√ºr ausgeschlossene Felder
            }
            
            // Profile-Namen extrahieren - entweder aus √ºbergebenen Profilen oder currentTandem
            let name1, name2;
            if (profile1 && profile2) {
                name1 = extractFirstName(profile1.name);
                name2 = extractFirstName(profile2.name);
            } else if (currentTandem && currentTandem.profile1 && currentTandem.profile2) {
                name1 = extractFirstName(currentTandem.profile1.name);
                name2 = extractFirstName(currentTandem.profile2.name);
            } else {
                console.log('‚ö†Ô∏è Keine Profile-Informationen verf√ºgbar f√ºr intelligente Analyse');
                return '';
            }

            console.log(`üîç Intelligente Analyse: "${question}" | "${a1}" vs "${a2}" | Namen: ${name1}, ${name2}`);

            // Keine verwertbaren Antworten
            if (!a1 && !a2) {
                return getNoAnswerText(question);
            }
            
            // Nur eine Person hat geantwortet
            if (!a1 && a2) {
                return getOneAnswerText(question, name2, name1, a2, false);
            }
            if (a1 && !a2) {
                return getOneAnswerText(question, name1, name2, a1, true);
            }

            // Beide haben geantwortet - intelligente Analyse
            return analyzeBothAnswersIntelligently(question, name1, name2, a1, a2);
        }

        function analyzeBothAnswersIntelligently(question, name1, name2, answer1, answer2) {
            const q = question.toLowerCase();
            
            console.log(`üß† Detaillierte Analyse f√ºr: "${question}"`);
            console.log(`üìù Antworten: "${answer1}" vs "${answer2}"`);
            
            // 1. EXAKTE √úBEREINSTIMMUNGEN zuerst pr√ºfen
            if (answer1.toLowerCase().trim() === answer2.toLowerCase().trim()) {
                if (q.includes('wichtig') || q.includes('freundschaft')) {
                    return `Gemeinsamer Wert: ${answer1}! Das ist eine starke Basis f√ºr eure Freundschaft üíù`;
                }
                if (q.includes('studium') && answer1.toLowerCase().includes('ja')) {
                    return 'Ihr habt beide studiert - das verbindet! üéì';
                }
                if (q.includes('deutschland') && answer1.toLowerCase().includes('nein')) {
                    return 'Ihr seid beide nicht in Deutschland geboren - √§hnliche Erfahrungen! üåç';
                }
                return `Identisch: ${answer1} - perfekte √úbereinstimmung! ‚ú®`;
            }
            
            // 2. ALTERS-ANALYSE
            if (q.includes('alter') || q.includes('geburt')) {
                const age1 = parseInt(answer1);
                const age2 = parseInt(answer2);
                if (!isNaN(age1) && !isNaN(age2)) {
                    const diff = Math.abs(age1 - age2);
                    if (diff === 0) return 'Ihr seid genau gleich alt! üéÇ';
                    if (diff <= 3) return `Nur ${diff} Jahr${diff > 1 ? 'e' : ''} Unterschied - perfekt! üéØ`;
                    if (diff <= 7) return `${diff} Jahre Unterschied - das passt gut zusammen üòä`;
                    if (diff <= 12) return `Generationsunterschied kann bereichernd sein (${diff} Jahre) ‚ú®`;
                    return 'Verschiedene Lebenserfahrungen zum Austauschen üåü';
                }
            }
            
            // 3. SPRACHEN-ANALYSE (Muss VOR Hobby-Analyse kommen!)
            if (q.includes('sprache') || q.includes('sprichst')) {
                return analyzeLanguagesIntelligently(answer1, answer2);
            }

            // 4. HOBBY-ANALYSE (erweitert)
            if (q.includes('hobby') || q.includes('freizeit') || q.includes('interesse') ||
                q.includes('machst du gerne') || q.includes('ausprobieren') ||
                q.includes('was machst du gerne')) {
                return analyzeHobbysIntelligentlyImproved(answer1, answer2);
            }

            // 5. FREUNDSCHAFTS-WERTE (verbessert)
            if (q.includes('wichtig') || q.includes('freundschaft')) {
                return analyzeFriendshipValuesImproved(answer1, answer2);
            }
            
            // 6. ZEIT-ANALYSE (verbessert)
            if (q.includes('zeit') || q.includes('treffen') || q.includes('wann')) {
                return analyzeTimeCompatibilityImproved(answer1, answer2);
            }
            
            // 7. TANDEM-VORSTELLUNG
            if (q.includes('tandem vor') || q.includes('stellst du dir')) {
                return analyzeTandemExpectations(answer1, answer2);
            }
            
            // 8. VERKEHRSMITTEL
            if (q.includes('bewegst') || q.includes('verkehr') || q.includes('stadt')) {
                return analyzeTransportation(answer1, answer2);
            }
            
            // 9. ERREICHBARKEIT
            if (q.includes('erreichen') || q.includes('kontakt')) {
                return analyzeContactMethods(answer1, answer2);
            }

            // 10. COMMUNITY-EVENTS & AKTIVIT√ÑTEN
            if (q.includes('event') || q.includes('community') || q.includes('unternehmen') ||
                q.includes('aktivit√§t') || q.includes('veranstaltung')) {
                return analyzeCommunityEventsIntelligently(answer1, answer2);
            }

            // 11. STUDIUM/BILDUNG
            if (q.includes('studium') || q.includes('schule') || q.includes('ausbildung')) {
                if (answer1.toLowerCase().trim() === answer2.toLowerCase().trim()) {
                    return `Identisch: ${answer1} - das verbindet! üéì`;
                }
                return 'Verschiedene Bildungswege - viel zu erz√§hlen! üìö';
            }

            // 12. JA/NEIN Fragen
            if ((answer1.toLowerCase().includes('ja') && answer2.toLowerCase().includes('ja')) ||
                (answer1.toLowerCase().includes('nein') && answer2.toLowerCase().includes('nein'))) {
                return `Ihr seid euch einig: ${answer1}! ‚úÖ`;
            }

            // 13. STANDARD f√ºr alle anderen
            return getDifferenceTextImproved(question, name1, name2, answer1, answer2);
        }

        function analyzeHobbysIntelligentlyImproved(answer1, answer2) {
            // Liste bekannter Sprachen, die NICHT als Hobbys gelten
            const languageKeywords = [
                'deutsch', 'englisch', 'franz√∂sisch', 'spanisch', 'italienisch',
                't√ºrkisch', 'arabisch', 'persisch', 'russisch', 'polnisch',
                'portugiesisch', 'niederl√§ndisch', 'chinesisch', 'japanisch',
                'koreanisch', 'griechisch', 'kroatisch', 'serbisch', 'ukrainisch',
                'farsi', 'kurdisch', 'dari', 'paschtu', 'hindi', 'urdu', 'bengali',
                'tamil', 'vietnamese', 'thai', 'indonesisch', 'filipino', 'tagalog'
            ];

            // Parse und filtere Sprachen aus
            const hobbies1 = answer1.toLowerCase()
                .split(/[,;]/)
                .map(s => s.trim())
                .filter(s => s.length > 2)
                .filter(s => !languageKeywords.some(lang => s === lang || s.includes(lang + 'e') || s.includes(lang + 'es')));

            const hobbies2 = answer2.toLowerCase()
                .split(/[,;]/)
                .map(s => s.trim())
                .filter(s => s.length > 2)
                .filter(s => !languageKeywords.some(lang => s === lang || s.includes(lang + 'e') || s.includes(lang + 'es')));

            console.log(`üé® Verbesserte Hobby-Analyse (Sprachen gefiltert): [${hobbies1.join(', ')}] vs [${hobbies2.join(', ')}]`);
            
            // Erweiterte Hobby-Synonyme basierend auf realen Daten (SwaF K√∂ln 2024-2026)
            const synonymGroups = [
                // Sport & Bewegung (sehr h√§ufig)
                {
                    keywords: ['sport', 'fitness', 'training', 'bewegung', 'fitnessstudio', 'gym', 'krafttraining'],
                    name: 'Sport/Fitness'
                },
                {
                    keywords: ['fu√üball', 'fussball', 'football', 'soccer', 'kicken'],
                    name: 'Fu√üball'
                },
                {
                    keywords: ['wandern', 'hiking', 'bergsteigen', 'trekking', 'in die berge'],
                    name: 'Wandern'
                },
                {
                    keywords: ['spazieren', 'spazieren gehen', 'walks', 'schlendern', 'flanieren'],
                    name: 'Spazieren'
                },
                {
                    keywords: ['schwimmen', 'schwimmbad', 'pool', 'baden'],
                    name: 'Schwimmen'
                },
                {
                    keywords: ['yoga', 'meditation', 'achtsamkeit', 'entspannung'],
                    name: 'Yoga/Meditation'
                },
                {
                    keywords: ['laufen', 'joggen', 'running', 'rennen'],
                    name: 'Laufen/Joggen'
                },
                {
                    keywords: ['fahrrad', 'radfahren', 'cycling', 'bike', 'fahrradtouren'],
                    name: 'Fahrrad fahren'
                },
                {
                    keywords: ['tanzen', 'dance', 'salsa', 'bachata', 'zumba', 'tanzschule'],
                    name: 'Tanzen'
                },
                {
                    keywords: ['klettern', 'bouldern', 'climbing', 'kletterhalle'],
                    name: 'Klettern'
                },
                {
                    keywords: ['volleyball', 'basketball', 'badminton', 'tischtennis', 'tennis'],
                    name: 'Ball-Sport'
                },

                // Kultur & Unterhaltung (h√§ufig)
                {
                    keywords: ['kino', 'ins kino gehen', 'filme schauen', 'film', 'filme', 'movies'],
                    name: 'Kino/Filme'
                },
                {
                    keywords: ['serien', 'netflix', 'streaming', 'tv', 'fernsehen'],
                    name: 'Serien'
                },
                {
                    keywords: ['museum', 'ins museum gehen', 'ausstellungen', 'galerie', 'galerien'],
                    name: 'Museum/Ausstellungen'
                },
                {
                    keywords: ['theater', 'ins theater gehen', 'schauspiel', 'oper', 'musical'],
                    name: 'Theater'
                },
                {
                    keywords: ['konzerte', 'konzert', 'livemusik', 'gigs', 'shows'],
                    name: 'Konzerte'
                },
                {
                    keywords: ['musik', 'musik h√∂ren', 'musikh√∂ren', 'music', 'songs'],
                    name: 'Musik h√∂ren'
                },

                // Sozial & Ausgehen
                {
                    keywords: ['freunde treffen', 'leute treffen', 'soziale kontakte', 'socializing'],
                    name: 'Freunde treffen'
                },
                {
                    keywords: ['feiern', 'feiern gehen', 'party', 'ausgehen', 'clubs', 'nightlife'],
                    name: 'Feiern/Party'
                },
                {
                    keywords: ['caf√©', 'cafe', 'kaffee trinken', 'coffee', 'kaffeeh√§user'],
                    name: 'Caf√©/Kaffee'
                },
                {
                    keywords: ['restaurant', 'essen gehen', 'dining', 'restaurants besuchen'],
                    name: 'Essen gehen'
                },
                {
                    keywords: ['bar', 'bars', 'kneipe', 'kneipen', 'pub', 'drinks'],
                    name: 'Bars/Kneipen'
                },

                // Kreativ & Handwerk
                {
                    keywords: ['kochen', 'gemeinsam kochen', 'essen zubereiten', 'kulinarik', 'rezepte'],
                    name: 'Kochen'
                },
                {
                    keywords: ['backen', 'kuchen', 'torten', 'geb√§ck', 'baking'],
                    name: 'Backen'
                },
                {
                    keywords: ['zeichnen', 'malen', 'kunst', 'painting', 'drawing', 'skizzieren'],
                    name: 'Zeichnen/Malen'
                },
                {
                    keywords: ['fotografie', 'fotografieren', 'photos', 'bilder', 'camera'],
                    name: 'Fotografie'
                },
                {
                    keywords: ['schreiben', 'writing', 'texte', 'geschichten', 'gedichte', 'blog'],
                    name: 'Schreiben'
                },
                {
                    keywords: ['handwerk', 'basteln', 'diy', 'werken', 'reparieren'],
                    name: 'Handwerk/Basteln'
                },
                {
                    keywords: ['n√§hen', 'stricken', 'h√§keln', 'sewing', 'knitting'],
                    name: 'N√§hen/Stricken'
                },

                // Wissen & Lernen
                {
                    keywords: ['lesen', 'b√ºcher', 'literatur', 'reading', 'books'],
                    name: 'Lesen/B√ºcher'
                },
                {
                    keywords: ['podcast', 'podcasts', 'h√∂rbuch', 'h√∂rb√ºcher', 'audiobooks'],
                    name: 'Podcasts'
                },
                {
                    keywords: ['lernen', 'weiterbildung', 'kurse', 'learning', 'studieren'],
                    name: 'Lernen/Weiterbildung'
                },

                // Natur & Drau√üen
                {
                    keywords: ['natur', 'drau√üen sein', 'wald', 'nature', 'outdoor'],
                    name: 'Natur'
                },
                {
                    keywords: ['garten', 'g√§rtnern', 'pflanzen', 'gardening', 'botanik'],
                    name: 'Garten/Pflanzen'
                },
                {
                    keywords: ['reisen', 'urlaub', 'travel', 'l√§nder', 'st√§dtetrips'],
                    name: 'Reisen'
                },
                {
                    keywords: ['camping', 'zelten', 'outdoor', 'wildcamping'],
                    name: 'Camping'
                },

                // Spiele & Gaming
                {
                    keywords: ['gesellschaftsspiele', 'brettspiele', 'boardgames', 'kartenspiele'],
                    name: 'Gesellschaftsspiele'
                },
                {
                    keywords: ['gaming', 'videospiele', 'zocken', 'playstation', 'xbox', 'pc games'],
                    name: 'Gaming/Videospiele'
                },
                {
                    keywords: ['schach', 'chess', 'dame', 'go', 'strategiespiele'],
                    name: 'Schach'
                },

                // Technologie & Digital
                {
                    keywords: ['it', 'technik', 'technologie', 'computer', 'programmieren', 'coding'],
                    name: 'IT/Technik'
                },

                // Diskussion & Austausch
                {
                    keywords: ['politik', 'gesellschaft', 'debattieren', 'diskutieren', 'politics'],
                    name: 'Politik/Gesellschaft'
                }
            ];
            
            const commonHobbies = [];
            
            // Finde √úbereinstimmungen durch Synonym-Gruppen
            synonymGroups.forEach(group => {
                const hobby1Matches = hobbies1.some(h => 
                    group.keywords.some(keyword => h.includes(keyword) || keyword.includes(h))
                );
                const hobby2Matches = hobbies2.some(h => 
                    group.keywords.some(keyword => h.includes(keyword) || keyword.includes(h))
                );
                
                if (hobby1Matches && hobby2Matches) {
                    commonHobbies.push(group.name);
                    console.log(`‚úÖ Gemeinsames Hobby gefunden: ${group.name}`);
                }
            });
            
            // Direkte √úbereinstimmungen f√ºr nicht-kategorisierte Hobbys
            hobbies1.forEach(h1 => {
                hobbies2.forEach(h2 => {
                    if (h1 === h2 && h1.length > 3 && !commonHobbies.some(ch => h1.includes(ch.toLowerCase()))) {
                        commonHobbies.push(h1);
                        console.log(`‚úÖ Direkte √úbereinstimmung: ${h1}`);
                    }
                });
            });
            
            console.log(`üéØ Finale gemeinsame Hobbys: [${commonHobbies.join(', ')}]`);
            
            if (commonHobbies.length === 0) {
                return 'Verschiedene Hobbys - perfekt um neue Dinge voneinander zu lernen! üåü';
            } else if (commonHobbies.length === 1) {
                return `Gemeinsames Hobby: ${commonHobbies[0]}! Das verbindet euch sofort üéØ`;
            } else if (commonHobbies.length <= 3) {
                return `${commonHobbies.length} gemeinsame Hobbys: ${commonHobbies.join(', ')}! Perfekte Basis f√ºr eure Freundschaft üé®`;
            } else {
                return `Viele gemeinsame Hobbys: ${commonHobbies.slice(0, 3).join(', ')} und mehr! Ihr werdet zusammen viel Spa√ü haben üéâ`;
            }
        }

        function analyzeFriendshipValuesImproved(values1, values2) {
            const v1 = values1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const v2 = values2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            
            console.log(`üíù Verbesserte Freundschafts-Analyse: [${v1.join(', ')}] vs [${v2.join(', ')}]`);
            
            // Exakte √úbereinstimmungen haben Priorit√§t
            const exactMatches = v1.filter(val1 => 
                v2.some(val2 => val1 === val2)
            );
            
            if (exactMatches.length > 0) {
                if (exactMatches.length === 1) {
                    return `Gemeinsamer Wert: ${exactMatches[0]}! Das ist eine perfekte Basis f√ºr eure Freundschaft üíù`;
                } else {
                    return `${exactMatches.length} gemeinsame Werte: ${exactMatches.join(', ')}! Ihr passt wirklich gut zusammen ü§ù`;
                }
            }
            
            // √Ñhnliche Werte
            const similarMatches = v1.filter(val1 => 
                v2.some(val2 => val1.includes(val2) || val2.includes(val1))
            );
            
            if (similarMatches.length > 0) {
                return `√Ñhnliche Werte: ${similarMatches[0]} - das erg√§nzt sich gut! üí´`;
            }
            
            // Erg√§nzende Werte
            const complementaryPairs = [
                ['ehrlichkeit', 'vertrauen'],
                ['humor', 'spa√ü'],
                ['treue', 'loyalit√§t'],
                ['respekt', 'toleranz'],
                ['hilfsbereitschaft', 'unterst√ºtzung']
            ];
            
            for (const [val1, val2] of complementaryPairs) {
                if (v1.some(v => v.includes(val1)) && v2.some(v => v.includes(val2))) {
                    return `${val1} und ${val2} - das erg√§nzt sich perfekt! ü§ù`;
                }
            }
            
            return 'Verschiedene Werte k√∂nnen Freundschaften bereichern! üåü';
        }

        function analyzeTimeCompatibilityImproved(time1, time2) {
            const t1 = time1.toLowerCase();
            const t2 = time2.toLowerCase();
            
            console.log(`‚è∞ Zeit-Analyse: "${t1}" vs "${t2}"`);
            
            // Exakte √úbereinstimmungen
            if (t1 === t2) {
                return `Identische Verf√ºgbarkeit: ${time1}! ‚è∞`;
            }
            
            // Wochenende
            if (t1.includes('wochenende') && t2.includes('wochenende')) {
                return 'Beide am Wochenende verf√ºgbar - perfekt f√ºr gemeinsame Aktivit√§ten! üìÖ';
            }
            
            // Abends
            if (t1.includes('abend') && t2.includes('abend')) {
                return 'Beide abends Zeit - ideal f√ºr entspannte Treffen! üåÜ';
            }
            
            // Morgens/Vormittags
            if ((t1.includes('morgen') || t1.includes('vormittag')) && 
                (t2.includes('morgen') || t2.includes('vormittag'))) {
                return 'Beide Fr√ºhaufsteher - perfekt f√ºr Morgen-Aktivit√§ten! ‚òÄÔ∏è';
            }
            
            // Flexibilit√§t erkennen
            if (t1.includes('flexibel') || t2.includes('flexibel') || 
                t1.includes('egal') || t2.includes('egal')) {
                return 'Einer von euch ist zeitlich flexibel - das macht Terminplanung einfach! ‚ú®';
            }
            
            // √úberschneidungen finden
            const overlap = findTimeOverlaps(t1, t2);
            if (overlap.length > 0) {
                return `√úberschneidung bei: ${overlap.join(', ')} - ihr findet bestimmt gemeinsame Termine! ‚è∞`;
            }
            
            return 'Verschiedene Zeiten - aber Kompromisse machen Freundschaften stark! üí™';
        }

        function findTimeOverlaps(time1, time2) {
            const timeSlots = ['wochenende', 'samstag', 'sonntag', 'abend', 'morgen', 'vormittag', 'nachmittag'];
            return timeSlots.filter(slot => time1.includes(slot) && time2.includes(slot));
        }

        function analyzeTandemExpectations(expectation1, expectation2) {
            const e1 = expectation1.toLowerCase();
            const e2 = expectation2.toLowerCase();
            
            console.log(`ü§ù Tandem-Erwartungen: "${e1}" vs "${e2}"`);
            
            // Deutsche Sprache
            if (e1.includes('deutsch') && e2.includes('deutsch')) {
                return 'Beide wollen Deutsch sprechen/lernen - perfektes Tandem! üó£Ô∏è';
            }
            
            // Stadt erkunden
            if ((e1.includes('stadt') || e1.includes('erkunden')) && 
                (e2.includes('stadt') || e2.includes('erkunden'))) {
                return 'Ihr wollt beide die Stadt erkunden - wird bestimmt spannend! üó∫Ô∏è';
            }
            
            // Kochen
            if (e1.includes('kochen') && e2.includes('kochen')) {
                return 'Gemeinsam kochen - das verbindet und ist lecker! üç≥';
            }
            
            // Kultureller Austausch
            if ((e1.includes('kultur') || e1.includes('austausch')) && 
                (e2.includes('kultur') || e2.includes('austausch'))) {
                return 'Kultureller Austausch ist euch beiden wichtig - perfekte Voraussetzung! üåç';
            }
            
            return 'Verschiedene Erwartungen k√∂nnen euer Tandem bereichern! ‚ú®';
        }

        function analyzeTransportation(transport1, transport2) {
            const t1 = transport1.toLowerCase();
            const t2 = transport2.toLowerCase();
            
            // √ñPNV
            if (t1.includes('√∂pnv') && t2.includes('√∂pnv')) {
                return 'Beide mit √ñPNV unterwegs - umweltfreundlich und flexibel! üöã';
            }
            
            // Auto
            if (t1.includes('auto') && t2.includes('auto')) {
                return 'Beide mit eigenem Auto - perfekt f√ºr Ausfl√ºge! üöó';
            }
            
            // Fahrrad
            if (t1.includes('fahrrad') && t2.includes('fahrrad')) {
                return 'Beide auf dem Fahrrad - gesund und sportlich! üö≤';
            }
            
            // Unterschiedliche Verkehrsmittel
            if (t1.includes('√∂pnv') && t2.includes('auto')) {
                return '√ñPNV und Auto - ihr k√∂nnt flexibel entscheiden wie ihr euch trefft! üöåüöó';
            }
            
            return 'Verschiedene Verkehrsmittel - ihr findet bestimmt einen Weg zueinander! üõ£Ô∏è';
        }

        function analyzeContactMethods(contact1, contact2) {
            const c1 = contact1.toLowerCase();
            const c2 = contact2.toLowerCase();

            // Gemeinsame Kontaktmethoden
            const commonMethods = [];

            if (c1.includes('email') && c2.includes('email')) commonMethods.push('E-Mail');
            if (c1.includes('sms') && c2.includes('sms')) commonMethods.push('SMS');
            if (c1.includes('whatsapp') && c2.includes('whatsapp')) commonMethods.push('WhatsApp');
            if (c1.includes('telefon') && c2.includes('telefon')) commonMethods.push('Telefon');

            if (commonMethods.length > 0) {
                return `Kommunikation √ºber ${commonMethods.join(' und ')} - perfekt! üì±`;
            }

            return 'Verschiedene Kontaktwege - ihr findet bestimmt einen gemeinsamen! üìû';
        }

        function analyzeCommunityEventsIntelligently(event1, event2) {
            // Basiert auf realen SwaF-Event-Daten aus K√∂ln
            const eventCategories = [
                {
                    keywords: ['kochabend', 'kochen', 'gemeinsam kochen', 'kulinarisch', 'rezepte'],
                    name: 'Kochabende',
                    emoji: 'üç≥'
                },
                {
                    keywords: ['spaziergang', 'spazieren', 'abendspazierg', 'walk'],
                    name: 'Spazierg√§nge',
                    emoji: 'üö∂'
                },
                {
                    keywords: ['wandern', 'wanderung', 'hiking', 'bergtouren'],
                    name: 'Wanderungen',
                    emoji: 'ü•æ'
                },
                {
                    keywords: ['museum', 'ausstellung', 'galerie', 'kunstmuseum'],
                    name: 'Museumsbesuche',
                    emoji: 'üèõÔ∏è'
                },
                {
                    keywords: ['konzert', 'livemusik', 'musik', 'band'],
                    name: 'Konzerte',
                    emoji: 'üéµ'
                },
                {
                    keywords: ['picknick', 'park', 'drau√üen essen'],
                    name: 'Picknick',
                    emoji: 'üß∫'
                },
                {
                    keywords: ['kulturabend', 'kultur', 'kulturell', 'kulturveranstaltung'],
                    name: 'Kulturabende',
                    emoji: 'üé≠'
                },
                {
                    keywords: ['spieleabend', 'brettspiele', 'gesellschaftsspiele', 'games'],
                    name: 'Spieleabende',
                    emoji: 'üé≤'
                },
                {
                    keywords: ['speedfriending', 'kennenlern', 'meet'],
                    name: 'Speedfriending',
                    emoji: '‚ö°'
                },
                {
                    keywords: ['fahrrad', 'radtour', 'cycling', 'bike'],
                    name: 'Fahrradtouren',
                    emoji: 'üö¥'
                },
                {
                    keywords: ['sport', 'fu√üball', 'basketball', 'volleyball', 'sportlich'],
                    name: 'Sport-Events',
                    emoji: '‚öΩ'
                },
                {
                    keywords: ['caf√©', 'cafe', 'kaffee', 'coffee'],
                    name: 'Caf√©-Treffen',
                    emoji: '‚òï'
                },
                {
                    keywords: ['kino', 'film', 'movie'],
                    name: 'Kino',
                    emoji: 'üé¨'
                },
                {
                    keywords: ['party', 'feiern', 'tanzen'],
                    name: 'Partys',
                    emoji: 'üéâ'
                }
            ];

            const events1 = event1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const events2 = event2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);

            console.log(`üé™ Event-Analyse: [${events1.join(', ')}] vs [${events2.join(', ')}]`);

            const commonEvents = [];

            // Finde gemeinsame Event-Interessen
            eventCategories.forEach(category => {
                const event1Matches = events1.some(e =>
                    category.keywords.some(keyword => e.includes(keyword) || keyword.includes(e))
                );
                const event2Matches = events2.some(e =>
                    category.keywords.some(keyword => e.includes(keyword) || keyword.includes(e))
                );

                if (event1Matches && event2Matches) {
                    commonEvents.push({ name: category.name, emoji: category.emoji });
                    console.log(`‚úÖ Gemeinsames Event-Interesse: ${category.name}`);
                }
            });

            // Generiere passende Texte
            if (commonEvents.length === 0) {
                return 'Verschiedene Event-Vorlieben - perfekt um Neues kennenzulernen! üåü';
            } else if (commonEvents.length === 1) {
                const event = commonEvents[0];
                return `Gemeinsames Interesse: ${event.name}! ${event.emoji} Das k√∂nnt ihr zusammen besuchen!`;
            } else if (commonEvents.length === 2) {
                return `2 gemeinsame Event-Interessen: ${commonEvents.map(e => e.name).join(' und ')}! ${commonEvents[0].emoji} Viel Auswahl f√ºr euch!`;
            } else {
                const eventNames = commonEvents.slice(0, 3).map(e => e.name).join(', ');
                return `${commonEvents.length} gemeinsame Interessen: ${eventNames}${commonEvents.length > 3 ? ' und mehr' : ''}! üéä Ihr werdet viel zusammen erleben!`;
            }
        }

        function analyzeHobbysIntelligently(answer1, answer2) {
            const hobbies1 = answer1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const hobbies2 = answer2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            
            console.log(`üé® Hobby-Analyse: [${hobbies1.join(', ')}] vs [${hobbies2.join(', ')}]`);
            
            // Hobby-Synonyme f√ºr intelligente Erkennung
            const synonymGroups = [
                ['feiern', 'feiern gehen', 'party', 'ausgehen'],
                ['kino', 'ins kino gehen', 'filme schauen', 'film'],
                ['kochen', 'gemeinsam kochen', 'essen zubereiten'],
                ['museum', 'ins museum gehen', 'kultur', 'ausstellungen'],
                ['theater', 'ins theater gehen', 'schauspiel'],
                ['sport', 'fitness', 'training', 'bewegung'],
                ['musik', 'musikh√∂ren', 'konzerte'],
                ['lesen', 'b√ºcher', 'literatur'],
                ['spazieren', 'wandern', 'natur', 'drau√üen sein']
            ];
            
            const commonHobbies = [];
            
            // Finde √úbereinstimmungen durch Synonym-Gruppen
            synonymGroups.forEach(group => {
                const hobby1Matches = hobbies1.some(h => group.some(syn => h.includes(syn)));
                const hobby2Matches = hobbies2.some(h => group.some(syn => h.includes(syn)));
                
                if (hobby1Matches && hobby2Matches) {
                    commonHobbies.push(group[0]); // Hauptbegriff verwenden
                }
            });
            
            // Direkte √úbereinstimmungen
            hobbies1.forEach(h1 => {
                hobbies2.forEach(h2 => {
                    if (h1 === h2 && !commonHobbies.includes(h1)) {
                        commonHobbies.push(h1);
                    }
                });
            });
            
            console.log(`üéØ Gemeinsame Hobbys gefunden: [${commonHobbies.join(', ')}]`);
            
            if (commonHobbies.length === 0) {
                return 'Verschiedene Hobbys - perfekt um neue Dinge auszuprobieren! üåü';
            } else if (commonHobbies.length === 1) {
                return `Gemeinsames Hobby: ${commonHobbies[0]}! Das verbindet sofort üéØ`;
            } else if (commonHobbies.length <= 3) {
                return `${commonHobbies.length} gemeinsame Hobbys: ${commonHobbies.join(', ')}! Perfekte Basis üé®`;
            } else {
                return `Viele gemeinsame Hobbys: ${commonHobbies.slice(0, 3).join(', ')} und mehr! Ihr werdet viel Spa√ü haben üéâ`;
            }
        }

        function analyzeFriendshipValuesIntelligently(values1, values2) {
            const v1 = values1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const v2 = values2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            
            console.log(`üíù Freundschafts-Analyse: [${v1.join(', ')}] vs [${v2.join(', ')}]`);
            
            // Suche nach gemeinsamen Werten
            const commonValues = v1.filter(val => 
                v2.some(val2 => val.includes(val2) || val2.includes(val) || val === val2)
            );
            
            if (commonValues.length > 0) {
                return `Gemeinsamer Wert: ${commonValues[0]}! Das ist eine starke Basis üíù`;
            }
            
            return 'Verschiedene Werte bereichern Freundschaften! ü§ù';
        }

        function analyzeLanguagesIntelligently(lang1, lang2) {
            // Bekannte Sprachen f√ºr bessere Erkennung
            const knownLanguages = [
                'deutsch', 'englisch', 'franz√∂sisch', 'spanisch', 'italienisch',
                't√ºrkisch', 'arabisch', 'persisch', 'russisch', 'polnisch',
                'portugiesisch', 'niederl√§ndisch', 'chinesisch', 'japanisch',
                'koreanisch', 'griechisch', 'kroatisch', 'serbisch', 'ukrainisch',
                'farsi', 'kurdisch', 'dari', 'paschtu', 'hindi', 'urdu', 'bengali',
                'tamil', 'vietnamese', 'thai', 'indonesisch', 'filipino', 'tagalog'
            ];

            // Parse Sprachen (durch Komma oder Semikolon getrennt)
            const languages1 = lang1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const languages2 = lang2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);

            console.log(`üó£Ô∏è Sprachen-Analyse: [${languages1.join(', ')}] vs [${languages2.join(', ')}]`);

            // Finde gemeinsame Sprachen
            const commonLanguages = [];

            languages1.forEach(lang1 => {
                languages2.forEach(lang2 => {
                    // Exakte √úbereinstimmung
                    if (lang1 === lang2 && !commonLanguages.includes(lang1)) {
                        commonLanguages.push(lang1);
                    }
                    // Substring-Match f√ºr bekannte Sprachen (z.B. "deutsch" in "ein bisschen deutsch")
                    else {
                        knownLanguages.forEach(known => {
                            if (lang1.includes(known) && lang2.includes(known) && !commonLanguages.includes(known)) {
                                commonLanguages.push(known);
                            }
                        });
                    }
                });
            });

            console.log(`‚úÖ Gemeinsame Sprachen: [${commonLanguages.join(', ')}]`);

            // Generiere passenden Text
            if (commonLanguages.length === 0) {
                return 'Verschiedene Sprachen - perfekt zum Voneinander-Lernen! üåé';
            } else if (commonLanguages.length === 1) {
                const langName = commonLanguages[0].charAt(0).toUpperCase() + commonLanguages[0].slice(1);
                return `Gemeinsame Sprache: ${langName}! Das erleichtert die Kommunikation üó£Ô∏è`;
            } else if (commonLanguages.length === 2) {
                const langNames = commonLanguages.map(l => l.charAt(0).toUpperCase() + l.slice(1)).join(' und ');
                return `2 gemeinsame Sprachen: ${langNames}! Ihr k√∂nnt euch gut austauschen üåç`;
            } else {
                const langNames = commonLanguages.slice(0, 3).map(l => l.charAt(0).toUpperCase() + l.slice(1)).join(', ');
                return `${commonLanguages.length} gemeinsame Sprachen: ${langNames}${commonLanguages.length > 3 ? ' und mehr' : ''}! Mehrsprachigkeit verbindet üåé`;
            }
        }

        function analyzeTimeCompatibility(time1, time2) {
            const t1 = time1.toLowerCase();
            const t2 = time2.toLowerCase();
            
            if (t1.includes('wochenende') && t2.includes('wochenende')) {
                return 'Beide am Wochenende verf√ºgbar - perfekt! üìÖ';
            }
            
            if (t1.includes('abend') && t2.includes('abend')) {
                return 'Beide abends Zeit - ideal f√ºr Treffen! üåÜ';
            }
            
            return 'Verschiedene Zeiten - aber Kompromisse sind m√∂glich! ‚è∞';
        }        

        function cleanAnswer(answer) {
            if (!answer || typeof answer !== 'string') return '';
            
            const cleaned = answer.trim();
            
            // Erkenne "keine Antwort" Indikatoren
            const emptyIndicators = [
                '', 'keine angabe', 'nicht angegeben', 'k.a.', 'n/a',
                '---', 'leer', 'keine antwort', 'nicht beantwortet'
            ];
            
            if (emptyIndicators.includes(cleaned.toLowerCase())) {
                return '';
            }
            
            return cleaned;
        }

        function getNoAnswerText(question) {
            const q = question.toLowerCase();
            
            if (q.includes('hobby') || q.includes('interesse')) {
                return 'Perfekte Gelegenheit, eure Hobbys kennenzulernen! üéØ';
            }
            if (q.includes('sprache')) {
                return 'Sprachenaustausch wird spannend! üó£Ô∏è';
            }
            if (q.includes('beruf') || q.includes('arbeit')) {
                return 'Berufstalk beim ersten Treffen! üíº';
            }
            
            return 'Hier gibt\'s viel zu entdecken beim ersten Gespr√§ch! ‚ú®';
        }

        function getOneAnswerText(question, answererName, otherName, answer, isFirst) {
            const q = question.toLowerCase();
            
            // Spezielle Behandlung f√ºr verschiedene Fragetypen
            if (q.includes('hobby') || q.includes('interesse') || q.includes('freizeit')) {
                return `${answererName} kann ${otherName} ${answer} zeigen! üé®`;
            }
            
            if (q.includes('sprache')) {
                return `${answererName} spricht ${answer} - perfekt zum Lernen f√ºr ${otherName}! üåç`;
            }
            
            if (q.includes('beruf') || q.includes('arbeit') || q.includes('job')) {
                return `${answererName} arbeitet ${answer} - ${otherName} kann viel fragen! üíº`;
            }
            
            if (q.includes('wohnort') || q.includes('postleitzahl')) {
                return `${answererName} kennt sich in ${answer} aus - perfekter Tour-Guide! üìç`;
            }
            
            if (q.includes('zeit') || q.includes('treffen')) {
                return `${answererName} hat ${answer} Zeit - ihr findet bestimmt einen gemeinsamen Termin! ‚è∞`;
            }
            
            // Standard f√ºr einseitige Antworten
            return `${answererName} kann ${otherName} von ${answer} erz√§hlen! üí¨`;
        }

        function analyzeBothAnswers(question, name1, name2, answer1, answer2) {
            const q = question.toLowerCase();
            
            // Identische Antworten
            if (answer1.toLowerCase() === answer2.toLowerCase()) {
                return getExactMatchTextImproved(question, answer1);
            }

            // √Ñhnliche Antworten (erweiterte fuzzy matching)
            const similarity = calculateSimilarityImproved(answer1, answer2);
            if (similarity > 0.6) {
                return getSimilarMatchTextImproved(question, answer1, answer2, similarity);
            }

            // Spezifische Analysen nach Fragentyp
            if (q.includes('alter') || q.includes('geburt')) {
                return analyzeAgeCompatibilityImproved(answer1, answer2);
            }
            
            if (q.includes('hobby') || q.includes('freizeit') || q.includes('interesse')) {
                return analyzeHobbyCompatibilityImproved(answer1, answer2);
            }
            
            if (q.includes('sprache') || q.includes('sprichst')) {
                return analyzeLanguageCompatibilityImproved(answer1, answer2);
            }
            
            if (q.includes('postleitzahl') || q.includes('plz')) {
                return analyzePLZCompatibility(answer1, answer2);
            }
            
            if (q.includes('zeit') || q.includes('treffen') || q.includes('wann')) {
                return analyzeTimeCompatibilityImproved(answer1, answer2);
            }
            
            if (q.includes('wichtig') || q.includes('freundschaft')) {
                return analyzeFriendshipValues(answer1, answer2);
            }
            
            if (q.includes('altersunterschied')) {
                return analyzeAgePreferences(answer1, answer2);
            }
            if (q.includes('wichtig') || q.includes('freundschaft')) {
                return analyzeFriendshipValues(answer1, answer2);
            }            

            if (q.includes('anreisen') || q.includes('entfernung')) {
                return analyzeDistancePreferences(answer1, answer2);
            }

            // Standard f√ºr unterschiedliche Antworten
            return getDifferenceTextImproved(question, name1, name2, answer1, answer2);
        }

        function calculateSimilarityImproved(str1, str2) {
            const words1 = str1.toLowerCase().split(/[,;\s]+/).filter(w => w.length > 2);
            const words2 = str2.toLowerCase().split(/[,;\s]+/).filter(w => w.length > 2);
            
            let matches = 0;
            let totalWeight = 0;
            
            words1.forEach(word1 => {
                words2.forEach(word2 => {
                    if (word1 === word2) {
                        matches += 2; // Exakte √úbereinstimmung
                    } else if (word1.includes(word2) || word2.includes(word1)) {
                        matches += 1; // Teil√ºbereinstimmung
                    }
                    totalWeight += 2;
                });
            });
            
            return totalWeight > 0 ? matches / totalWeight : 0;
        }

        function analyzeAgeCompatibilityImproved(age1, age2) {
            const num1 = extractNumber(age1);
            const num2 = extractNumber(age2);
            
            if (num1 && num2) {
                const diff = Math.abs(num1 - num2);
                if (diff === 0) return 'Ihr seid genau gleich alt! üéÇ';
                if (diff <= 3) return `Nur ${diff} Jahr${diff > 1 ? 'e' : ''} Unterschied - perfekt! üéØ`;
                if (diff <= 7) return `${diff} Jahre Unterschied - das passt gut zusammen üòä`;
                if (diff <= 12) return `Altersunterschied kann spannend sein (${diff} Jahre) ‚ú®`;
                return 'Verschiedene Lebenserfahrungen zum Austauschen üåü';
            }
            
            return 'Alter ist nur eine Zahl! üòä';
        }

        function analyzeHobbyCompatibilityImproved(answer1, answer2) {
            const hobbies1 = splitAndNormalize(answer1);
            const hobbies2 = splitAndNormalize(answer2);
            
            console.log(`üé® Hobby-Analyse: "${hobbies1}" vs "${hobbies2}"`);
            
            // Erweiterte Hobby-Synonyme f√ºr besseres Matching
            const hobbyMappings = {
                'feiern': ['feiern gehen', 'ausgehen', 'party'],
                'kino': ['ins kino gehen', 'filme schauen', 'film'],
                'kochen': ['gemeinsam kochen', 'kulinarik', 'essen zubereiten'],
                'museum': ['ins museum gehen', 'kultur', 'ausstellungen'],
                'theater': ['ins theater gehen', 'schauspiel', 'b√ºhne'],
                'sport': ['fitness', 'training', 'bewegung', 'fitnessstudio'],
                'musik': ['musikh√∂ren', 'konzerte', 'konzert'],
                'lesen': ['b√ºcher', 'literatur', 'book'],
                'reisen': ['travel', 'urlaub', 'vacation']
            };
            
            // Finde intelligente √úbereinstimmungen
            const commonHobbies = [];
            
            hobbies1.forEach(hobby1 => {
                hobbies2.forEach(hobby2 => {
                    // Exakte √úbereinstimmung
                    if (hobby1.toLowerCase() === hobby2.toLowerCase()) {
                        if (!commonHobbies.includes(hobby1)) {
                            commonHobbies.push(hobby1);
                        }
                        return;
                    }
                    
                    // Synonym-Matching
                    for (const [mainHobby, synonyms] of Object.entries(hobbyMappings)) {
                        const hobby1IsMain = hobby1.toLowerCase().includes(mainHobby) || 
                                        synonyms.some(syn => hobby1.toLowerCase().includes(syn));
                        const hobby2IsMain = hobby2.toLowerCase().includes(mainHobby) || 
                                        synonyms.some(syn => hobby2.toLowerCase().includes(syn));
                        
                        if (hobby1IsMain && hobby2IsMain && !commonHobbies.includes(mainHobby)) {
                            commonHobbies.push(mainHobby);
                            return;
                        }
                    }
                    
                    // Teilstring-Matching f√ºr √§hnliche Begriffe
                    if ((hobby1.length > 3 && hobby2.toLowerCase().includes(hobby1.toLowerCase())) || 
                        (hobby2.length > 3 && hobby1.toLowerCase().includes(hobby2.toLowerCase()))) {
                        const longerHobby = hobby1.length >= hobby2.length ? hobby1 : hobby2;
                        if (!commonHobbies.includes(longerHobby)) {
                            commonHobbies.push(longerHobby);
                        }
                    }
                });
            });
            
            // Generiere intelligenten Text
            if (commonHobbies.length > 0) {
                if (commonHobbies.length === 1) {
                    return `Gemeinsames Hobby: ${commonHobbies[0]}! Das verbindet sofort üéØ`;
                } else if (commonHobbies.length <= 3) {
                    return `${commonHobbies.length} gemeinsame Hobbys: ${commonHobbies.join(', ')}! Perfekte Basis üé®`;
                } else {
                    return `Viele gemeinsame Hobbys: ${commonHobbies.slice(0, 3).join(', ')} und mehr! Ihr werdet viel Spa√ü haben üéâ`;
                }
            }
            
            // Standard f√ºr verschiedene Hobbys
            return 'Verschiedene Hobbys - perfekt um neue Dinge auszuprobieren! üåü';
        }

        function splitAndNormalize(text) {
            if (!text) return [];
            return text.toLowerCase()
                .split(/[,;]/)
                .map(s => s.trim())
                .filter(s => s.length > 1);
        }

        function analyzeAgePreferences(pref1, pref2) {
            // Analysiere Pr√§ferenzen, nicht tats√§chliches Alter
            const p1 = pref1.toLowerCase();
            const p2 = pref2.toLowerCase();
            
            if ((p1.includes('10') && p2.includes('10')) || 
                (p1.includes('egal') && p2.includes('egal'))) {
                return 'Ihr seid beide offen f√ºr verschiedene Altersgruppen! ü§ó';
            }
            
            if (p1.includes('egal') || p2.includes('egal')) {
                return 'Einer ist sehr flexibel beim Alter - das passt! ‚ú®';
            }
            
            return 'Eure Altersvorstellungen erg√§nzen sich gut üòä';
        }

        function analyzeLanguageCompatibilityImproved(lang1, lang2) {
            const l1 = lang1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 1);
            const l2 = lang2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 1);
            
            console.log(`üó£Ô∏è Sprachen-Analyse: "${l1}" vs "${l2}"`);
            
            // Suche nach gemeinsamen Sprachen
            const commonLanguages = l1.filter(lang => 
                l2.some(lang2 => 
                    lang.includes(lang2) || lang2.includes(lang) || 
                    (lang.includes('deutsch') && lang2.includes('deutsch'))
                )
            );
            
            if (commonLanguages.length > 0) {
                return `Gemeinsame Sprache: ${commonLanguages[0]}! Das erleichtert die Kommunikation üó£Ô∏è`;
            }
            
            // Pr√ºfe auf Lern-M√∂glichkeiten
            if (l1.some(l => l.includes('deutsch')) && l2.some(l => !l.includes('deutsch'))) {
                return 'Perfekt f√ºr Deutsch-Praxis und kulturellen Austausch! üåç';
            }
            
            if (l2.some(l => l.includes('deutsch')) && l1.some(l => !l.includes('deutsch'))) {
                return 'Tolle Gelegenheit f√ºr Sprachpraxis und neue Kulturen! üåç';
            }
            
            return 'Verschiedene Sprachen - perfekt zum Voneinander-Lernen! üåé';
        }

        function analyzePLZCompatibility(plz1, plz2) {
            const num1 = extractNumber(plz1);
            const num2 = extractNumber(plz2);
            
            if (num1 && num2) {
                if (num1 === num2) return 'Gleiche PLZ - ihr seid quasi Nachbarn! üè†';
                
                const diff = Math.abs(num1 - num2);
                if (diff < 100) return 'Sehr nah beieinander - kurze Wege! üö∂‚Äç‚ôÄÔ∏è';
                if (diff < 1000) return 'Gute Erreichbarkeit mit √ñPNV! üöã';
                if (diff < 10000) return 'Gleiche Region - das ist praktisch! üìç';
            }
            
            return 'Verschiedene Gegenden - k√∂nnt euch eure Kieze zeigen! üó∫Ô∏è';
        }

        function analyzeFriendshipValues(values1, values2) {
            const v1 = values1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const v2 = values2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            
            console.log(`üíù Freundschafts-Analyse: "${v1}" vs "${v2}"`);
            
            // Suche nach gemeinsamen Werten
            const commonValues = v1.filter(val => 
                v2.some(val2 => val.includes(val2) || val2.includes(val) || val === val2)
            );
            
            if (commonValues.length > 0) {
                const mainValue = commonValues[0];
                return `Gemeinsamer Wert: ${mainValue}! Das ist eine starke Basis üíù`;
            }
            
            // Pr√ºfe auf erg√§nzende Werte
            const complementaryPairs = [
                ['ehrlichkeit', 'vertrauen'],
                ['humor', 'spa√ü'],
                ['treue', 'loyalit√§t'],
                ['respekt', 'toleranz']
            ];
            
            for (const [val1, val2] of complementaryPairs) {
                if (v1.some(v => v.includes(val1)) && v2.some(v => v.includes(val2))) {
                    return `${val1} + ${val2} - das erg√§nzt sich perfekt! ü§ù`;
                }
            }
            
            return 'Verschiedene Werte bereichern Freundschaften! üåü';
        }

        function getDifferenceTextImproved(question, name1, name2, answer1, answer2) {
            const q = question.toLowerCase();
            
            // Spezifische Unterschieds-Texte
            if (q.includes('beruf') || q.includes('arbeit')) {
                return `${name1}: ${answer1} | ${name2}: ${answer2} - perfekt f√ºr neue Perspektiven! üíº`;
            }
            
            if (q.includes('studium') || q.includes('ausbildung')) {
                return 'Verschiedene Bildungswege - viel zu erz√§hlen! üéì';
            }
            
            if (q.includes('geboren') || q.includes('herkunft')) {
                return 'Verschiedene Hintergr√ºnde - perfekt f√ºr kulturellen Austausch! üåç';
            }
            
            // Motivierende Standard-Texte
            const encouragingTexts = [
                'Unterschiede machen Freundschaften spannend! ‚ú®',
                'Perfekt zum Voneinander-Lernen! ü§ù', 
                'Verschiedene Perspektiven bereichern! üåü',
                'Das wird sicher interessant! üí≠',
                'Gegens√§tze k√∂nnen sich perfekt erg√§nzen! üòä'
            ];
            
            const index = (question.length + answer1.length + answer2.length) % encouragingTexts.length;
            return encouragingTexts[index];
        }

        function splitAndNormalize(text) {
            return text.toLowerCase()
                .split(/[,;]/)
                .map(s => s.trim())
                .filter(s => s.length > 1)
                .map(s => s.replace(/[^a-z√§√∂√º√ü\s]/g, '').trim());
        }

        function findCommonItems(arr1, arr2) {
            return arr1.filter(item => 
                arr2.some(item2 => 
                    item === item2 || 
                    item.includes(item2) || 
                    item2.includes(item)
                )
            );
        }

        function extractNumber(text) {
            const match = text.match(/\d+/);
            return match ? parseInt(match[0]) : null;
        }

        function analyzeDistancePreferences(dist1, dist2) {
            const d1 = dist1.toLowerCase();
            const d2 = dist2.toLowerCase();
            
            if (d1 === d2) {
                return `Identische Anreise-Vorstellungen: ${dist1}! üéØ`;
            }
            
            if ((d1.includes('stunde') && d2.includes('stunde')) ||
                (d1.includes('30') && d2.includes('30'))) {
                return '√Ñhnliche Entfernungsvorstellungen - das passt! üöã';
            }
            
            return 'Unterschiedliche Anreise-Pr√§ferenzen - Kompromisse sind m√∂glich! üó∫Ô∏è';
        }

        function getExactMatchTextImproved(question, answer) {
            const q = question.toLowerCase();
            const a = answer.toLowerCase();
            
            if (q.includes('hobby') || q.includes('interesse')) {
                return `Gemeinsames Interesse: ${answer}! Das verbindet üéØ`;
            }
            if (q.includes('sprache')) {
                return `Perfekt - ihr sprecht beide: ${answer}! üó£Ô∏è`;
            }
            if (q.includes('studium') && a.includes('ja')) {
                return 'Ihr habt beide studiert - akademischer Austausch! üéì';
            }
            if (a.includes('ja') || a.includes('gerne')) {
                return `Ihr seid euch einig: ${answer}! ‚ú®`;
            }
            
            return `Identisch: ${answer} - das passt perfekt! üòä`;
        }

        function getSimilarMatchTextImproved(question, answer1, answer2, similarity) {
            const q = question.toLowerCase();
            const simPercent = Math.round(similarity * 100);
            
            if (q.includes('hobby')) {
                return `${simPercent}% √úbereinstimmung bei Hobbys - perfekte Mischung! üé®`;
            }
            if (q.includes('sprache')) {
                return '√Ñhnliche Sprachkenntnisse - k√∂nnt euch super helfen! üåç';
            }
            
            return `Das passt gut zusammen (${simPercent}% √§hnlich)! üòä`;
        }

        function debugQuestionSimilarity() {
            const allQuestions = new Set();
            profiles.forEach(profile => {
                profile.fields.forEach(field => {
                    allQuestions.add(field.question);
                });
            });
            
            const questionGroups = findSimilarQuestions(Array.from(allQuestions));
            const duplicateGroups = questionGroups.filter(group => group.length > 1);
            
            console.log('üîç === FRAGEN-√ÑHNLICHKEITS-ANALYSE ===');
            console.log(`üìä Gesamt: ${allQuestions.size} Fragen`);
            console.log(`üîÑ Gruppen mit Duplikaten: ${duplicateGroups.length}`);
            
            duplicateGroups.forEach((group, index) => {
                console.log(`\nüìù Gruppe ${index + 1}:`);
                group.forEach(q => {
                    const count = profiles.reduce((count, profile) => 
                        count + (profile.fields.some(f => f.question === q) ? 1 : 0), 0
                    );
                    console.log(`  - "${q}" (${count} Profile)`);
                });
            });
            
            showNotification(`üîç Fragen-Analyse: ${duplicateGroups.length} Duplikat-Gruppen gefunden`, 'info', 5000);
        }

        // ===============================
        // R√úCKWIRKENDE DATEN-BEREINIGUNG
        // ===============================

        function migrateExistingProfiles() {
            if (profiles.length === 0) {
                showNotification('‚ùå Keine Profile zum Migrieren vorhanden', 'warning');
                return;
            }

            if (!confirm(`üîÑ R√ºckwirkende Fragen-Bereinigung f√ºr ${profiles.length} Profile durchf√ºhren?\n\nDies wird:\n- √Ñhnliche Fragen zusammenf√ºhren\n- Duplikate bereinigen\n- Tandems aktualisieren\n\nEmpfohlen: Erstelle vorher ein Backup!`)) {
                return;
            }

            console.log('üöÄ Starte Migration der bestehenden Profile...');
            
            let totalChanges = 0;
            let profilesChanged = 0;

            // 1. Profile bereinigen
            profiles.forEach((profile, profileIndex) => {
                console.log(`üìã Migriere Profil ${profileIndex + 1}/${profiles.length}: ${profile.name}`);
                
                const originalFieldCount = profile.fields.length;
                const cleanedFields = cleanupProfileFields(profile.fields);
                
                if (cleanedFields.length !== originalFieldCount) {
                    console.log(`  ‚úÖ ${originalFieldCount} ‚Üí ${cleanedFields.length} Felder (${originalFieldCount - cleanedFields.length} Duplikate entfernt)`);
                    profile.fields = cleanedFields;
                    totalChanges += (originalFieldCount - cleanedFields.length);
                    profilesChanged++;
                } else {
                    console.log(`  ‚ÑπÔ∏è Keine √Ñnderungen n√∂tig`);
                }
            });

            // 2. Tandems aktualisieren
            let tandemsUpdated = 0;
            tandems.forEach((tandem, tandemIndex) => {
                console.log(`ü§ù Aktualisiere Tandem ${tandemIndex + 1}/${tandems.length}: ${tandem.name}`);
                
                const updatedCommonalities = updateTandemCommonalities(tandem);
                
                if (updatedCommonalities.length !== tandem.commonalities.length) {
                    tandem.commonalities = updatedCommonalities;
                    tandemsUpdated++;
                    console.log(`  ‚úÖ Gemeinsamkeiten aktualisiert`);
                }
            });

            // 3. Speichern
            saveProfiles();
            saveTandems();

            // 4. UI aktualisieren
            updateUI();
            
            // 5. Ergebnis anzeigen
            const summary = `üéâ Migration abgeschlossen!\n\nüìä Ergebnisse:\n- ${profilesChanged} von ${profiles.length} Profilen bereinigt\n- ${totalChanges} Duplikat-Felder entfernt\n- ${tandemsUpdated} Tandems aktualisiert\n\nüíæ Alle √Ñnderungen wurden gespeichert.`;
            
            console.log('‚úÖ Migration erfolgreich abgeschlossen');
            showNotification('‚úÖ R√ºckwirkende Bereinigung erfolgreich!', 'success', 5000);
            alert(summary);
        }

        function cleanupProfileFields(fields) {
            console.log(`    üîç Bereinige ${fields.length} Felder...`);
            
            // 1. Erstelle Mapping: normalisierte Frage ‚Üí beste Original-Frage + alle Antworten
            const questionGroups = new Map();
            
            fields.forEach(field => {
                const normalizedQ = normalizeQuestion(field.question);
                
                if (!questionGroups.has(normalizedQ)) {
                    questionGroups.set(normalizedQ, {
                        originalQuestions: [],
                        answers: [],
                        bestQuestion: field.question
                    });
                }
                
                const group = questionGroups.get(normalizedQ);
                group.originalQuestions.push(field.question);
                group.answers.push(field.answer);
                
                // W√§hle die beste Frage (k√ºrzeste, h√§ufigste, oder klarste)
                if (field.question.length < group.bestQuestion.length || 
                    field.question.split(' ').length < group.bestQuestion.split(' ').length) {
                    group.bestQuestion = field.question;
                }
            });

            // 2. Erstelle bereinigte Felder
            const cleanedFields = [];
            
            questionGroups.forEach((group, normalizedQ) => {
                if (group.originalQuestions.length > 1) {
                    console.log(`      üîÑ Zusammenf√ºhrung: ${group.originalQuestions.length} Variationen von "${normalizedQ}"`);
                    console.log(`        ‚Üí Beste Frage: "${group.bestQuestion}"`);
                    group.originalQuestions.forEach(q => console.log(`        - "${q}"`));
                }
                
                // W√§hle die beste Antwort (l√§ngste, vollst√§ndigste)
                const bestAnswer = group.answers.reduce((best, current) => {
                    if (!best) return current;
                    if (!current) return best;
                    
                    // L√§ngere Antwort bevorzugen, au√üer wenn sie nur Wiederholungen sind
                    const cleanCurrent = cleanProfileAnswer(current);
                    const cleanBest = cleanProfileAnswer(best);
                    
                    if (cleanCurrent.length > cleanBest.length) return current;
                    return best;
                });
                
                if (bestAnswer && bestAnswer.trim()) {
                    cleanedFields.push({
                        question: group.bestQuestion,
                        answer: bestAnswer
                    });
                }
            });

            console.log(`    ‚úÖ ${fields.length} ‚Üí ${cleanedFields.length} Felder (${fields.length - cleanedFields.length} Duplikate entfernt)`);
            return cleanedFields;
        }

        function updateTandemCommonalities(tandem) {
            console.log(`    üîç Aktualisiere Gemeinsamkeiten f√ºr "${tandem.name}"`);
            
            // Neu berechnen basierend auf den bereinigten Profildaten
            const profile1 = profiles.find(p => p.id === tandem.profile1.id);
            const profile2 = profiles.find(p => p.id === tandem.profile2.id);
            
            if (!profile1 || !profile2) {
                console.log(`    ‚ö†Ô∏è Profile nicht gefunden - √ºberspringe`);
                return tandem.commonalities;
            }
            
            // Aktualisiere Profile-Referenzen im Tandem
            tandem.profile1 = profile1;
            tandem.profile2 = profile2;
            
            // Berechne Gemeinsamkeiten neu
            const newCommonalities = findCommonalities(profile1, profile2);
            
            console.log(`    ‚úÖ ${tandem.commonalities.length} ‚Üí ${newCommonalities.length} Gemeinsamkeiten`);
            return newCommonalities;
        }

        function createDataBackup() {
            const backup = {
                profiles: JSON.parse(JSON.stringify(profiles)),
                tandems: JSON.parse(JSON.stringify(tandems)),
                selectedFields: JSON.parse(JSON.stringify(selectedFields)),
                timestamp: new Date().toISOString(),
                version: '2.0-pre-migration'
            };
            
            const filename = `SwaF_Backup_Pre_Migration_${new Date().toISOString().split('T')[0]}.json`;
            downloadFile(JSON.stringify(backup, null, 2), filename, 'application/json');
            
            showNotification('üíæ Backup erstellt!', 'success', 3000);
        }

        function analyzeCurrentData() {
            if (profiles.length === 0) {
                showNotification('‚ùå Keine Profile zum Analysieren', 'warning');
                return;
            }
            
            console.log('üîç === DATEN-ANALYSE VOR MIGRATION ===');
            
            // Sammle alle Fragen
            const allQuestions = new Set();
            let totalFields = 0;
            
            profiles.forEach(profile => {
                totalFields += profile.fields.length;
                profile.fields.forEach(field => {
                    allQuestions.add(field.question);
                });
            });
            
            // Finde Duplikate
            const questionGroups = findSimilarQuestions(Array.from(allQuestions));
            const duplicateGroups = questionGroups.filter(group => group.length > 1);
            
            let potentialSavings = 0;
            duplicateGroups.forEach(group => {
                potentialSavings += (group.length - 1);
            });
            
            const analysis = `üìä Aktuelle Daten-Analyse:

        üìã Profile: ${profiles.length}
        üìù Gesamt Felder: ${totalFields}
        ‚ùì Einzigartige Fragen: ${allQuestions.size}
        üîÑ Duplikat-Gruppen: ${duplicateGroups.length}
        üíæ Potentielle Einsparungen: ${potentialSavings} Duplikat-Felder

        üîç Gr√∂√üte Duplikat-Gruppen:`;

            console.log(analysis);
            
            // Zeige gr√∂√üte Duplikat-Gruppen
            duplicateGroups
                .sort((a, b) => b.length - a.length)
                .slice(0, 5)
                .forEach((group, index) => {
                    console.log(`\n${index + 1}. ${group.length} Variationen:`);
                    group.forEach(q => console.log(`   - "${q}"`));
                });
            
            alert(analysis + '\n\nDetails siehe Browser-Konsole.');
        }

        function testIntelligentMatching() {
            console.log('üß™ === INTELLIGENTE MATCHING TESTS ===');
            
            const testCases = [
                { q: 'Vorname', a1: 'Max', a2: 'Anna', expected: 'Sollte leer bleiben' },
                { q: 'Hobbys', a1: 'Fu√üball, Lesen', a2: 'Sport, B√ºcher', expected: 'Sollte Gemeinsamkeiten finden' },
                { q: 'ID', a1: '12345', a2: '67890', expected: 'Sollte ausgeschlossen werden' },
                { q: 'Status', a1: 'aktiv', a2: 'aktiv', expected: 'Sollte als sinnlos erkannt werden' }
            ];
            
            testCases.forEach((test, index) => {
                console.log(`\n${index + 1}. Test: "${test.q}"`);
                console.log(`   Input: "${test.a1}" vs "${test.a2}"`);
                console.log(`   Erwarte: ${test.expected}`);
                
                const excluded = shouldExcludeFromMatching(test.q);
                const meaningless = isMeaninglessComparison(test.a1, test.a2, test.q);
                const intelligentText = generateIntelligentText(test.q, test.a1, test.a2);
                
                console.log(`   ‚Üí Ausgeschlossen: ${excluded}`);
                console.log(`   ‚Üí Sinnlos: ${meaningless}`);
                console.log(`   ‚Üí Generierter Text: "${intelligentText}"`);
            });
            
            showNotification('üß™ Intelligente Matching Tests in Konsole ausgegeben', 'info', 4000);
        }

        // Globale Funktion verf√ºgbar machen
        window.testIntelligentMatching = testIntelligentMatching;

        function testNameExtraction() {
            const testNames = [
                'Aufnahmegespr√§ch Einwander*innen (Sara Pooramin)',
                'Aufnahmegespr√§ch Locals (Nekhat Hasrat-Nazimi)', 
                'Sara Mustermann',
                'Interview mit Max',
                'Gespr√§ch Teilnehmer (Anna Schmidt)'
            ];
            
            console.log('üë§ === NAMEN-EXTRAKTION TESTS ===');
            testNames.forEach(name => {
                const extracted = extractFirstName(name);
                console.log(`"${name}" ‚Üí "${extracted}"`);
            });
            
            showNotification('üë§ Namen-Tests in Konsole ausgegeben', 'info', 3000);
        }

        window.switchProfileView = switchProfileView;
        window.loadProfileMap = loadProfileMap;
        window.toggleProfileSelectionFromMap = toggleProfileSelectionFromMap;

        window.testNameExtraction = testNameExtraction;    
        
        function loadFieldsWithOrder() {
            const container = document.getElementById('field-selection');
            
            if (!profiles || profiles.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 2rem;">Bitte zuerst Profile sammeln.</p>';
                return;
            }

            const allFields = new Set();
            profiles.forEach(profile => {
                profile.fields.forEach(field => {
                    allFields.add(field.question);
                });
            });

            const excludeFields = [
                'Nachname', 'E-Mail-Adresse', 'Telefonnummer', 'Status',
                'Terminart', 'Durchgef√ºhrt von', 'Datum/Uhrzeit', 'Gruppe',
                'Standort-Newsletter', 'Vermittler*in'
            ];

            let fieldOrder = JSON.parse(localStorage.getItem('swaf_field_order') || '[]');
            const allFieldsArray = Array.from(allFields);
            
            allFieldsArray.forEach(field => {
                if (!fieldOrder.includes(field)) {
                    fieldOrder.push(field);
                }
            });
            
            fieldOrder = fieldOrder.filter(field => allFieldsArray.includes(field));
            localStorage.setItem('swaf_field_order', JSON.stringify(fieldOrder));

            container.innerHTML = fieldOrder.map((field, index) => {
                const isExcluded = excludeFields.some(ex => field.toLowerCase().includes(ex.toLowerCase()));
                const isSelected = selectedFields.includes(field);
                
                return `
                    <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: ${isSelected ? 'var(--swaf-lightest-teal)' : 'white'}; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 0.3rem;">
                        <div style="display: flex; flex-direction: column; gap: 0.2rem;">
                            <button onclick="moveFieldUp(${index})" class="btn btn-outline" style="padding: 0.2rem 0.5rem; font-size: 0.8rem;" ${index === 0 ? 'disabled' : ''}>‚ñ≤</button>
                            <button onclick="moveFieldDown(${index})" class="btn btn-outline" style="padding: 0.2rem 0.5rem; font-size: 0.8rem;" ${index === fieldOrder.length - 1 ? 'disabled' : ''}>‚ñº</button>
                        </div>
                        <label style="display: flex; align-items: center; flex: 1; cursor: pointer;">
                            <input type="checkbox" 
                                ${isSelected ? 'checked' : ''} 
                                ${isExcluded ? 'disabled' : ''}
                                onchange="toggleField('${field.replace(/'/g, "\\'")}')"
                                style="margin-right: 0.5rem;">
                            <span style="${isExcluded ? 'color: #999; text-decoration: line-through;' : ''}">${field}</span>
                        </label>
                    </div>
                `;
            }).join('');
        }

        function moveFieldUp(index) {
            let fieldOrder = JSON.parse(localStorage.getItem('swaf_field_order') || '[]');
            if (index > 0) {
                [fieldOrder[index - 1], fieldOrder[index]] = [fieldOrder[index], fieldOrder[index - 1]];
                localStorage.setItem('swaf_field_order', JSON.stringify(fieldOrder));
                loadFieldsWithOrder();
            }
        }

        function moveFieldDown(index) {
            let fieldOrder = JSON.parse(localStorage.getItem('swaf_field_order') || '[]');
            if (index < fieldOrder.length - 1) {
                [fieldOrder[index], fieldOrder[index + 1]] = [fieldOrder[index + 1], fieldOrder[index]];
                localStorage.setItem('swaf_field_order', JSON.stringify(fieldOrder));
                loadFieldsWithOrder();
            }
        }
        
    </script>

    <!-- Full-Screen Karten Modal -->
    <div id="fullscreen-map-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; z-index: 10000;">
        <div style="display: flex; flex-direction: column; height: 100%;">
            <!-- Header mit Filtern und Schlie√üen-Button -->
            <div style="background: var(--swaf-teal); color: white; padding: 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h2 style="margin: 0;">üó∫Ô∏è Full-Screen Kartenansicht</h2>
                    <button class="btn btn-outline" onclick="closeFullScreenMap()" style="background: white; color: var(--swaf-teal); font-weight: bold;">
                        ‚úï Schlie√üen
                    </button>
                </div>

                <!-- Filter -->
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <input type="text" id="fs-profile-search" placeholder="Profile durchsuchen (z.B. 'Studium', 'Fu√üball')..."
                        onkeyup="filterFullScreenMap()" style="flex: 2; min-width: 200px; padding: 0.5rem; border-radius: 4px; border: none;">

                    <select id="fs-search-scope" onchange="filterFullScreenMap()" style="flex: 1; min-width: 150px; padding: 0.5rem; border-radius: 4px; border: none;" title="Suchbereich festlegen">
                        <option value="all">üîç Alle Felder</option>
                        <option value="name">üë§ Nur Name</option>
                        <option value="specific">üìã Bestimmtes Feld...</option>
                    </select>

                    <select id="fs-filter-gender" onchange="filterFullScreenMap()" style="flex: 1; min-width: 150px; padding: 0.5rem; border-radius: 4px; border: none;">
                        <option value="">Alle Geschlechter</option>
                        <option value="weiblich">Weiblich</option>
                        <option value="m√§nnlich">M√§nnlich</option>
                        <option value="divers">Divers</option>
                        <option value="keine angabe">Keine Angabe</option>
                    </select>

                    <select id="fs-filter-gruppe" onchange="filterFullScreenMap()" style="flex: 1; min-width: 150px; padding: 0.5rem; border-radius: 4px; border: none;">
                        <option value="">Alle Gruppen</option>
                        <option value="local">Locals</option>
                        <option value="einwander">Eingewanderte</option>
                    </select>

                    <input type="number" id="fs-filter-age-min" placeholder="Alter von"
                        onchange="filterFullScreenMap()" style="flex: 1; min-width: 100px; padding: 0.5rem; border-radius: 4px; border: none;" min="0" max="120">

                    <input type="number" id="fs-filter-age-max" placeholder="Alter bis"
                        onchange="filterFullScreenMap()" style="flex: 1; min-width: 100px; padding: 0.5rem; border-radius: 4px; border: none;" min="0" max="120">

                    <button class="btn btn-outline" onclick="clearFullScreenFilters()"
                        style="white-space: nowrap; background: white; color: var(--swaf-teal); font-weight: bold;">üîÑ Filter zur√ºcksetzen</button>
                </div>

                <!-- Spezifisches Feld-Dropdown (nur sichtbar wenn "Bestimmtes Feld" ausgew√§hlt) -->
                <div id="fs-specific-field-container" style="display: none; margin-top: 0.5rem;">
                    <select id="fs-specific-field-select" onchange="filterFullScreenMap()" style="width: 100%; padding: 0.5rem; border-radius: 4px; border: none;">
                        <option value="">-- Feld ausw√§hlen --</option>
                    </select>
                </div>
            </div>

            <!-- Karte -->
            <div id="fullscreen-map-container" style="flex: 1; position: relative;">
                <!-- Die Leaflet-Karte wird hier eingef√ºgt -->
            </div>

            <!-- Footer mit Legende und Matching-Controls -->
            <div style="background: #f5f5f5; padding: 1rem; border-top: 2px solid var(--swaf-teal);">
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
                    <!-- Legende -->
                    <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <div style="width: 20px; height: 20px; background: #FFB000; border-radius: 50%; border: 2px solid white;"></div>
                            <span>Locals (verf√ºgbar)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <div style="width: 20px; height: 20px; background: #009892; border-radius: 50%; border: 2px solid white;"></div>
                            <span>Eingewanderte (verf√ºgbar)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <div style="width: 20px; height: 20px; background: #C30045; border-radius: 50%; border: 2px solid white;"></div>
                            <span>Ausgew√§hlt (f√ºr Matching)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <div style="width: 20px; height: 20px; background: #6B46C1; border-radius: 50%; border: 2px solid white;"></div>
                            <span>Gematcht (bestehende Tandems)</span>
                        </div>
                    </div>

                    <!-- Matching Controls -->
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <span id="fs-selection-status" style="font-weight: bold; color: var(--swaf-teal);">0 von 2 Profilen ausgew√§hlt</span>
                        <button id="fs-create-match-btn" class="btn btn-primary" onclick="createMatchFromFullScreen()" disabled>
                            ‚ú® Tandem erstellen
                        </button>
                        <button class="btn btn-outline" onclick="clearFullScreenSelection()">
                            üóëÔ∏è Auswahl l√∂schen
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

            <!-- Leaflet JS f√ºr Karten -->
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
                integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
                crossorigin=""></script>
        <!-- SheetJS f√ºr Excel-Export -->
        <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
</body>

</html>
