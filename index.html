<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwaF Tandem Matcher v2.0</title>
    <!-- Leaflet CSS für Karten -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <style>
        /* SwaF Farbpalette basierend auf der Styleguide */
        :root {
            --swaf-red: #C3003B;
            --swaf-teal: #009892;
            --swaf-black: #000000;
            --swaf-light-gray: #F5F5F5;
            --swaf-dark-gray: #555555;
            --swaf-lightest-red: #FFE6ED;
            --swaf-light-red: #FF99B5;
            --swaf-lightest-teal: #E6FFFD;
            --swaf-light-teal: #99FFFA;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--swaf-light-gray);
            color: var(--swaf-black);
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, var(--swaf-red), var(--swaf-teal));
            color: white;
            padding: 1rem 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .header p {
            opacity: 0.9;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .tabs {
            display: flex;
            background: white;
            border-radius: 8px 8px 0 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        .tab {
            padding: 1rem 1.5rem;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: var(--swaf-dark-gray);
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .tab:hover {
            background-color: var(--swaf-lightest-teal);
            color: var(--swaf-teal);
        }

        .tab.active {
            background-color: var(--swaf-teal);
            color: white;
            border-bottom-color: var(--swaf-red);
        }

        .tab-content {
            background: white;
            border-radius: 0 0 8px 8px;
            padding: 2rem;
            min-height: 600px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--swaf-teal);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--swaf-teal);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--swaf-red);
            color: white;
        }

        .btn-primary:hover {
            background-color: #a30030;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: var(--swaf-teal);
            color: white;
        }

        .btn-secondary:hover {
            background-color: #007a75;
            transform: translateY(-2px);
        }

        .btn-outline {
            background-color: transparent;
            color: var(--swaf-teal);
            border: 2px solid var(--swaf-teal);
        }

        .btn-outline:hover {
            background-color: var(--swaf-teal);
            color: white;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }

        .grid {
            display: grid;
            gap: 1rem;
        }

        .grid-2 {
            grid-template-columns: 1fr 1fr;
        }

        .grid-3 {
            grid-template-columns: 1fr 1fr 1fr;
        }

        .card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid var(--swaf-teal);
        }

        .card h3 {
            color: var(--swaf-red);
            margin-bottom: 1rem;
        }

        .progress {
            width: 100%;
            height: 8px;
            background-color: #ddd;
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--swaf-teal), var(--swaf-red));
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Floating Template Panel */
        .floating-templates {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 2px solid var(--swaf-teal);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 5000;
            transition: all 0.3s ease;
            display: none;
        }

        .floating-templates.visible {
            display: block;
            animation: slideInRight 0.3s ease-out;
        }

        .floating-templates.collapsed {
            width: 40px;
            height: 40px;
            padding: 0.5rem;
            overflow: hidden;
            cursor: pointer;
        }

        .floating-templates h4 {
            color: var(--swaf-teal);
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
        }

        .floating-template-btn {
            display: block;
            width: 100%;
            margin: 0.2rem 0;
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--swaf-teal);
            background: white;
            color: var(--swaf-teal);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            text-align: left;
            transition: all 0.2s ease;
        }

        .floating-template-btn:hover {
            background: var(--swaf-lightest-teal);
            transform: translateX(-2px);
        }

        /* Quick-Action Buttons für schnelleres Arbeiten */
        .quick-actions {
            position: fixed;
            bottom: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 1000;
        }

        .quick-action-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .quick-action-btn:hover {
            transform: scale(1.1);
        }

        .quick-action-btn.quick-save {
            background: var(--swaf-teal);
        }

        .quick-action-btn.quick-common {
            background: var(--swaf-red);
        }

        .quick-action-btn.quick-clear {
            background: #ff6b6b;
        }

        /* Keyboard Shortcuts Info */
        .keyboard-shortcuts {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 2000;
        }

        .keyboard-shortcuts.visible {
            opacity: 1;
        }

        /* Auto-Complete Dropdown */
        .auto-complete {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--swaf-teal);
            border-top: none;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .auto-complete-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .auto-complete-item:hover,
        .auto-complete-item.selected {
            background: var(--swaf-lightest-teal);
        }

        .auto-complete-item:last-child {
            border-bottom: none;
        }

        /* Bulk Edit Mode */
        .bulk-edit-mode .tandem-table td[contenteditable] {
            background: var(--swaf-lightest-red) !important;
            border: 2px dashed var(--swaf-red) !important;
        }

        .bulk-edit-toolbar {
            position: fixed;
            top: 100px;
            right: 20px;
            background: white;
            border: 2px solid var(--swaf-red);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 2000;
            display: none;
        }

        .bulk-edit-toolbar.visible {
            display: block;
        }

        .floating-template-btn.priority {
            background: var(--swaf-lightest-red);
            border-color: var(--swaf-red);
            color: var(--swaf-red);
            font-weight: bold;
        }

        .floating-template-btn.priority:hover {
            background: var(--swaf-red);
            color: white;
        }

        .template-category {
            border-top: 1px solid #eee;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
        }

        .template-category:first-child {
            border-top: none;
            margin-top: 0;
            padding-top: 0;
        }

        .template-category-title {
            font-size: 0.7rem;
            font-weight: bold;
            color: var(--swaf-dark-gray);
            margin-bottom: 0.3rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .floating-templates-toggle {
            position: fixed;
            right: 20px;
            top: 200px;
            width: 50px;
            height: 50px;
            background: var(--swaf-teal);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 5001;
            transition: all 0.3s ease;
        }

        .floating-templates-toggle:hover {
            background: var(--swaf-red);
            transform: scale(1.1);
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateY(-50%) translateX(20px);
            }

            to {
                opacity: 1;
                transform: translateY(-50%) translateX(0);
            }
        }

        @media (max-width: 768px) {
            .floating-templates {
                position: fixed;
                right: 10px;
                bottom: 80px;
                top: auto;
                transform: none;
                max-width: 250px;
                max-height: 250px;
            }

            .floating-templates-toggle {
                right: 10px;
                top: auto;
                bottom: 150px;
            }
        }

        .alert {
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            border-left: 4px solid;
        }

        .alert-info {
            background-color: var(--swaf-lightest-teal);
            border-color: var(--swaf-teal);
            color: var(--swaf-teal);
        }

        .alert-success {
            background-color: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .alert-warning {
            background-color: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }

        .alert-error {
            background-color: var(--swaf-lightest-red);
            border-color: var(--swaf-red);
            color: var(--swaf-red);
        }

        .profiles-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        .profile-item {
            padding: 1rem;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .profile-item:hover {
            border-color: var(--swaf-teal);
            transform: translateY(-2px);
        }

        .profile-item.selected {
            border-color: var(--swaf-red);
            background-color: var(--swaf-lightest-red);
            box-shadow: 0 4px 12px rgba(195, 0, 59, 0.3);
        }

        .matched-pair.selected {
            background-color: var(--swaf-lightest-teal);
            border-left: 4px solid var(--swaf-teal);
        }

        .matched-pairs {
            list-style: none;
            background: white;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }

        .matched-pair {
            padding: 1rem;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .matched-pair:last-child {
            border-bottom: none;
        }

        .matched-pair:hover {
            background-color: var(--swaf-lightest-teal);
        }

        .tandem-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .tandem-table th,
        .tandem-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .tandem-table th {
            background-color: var(--swaf-teal);
            color: white;
            font-weight: 600;
        }

        .tandem-table tr:hover {
            background-color: var(--swaf-lightest-teal);
        }

        .tandem-table td {
            vertical-align: top;
            max-width: 300px;
            word-wrap: break-word;
        }

        .bookmarklet-box {
            background: #f8f9fa;
            border: 2px dashed var(--swaf-teal);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            text-align: center;
        }

        .bookmarklet {
            background: var(--swaf-red);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            text-decoration: none;
            font-weight: 600;
            display: inline-block;
            margin: 0.5rem;
            user-select: all;
            cursor: pointer;
        }

        .status-bar {
            background: var(--swaf-dark-gray);
            color: white;
            padding: 0.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .template-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .hidden {
            display: none !important;
        }

        /* Rich Text Editor */
        .rich-text-editor {
            border: 2px solid #ddd;
            border-radius: 4px;
            min-height: 200px;
            padding: 1rem;
            background: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.5;
            outline: none;
        }

        .rich-text-editor:focus {
            border-color: var(--swaf-teal);
        }

        .rich-text-toolbar {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            flex-wrap: wrap;
        }

        .rich-text-btn {
            padding: 0.3rem 0.6rem;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
            min-width: 30px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .rich-text-btn:hover {
            background: var(--swaf-lightest-teal);
            border-color: var(--swaf-teal);
        }

        .rich-text-btn.active {
            background: var(--swaf-teal);
            color: white;
            border-color: var(--swaf-teal);
        }

        .email-template-section {
            background: white;
            border: 2px solid var(--swaf-teal);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .email-preview {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.5;
        }

        .email-preview h3 {
            color: var(--swaf-red);
            margin-top: 0;
        }

        .email-subject-line {
            background: var(--swaf-lightest-teal);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            border-left: 4px solid var(--swaf-teal);
        }

        .tandem-link-placeholder {
            background: var(--swaf-lightest-red);
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
            border-left: 4px solid var(--swaf-red);
            font-style: italic;
        }

        @keyframes pulse {
            0% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.05);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }

        .profile-detected {
            animation: highlight 1s ease-in-out;
        }

        @keyframes highlight {
            0% {
                background: var(--swaf-lightest-teal);
            }

            50% {
                background: var(--swaf-light-teal);
            }

            100% {
                background: var(--swaf-lightest-teal);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .grid-2 {
                grid-template-columns: 1fr;
            }

            .profiles-list {
                grid-template-columns: 1fr;
            }

            .tabs {
                flex-wrap: wrap;
            }
        }

        .contextual-category-section {
            transition: all 0.3s ease;
        }

        .contextual-category-section:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .contextual-category-section table {
            font-size: 0.9rem;
        }

        .contextual-category-section table th {
            font-weight: 600;
            text-align: center;
        }

        .contextual-category-section table td {
            vertical-align: top;
        }

        .contextual-category-section textarea {
            resize: vertical;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .contextual-category-section textarea:focus {
            outline: none;
            border-color: var(--swaf-teal);
            box-shadow: 0 0 0 2px rgba(0, 152, 146, 0.2);
        }

        .template-priority-checkbox {
            transform: scale(1.2);
            margin-bottom: 0.3rem;
        }

        .contextual-templates-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        @media (max-width: 768px) {
            .contextual-templates-grid {
                grid-template-columns: 1fr;
            }

            .contextual-category-section table {
                font-size: 0.8rem;
            }

            .contextual-category-section textarea {
                min-height: 40px;
            }
        }

        /* Logo-Stil */
        .logo {
            width: 60px;
            height: 30px;
            background: var(--swaf-red);
            color: white;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 4px;
            margin-right: 1rem;
        }

        /* Floating Action Button für Schnellzugriff */
        .fab {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 60px;
            height: 60px;
            background: var(--swaf-red);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .fab:hover {
            transform: scale(1.1);
            background: #a30030;
        }

        /* Vereinfachtes Bookmarklet-Display */
        .simple-bookmarklet {
            background: var(--swaf-red);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            display: inline-block;
            margin: 1rem;
            user-select: all;
            cursor: grab;
        }

        .simple-bookmarklet:active {
            cursor: grabbing;
        }

        /* Polite Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--swaf-teal);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Auto-Complete für intelligentes Texting */
        .smart-input {
            position: relative;
        }

        .smart-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--swaf-teal);
            border-top: none;
            max-height: 150px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .smart-suggestion {
            padding: 0.5rem;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
        }

        .smart-suggestion:hover,
        .smart-suggestion.selected {
            background: var(--swaf-lightest-teal);
        }

        .smart-suggestion:last-child {
            border-bottom: none;
        }

        .smart-suggestion .suggestion-text {
            font-weight: bold;
            color: var(--swaf-teal);
        }

        .smart-suggestion .suggestion-context {
            font-size: 0.8rem;
            color: var(--swaf-dark-gray);
            margin-top: 0.2rem;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1><span class="logo">SwaF</span>Tandem Vorschläge</h1>
        <p>Start with a Friend - Tandem-Vorschläge intelligent erstellen</p>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab(0)">1. Profile sammeln</button>
            <button class="tab" onclick="switchTab(1)">2. Tandems matchen</button>
            <button class="tab" onclick="switchTab(2)">3. Felder auswählen</button>
            <button class="tab" onclick="switchTab(3)">4. Bearbeitung</button>
            <button class="tab" onclick="switchTab(4)">5. Verwaltung</button>
        </div>

        <div class="tab-content">
            <!-- Tab 1: Profile sammeln -->
            <div class="tab-panel active" id="tab-0">
                <h2>🔄 Profile automatisch sammeln</h2>

                <div class="alert alert-info">
                    <strong>🎯 Einfachste Methode:</strong> Verwende das vereinfachte Bookmarklet für schnelles und
                    zuverlässiges Sammeln von Profildaten!
                </div>

                <!-- Zwischenablage-Einstellungen -->
                <div style="background: var(--swaf-lightest-red); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600;">
                        <input type="checkbox" id="auto-clipboard-detection" onchange="toggleAutoClipboardDetection()" checked
                            style="margin-right: 0.5rem; transform: scale(1.2);">
                        <span>🔄 Automatische Zwischenablage-Erkennung (empfohlen)</span>
                    </label>
                    <p style="margin: 0.5rem 0 0 1.7rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                        <strong>Deaktivieren bei häufigen Browser-Berechtigungsanfragen.</strong><br>
                        Danach manuell "📋 Aus Zwischenablage einfügen" verwenden.
                    </p>
                </div>

                <!-- Vereinfachte Bookmarklet-Sektion -->
                <div class="card">
                    <h3>📌 Schritt 1: Bookmarklet installieren</h3>

                    <!-- Checkbox für Bookmarklet-Status -->
                    <div
                        style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600;">
                            <input type="checkbox" id="bookmarklet-installed" onchange="toggleBookmarkletStatus()"
                                style="margin-right: 0.5rem; transform: scale(1.2);">
                            <span>✅ Bookmarklet (Lesezeichen) schon abgespeichert?</span>
                        </label>
                    </div>

                    <div id="bookmarklet-install-section">
                        <div style="text-align: center; margin: 2rem 0;">
                            <p style="margin-bottom: 1rem;">Ziehe diesen Button in deine Lesezeichen-Leiste:</p>

                            <a href="javascript:(function(){try{var d={url:location.href,name:'',fields:[],pageType:'',timestamp:Date.now()};console.log('🚀 SwaF Sammler gestartet...');if(document.querySelector('.js_question-wrapper')){d.pageType='Interview';var h=document.querySelector('h1')||document.querySelector('.breadcrumb-item.active');d.name=h?(h.textContent||'').trim():'Interview_'+Date.now();console.log('📋 Interview-Modus, Name:',d.name);document.querySelectorAll('.js_question-wrapper').forEach(function(w,idx){console.log('🔍 Verarbeite Frage',idx+1);var qEl=w.querySelector('h2 span.text-break')||w.querySelector('h2');if(!qEl){console.log('❌ Keine Frage gefunden in Wrapper',idx+1);return;}var q=qEl.textContent.trim();console.log('❓ Frage:',q);var ans=[];w.querySelectorAll('input[type=checkbox]:checked,input[type=radio]:checked').forEach(function(inp){var sp=inp.nextElementSibling;if(sp&&sp.tagName==='SPAN'){ans.push(sp.textContent.trim());}else{var parent=inp.closest('label');if(parent)ans.push(parent.textContent.trim());}});w.querySelectorAll('select').forEach(function(sel){var opt=sel.querySelector('option[selected]')||sel.querySelector('option:checked');if(opt)ans.push(opt.textContent.trim());});w.querySelectorAll('textarea').forEach(function(ta,taIdx){console.log('📝 Textarea',taIdx+1,':');console.log('  - disabled:',ta.disabled);console.log('  - position:',ta.style.position);console.log('  - opacity:',ta.style.opacity);console.log('  - value:',ta.value);console.log('  - textContent:',ta.textContent);console.log('  - innerHTML:',ta.innerHTML);if(ta.disabled||ta.style.position==='absolute'||ta.style.opacity==='0'||ta.style.top==='-10000px'){console.log('  ⏭️ Textarea ignoriert (versteckt)');return;}var content='';if(ta.textContent&&ta.textContent.trim()){content=ta.textContent.trim();console.log('  ✅ textContent verwendet:',content.substring(0,50)+'...');}else if(ta.innerHTML&&ta.innerHTML.trim()){content=ta.innerHTML.trim();console.log('  ✅ innerHTML verwendet:',content.substring(0,50)+'...');}else if(ta.value&&ta.value.trim()){content=ta.value.trim();console.log('  ✅ value verwendet:',content.substring(0,50)+'...');}if(content&&content!=='Hier kannst du etwas schreiben...'&&content.length>0){ans.push(content);console.log('  ✅ Antwort hinzugefügt:',content.substring(0,100)+'...');}else{console.log('  ❌ Kein verwertbarer Inhalt gefunden');}});w.querySelectorAll('input[type=text],input[type=email],input[type=number]').forEach(function(inp){if(inp.value&&inp.value.trim()&&inp.value.trim()!==''){ans.push(inp.value.trim());}});var answer=ans.filter(function(a){return a&&a.length>0;}).join(', ');console.log('📋 Finale Antwort:',answer);if(q&&answer){d.fields.push({question:q,answer:answer});console.log('✅ Feld hinzugefügt:',q,'=',answer.substring(0,100)+'...');}else{console.log('❌ Feld NICHT hinzugefügt - Frage:',!!q,'Antwort:',!!answer);}});}else{d.pageType='Hauptprofil';var nameEl=document.querySelector('span[name=name]')||document.querySelector('.o_field_char')||document.querySelector('h1');if(nameEl)d.name=(nameEl.textContent||nameEl.innerText||'').trim();if(!d.name)d.name='Profil_'+Date.now();document.querySelectorAll('span.o_field_widget,div.o_field_widget,a.o_field_widget').forEach(function(field){var labels=document.querySelectorAll('label.o_form_label');var matchedLabel=null;for(var i=0;i<labels.length;i++){var label=labels[i];var fieldRect=field.getBoundingClientRect();var labelRect=label.getBoundingClientRect();if(Math.abs(labelRect.top-fieldRect.top)<10&&labelRect.left<fieldRect.left){if(!matchedLabel||Math.abs(labelRect.left-fieldRect.left)<Math.abs(matchedLabel.getBoundingClientRect().left-fieldRect.left)){matchedLabel=label;}}}if(matchedLabel){var question=matchedLabel.textContent.trim().replace(':','');var answer=field.textContent.trim();if(question&&answer&&answer.length>0&&!answer.includes('o_field')&&answer!=='false'&&answer!=='true'&&question!==answer){d.fields.push({question:question,answer:answer});console.log('✅ Hauptprofil:',question,'=',answer);}}});document.querySelectorAll('.tab-pane').forEach(function(pane,tabIndex){pane.querySelectorAll('tr').forEach(function(row){var label=row.querySelector('label.o_form_label');var field=row.querySelector('span.o_field_widget,div.o_field_widget,a.o_field_widget');if(label&&field&&!field.classList.contains('o_field_empty')){var question=label.textContent.trim().replace(':','');var answer=field.textContent.trim();if(question&&answer&&answer.length>0&&!answer.includes('o_field')&&answer!=='false'&&answer!=='true'&&question!==answer){var exists=d.fields.some(function(f){return f.question===question;});if(!exists){d.fields.push({question:question,answer:answer});console.log('✅ Tab-Feld:',question,'=',answer);}}}});});}console.log('📊 SwaF Sammler ('+d.pageType+') - Gefunden:',d.name,'mit',d.fields.length,'Feldern');console.log('🔍 Alle Felder:',d.fields);var clipboardData='SWAF_PROFILE_START'+JSON.stringify(d)+'SWAF_PROFILE_END';localStorage.setItem('swaf_bookmarklet_data',JSON.stringify(d));if(navigator.clipboard&&navigator.clipboard.writeText){navigator.clipboard.writeText(clipboardData).then(function(){alert('✅ '+d.pageType+' erfasst: '+d.name+' ('+d.fields.length+' Felder)\n📋 Daten in Zwischenablage kopiert!\n\n🔄 Zur App wechseln - Daten werden automatisch erkannt!\n\nÖffne Browser-Konsole für Details.');}).catch(function(err){alert('✅ '+d.pageType+' erfasst: '+d.name+' ('+d.fields.length+' Felder)\n⚠️ Zwischenablage-Zugriff fehlgeschlagen\n\n📋 Kopiere diese Daten manuell:\n'+clipboardData);});}else{alert('✅ '+d.pageType+' erfasst: '+d.name+' ('+d.fields.length+' Felder)\n📋 Kopiere diese Daten manuell:\n'+clipboardData);}}catch(e){alert('❌ Fehler: '+e.message);console.error('❌ SwaF Sammler Fehler:',e);}})()"    class="simple-bookmarklet" draggable="true">
                                📋 SwaF Sammler
                            </a>

                            <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                                <strong>Funktioniert nicht?</strong> Rechtsklick auf den Button → "Link speichern unter"
                                → Als Lesezeichen speichern
                            </p>
                        </div>

                        <div
                            style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                            <h4>🚀 Einfacher Workflow:</h4>
                            <ol style="margin-left: 1rem; margin-top: 0.5rem;">
                                <li><strong>Einzelne Profile:</strong> Einfach das Bookmarklet klicken → zur App
                                    wechseln → automatisch erkannt</li>
                                <li><strong>Mehrere Profile:</strong> Für jedes Profil das Bookmarklet verwenden</li>
                            </ol>
                        </div>
                    </div>

                    <div style="background: #fff3cd; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <h4>💡 Automatische Erkennung:</h4>
                        <p>Die App erkennt automatisch SwaF-Profildaten in der Zwischenablage. Du kannst auch manuell
                            einfügen:</p>
                        <button class="btn btn-secondary" onclick="pasteFromClipboard()" style="margin-top: 0.5rem;">
                            📋 Aus Zwischenablage einfügen
                        </button>
                    </div>
                </div>

                <!-- Status und gesammelte Profile -->
                <div class="card">
                    <h3>📊 Gesammelte Profile</h3>

                    <div class="progress">
                        <div class="progress-bar" id="download-progress" style="width: 0%"></div>
                    </div>

                    <div id="profile-status" style="margin: 1rem 0; font-weight: 600;">
                        Bereit zum Sammeln • Aktuell: <span id="profile-count">0</span> Profile
                    </div>

                    <div id="collected-profiles-display"></div>

                    <!-- Aktionsbuttons -->
                    <div style="margin-top: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="switchTab(1)" id="continue-btn" style="display: none;">
                            ➡️ Weiter zum Matching (<span id="profile-count-btn">0</span> Profile)
                        </button>
                        <button class="btn btn-secondary" onclick="addTestProfile()">
                            🧪 Test-Profil hinzufügen
                        </button>
                        <button class="btn btn-outline" onclick="showManualInput()">
                            ✏️ Profil manuell eingeben
                        </button>
                        <button class="btn btn-outline" onclick="clearAllProfiles()">
                            🗑️ Alle Profile löschen
                        </button>
                    </div>
                </div>

                <!-- Profile-Merge Tool -->
                <div class="card">
                    <h3>🔄 Profile zusammenführen</h3>
                    <p style="margin-bottom: 1rem;">Führe zwei Profile derselben Person manuell zusammen:</p>

                    <div class="grid grid-2" style="margin-bottom: 1rem;">
                        <div class="form-group">
                            <label>Erstes Profil:</label>
                            <select id="merge-profile-1" style="width: 100%;">
                                <option value="">-- Profil auswählen --</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Zweites Profil:</label>
                            <select id="merge-profile-2" style="width: 100%;">
                                <option value="">-- Profil auswählen --</option>
                            </select>
                        </div>
                    </div>

                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="manualMergeProfiles()">🔄 Profile zusammenführen</button>
                        <button class="btn btn-outline" onclick="updateMergeProfileLists()">🔄 Listen aktualisieren</button>
                        <button class="btn btn-outline" onclick="showMergePreview()">👀 Vorschau anzeigen</button>
                    </div>
                </div>

                <!-- Debug-Sektion -->
                <div class="card" id="debug-help-section" style="display: none;">
                    <h3>🔧 Debug & Hilfe</h3>
                    <p style="margin-bottom: 1rem;">Falls etwas nicht funktioniert:</p>

                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-outline btn-small" onclick="checkClipboardForProfileData()">
                            📋 Zwischenablage prüfen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="pasteFromClipboard()">
                            📥 Manuell einfügen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testClipboardFormat()">
                            🧪 Clipboard-Format testen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="checkForBookmarkletData()">
                            🔍 Nach localStorage-Daten suchen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="showDebugInfo()">
                            📊 Debug-Info anzeigen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testLocalStorage()">
                            💾 localStorage testen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testPLZDistance()">
                            📍 PLZ-Distanz testen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testDataCleaning()">
                            🧹 Datenbereinigung testen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="showInstructions()">
                            ❓ Detaillierte Anleitung
                        </button>
                        <button class="btn btn-outline btn-small" onclick="testPLZDistanceAPI()">
                            🌐 PLZ-Distanz API testen
                        </button>
                        <button class="btn btn-primary btn-small" onclick="testAdvancedPLZFeatures()">
                            🗺️ Erweiterte PLZ-Features testen
                        </button>
                        <button class="btn btn-secondary btn-small" onclick="interactivePLZTest()">
                            📍 Interaktive PLZ-Distanz
                        </button>
                        <button class="btn btn-outline btn-small" onclick="debugRoutingCache()">
                            💾 Routing-Cache prüfen
                        </button>
                        <button class="btn btn-outline btn-small" onclick="clearRoutingCache()">
                            🗑️ Cache leeren
                        </button>
                        <button class="btn btn-outline btn-small" onclick="debugQuestionSimilarity()">🔍 Fragen-Duplikate finden</button>
                        <button class="btn btn-primary btn-small" onclick="analyzeCurrentData()">📊 Daten analysieren</button>
                        <button class="btn btn-secondary btn-small" onclick="createDataBackup()">💾 Backup erstellen</button>
                        <button class="btn btn-primary" onclick="migrateExistingProfiles()" style="background: var(--swaf-red); margin-top: 1rem;">🔄 Rückwirkende Bereinigung</button>
                        <button class="btn btn-secondary btn-small" onclick="testIntelligentMatching()">🧪 Intelligente Matching Tests</button>
                        <button class="btn btn-outline btn-small" onclick="testNameExtraction()">👤 Namen-Extraktion testen</button>
                        <button class="btn btn-outline btn-small" onclick="debugModalSystem()">🔧 Modal System testen</button>
                    </div>
                </div>

                <div class="card" id="plz-distance-section" style="display: none;">
                    <h3>📍 PLZ-Distanzberechnung</h3>
                    <p style="margin-bottom: 1rem;">Die App berechnet automatisch Entfernungen zwischen Postleitzahlen
                        und zeigt diese in den Gemeinsamkeiten an.</p>

                    <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px;">
                        <h4>🎯 Entfernungs-Kategorien:</h4>
                        <ul style="margin: 0.5rem 0 0 1rem; font-size: 0.9rem;">
                            <li><strong>Gleiche PLZ:</strong> Identische Postleitzahl</li>
                            <li><strong>Sehr nah (≤ 10 km):</strong> Fußläufig/Fahrrad erreichbar</li>
                            <li><strong>Nah (≤ 25 km):</strong> Öffentliche Verkehrsmittel</li>
                            <li><strong>Mittlere Entfernung (≤ 50 km):</strong> Regionale Verbindung</li>
                            <li><strong>Größere Entfernung (≤ 100 km):</strong> Bundesweit erreichbar</li>
                        </ul>
                        <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                            <strong>Hinweis:</strong> Entfernungen über 100 km werden nicht als Gemeinsamkeit angezeigt.
                        </p>
                    </div>
                </div>
                
                <div class="card" id="auto-cleanup-section" style="display: none;">
                    <h3>🧹 Automatische Datenbereinigung</h3>
                    <!-- Admin Toggle (Doppelklick auf Logo aktiviert versteckte Bereiche) -->
                    <script>
                        let logoClickCount = 0;
                        document.addEventListener('DOMContentLoaded', function() {
                            const logo = document.querySelector('.logo');
                            if (logo) {
                                logo.addEventListener('dblclick', function() {
                                    logoClickCount++;
                                    if (logoClickCount >= 2) {
                                        document.getElementById('debug-help-section').style.display = 'block';
                                        document.getElementById('plz-distance-section').style.display = 'block';
                                        document.getElementById('auto-cleanup-section').style.display = 'block';
                                        showNotification('🔓 Admin-Bereiche eingeblendet', 'success');
                                        logoClickCount = 0;
                                    }
                                });
                            }
                        });
                    </script>
                    <p style="margin-bottom: 1rem;">Die App bereinigt automatisch störende Formulierungen aus den
                        Profildaten.</p>

                    <div style="background: var(--swaf-lightest-red); padding: 1rem; border-radius: 4px;">
                        <h4>❌ Automatisch entfernte Formulierungen:</h4>
                        <div
                            style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin: 0.5rem 0; font-size: 0.9rem;">
                            <div>
                                <strong>Standardformulierungen:</strong>
                                <ul style="margin: 0.3rem 0 0 1rem;">
                                    <li>"-- Hier kannst du etwas auswählen --"</li>
                                    <li>"Keine Auswahl"</li>
                                    <li>"Bitte auswählen"</li>
                                </ul>
                            </div>
                            <div>
                                <strong>Sonstiges-Einträge:</strong>
                                <ul style="margin: 0.3rem 0 0 1rem;">
                                    <li>"sonstiges:," / "Anderer Grund:,"</li>
                                    <li>"anderes:,"</li>
                                    <li>"Etwas anderes (bitte genauer beschreiben)"</li>
                                </ul>
                            </div>
                        </div>
                        <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                            <strong>Ergebnis:</strong> Nur relevante, aussagekräftige Inhalte bleiben erhalten.
                        </p>
                    </div>

                    <div
                        style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin-top: 1rem;">
                        <h4>✅ Bereinigung erfolgt automatisch beim:</h4>
                        <ul style="margin: 0.5rem 0 0 1rem; font-size: 0.9rem;">
                            <li><strong>Profil-Import:</strong> Alle neuen Profile werden sofort bereinigt</li>
                            <li><strong>Daten-Kombination:</strong> Beim Zusammenführen mehrerer Profile</li>
                            <li><strong>Export:</strong> Ausgabedaten sind automatisch sauber</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Tab 2: Tandems matchen -->
            <div class="tab-panel" id="tab-1">
                <h2>🤝 Profile zu Tandems matchen</h2>

                <div class="alert alert-info">
                    <strong>Anleitung:</strong> Wähle genau 2 Profile aus (durch Anklicken) und erstelle dann ein
                    Tandem.
                    Der Auto-Match analysiert automatisch Gemeinsamkeiten.
                </div>

                <div class="grid grid-2">
                    <div class="card">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h3>Verfügbare Profile</h3>
                            <button class="btn btn-outline btn-small" onclick="loadAvailableProfiles()">🔄
                                Aktualisieren</button>
                        </div>
                        <!-- Ansichtsumschalter -->
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; border-bottom: 2px solid var(--swaf-lightest-teal); padding-bottom: 0.5rem;">
                            <button class="btn btn-outline btn-small" id="list-view-btn" onclick="switchProfileView('list')" style="flex: 1; background: var(--swaf-teal); color: white;">
                                📋 Listenansicht
                            </button>
                            <button class="btn btn-outline btn-small" id="map-view-btn" onclick="switchProfileView('map')" style="flex: 1;">
                                🗺️ Kartenansicht
                            </button>
                        </div>
                        <div class="form-group">
                            <input type="text" id="profile-search" placeholder="Profile suchen..."
                                onkeyup="filterProfiles()">
                        </div>

                        <div id="matching-status"
                            style="margin: 0.5rem 0; padding: 0.5rem; background: var(--swaf-lightest-teal); border-radius: 4px; text-align: center; font-weight: 600;">
                            0 von 2 Profilen ausgewählt
                        </div>
                
                        <!-- Listenansicht -->
                        <div class="profiles-list" id="available-profiles" style="display: block;">
                            <p style="text-align: center; padding: 2rem;">Lade Profile...</p>
                        </div>
                
                        <!-- Kartenansicht -->
                        <div id="map-view-container" style="display: none;">
                            <div id="profile-map" style="height: 500px; border-radius: 8px; margin-bottom: 1rem;"></div>
                            <div class="alert alert-info" style="font-size: 0.9rem;">
                                <strong>💡 Tipp:</strong> Klicke auf die Markierungen um Profile anzuzeigen und auszuwählen.
                            </div>
                        </div>

                        <div style="margin-top: 1rem;">
                            <button class="btn btn-secondary" onclick="matchSelectedProfiles()" id="match-btn" disabled>
                                🤝 Ausgewählte Profile matchen
                            </button>
                            <button class="btn btn-outline btn-small" onclick="suggestAutoMatches()">
                                🎯 Auto-Match vorschlagen
                            </button>
                            <button class="btn btn-outline btn-small" onclick="clearProfileSelection()">
                                🗑️ Auswahl löschen
                            </button>
                            <button class="btn btn-outline btn-small" onclick="debugMatchingState()">
                                🔍 Debug Matching
                            </button>
                            <button class="btn btn-outline btn-small" onclick="fixProfileSelection()">
                                🔧 IDs reparieren
                            </button>
                        </div>
                    </div>

                    <div class="card">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h3>Gematchte Tandems</h3>
                            <span id="tandem-count"
                                style="background: var(--swaf-red); color: white; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.9rem;">0</span>
                        </div>

                        <ul class="matched-pairs" id="matched-pairs">
                            <li
                                style="padding: 1rem; text-align: center; color: var(--swaf-dark-gray); font-style: italic;">
                                Noch keine Tandems erstellt.
                            </li>
                        </ul>

                        <div style="margin-top: 1rem;">
                            <button class="btn btn-outline" onclick="removeSelectedPair()" id="remove-pair-btn"
                                disabled>
                                🗑️ Ausgewähltes Paar entfernen
                            </button>
                            <button class="btn btn-outline" onclick="clearAllTandems()">
                                🗑️ Alle Tandems löschen
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tab 3: Felder auswählen -->
            <div class="tab-panel" id="tab-2">
                <h2>⚙️ Felder für die Ausgabe auswählen</h2>

                <div class="card">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3>Verfügbare Felder</h3>
                        <div>
                            <button class="btn btn-outline btn-small" onclick="selectAllFields(true)">Alle
                                auswählen</button>
                            <button class="btn btn-outline btn-small" onclick="selectAllFields(false)">Alle
                                abwählen</button>
                        </div>
                    </div>

                    <div id="field-selection" class="grid grid-2"></div>
                </div>

                <div class="alert alert-info">
                    <strong>💡 Wichtig:</strong> Wähle die Felder aus, die in der Tandem-Übersicht in <strong>Schritt 4</strong> erscheinen sollen.
                    Nur ausgewählte Felder werden in der Tandem-Gegenüberstellung angezeigt.
                    <br><br>
                    <strong>Tipp:</strong> Nach Änderungen hier wechsle zu Schritt 4 und lade das Tandem neu.
                </div>
            </div>
            
            <!-- Tab 4: Bearbeitung & E-Mail-Template -->
            <div class="tab-panel" id="tab-3">
                <h2>📧 E-Mail-Tandem-Vorschläge erstellen</h2>

                <!-- E-Mail Template Sektion -->
                <div class="email-template-section">
                    <h3>📝 E-Mail-Vorlage bearbeiten</h3>

                    <div class="grid grid-2" style="margin-bottom: 1.5rem;">
                        <div class="form-group">
                            <label>E-Mail Betreff:</label>
                            <input type="text" id="email-subject"
                                value="🤝 Euer Tandem-Vorschlag von Start with a Friend" style="width: 100%;">
                        </div>
                        <div class="form-group">
                            <label>Tandem-Link Platzhalter:</label>
                            <input type="text" id="tandem-link" value="[HIER TANDEM-LINK EINFÜGEN]" style="width: 100%;"
                                placeholder="z.B. https://portal.startwithafriend.de/tandem/123">
                        </div>
                    </div>

                    <div class="form-group">
                        <label>E-Mail-Einleitung (mit Formatierung):</label>
                        <div class="rich-text-toolbar">
                            <button class="rich-text-btn" onclick="formatText('bold')" title="Fett"><b>B</b></button>
                            <button class="rich-text-btn" onclick="formatText('italic')"
                                title="Kursiv"><i>I</i></button>
                            <button class="rich-text-btn" onclick="formatText('underline')"
                                title="Unterstreichen"><u>U</u></button>
                            <span style="border-left: 1px solid #ddd; margin: 0 0.5rem;"></span>
                            <button class="rich-text-btn" onclick="insertText('😊')" title="Smiley">😊</button>
                            <button class="rich-text-btn" onclick="insertText('🤝')" title="Handshake">🤝</button>
                            <button class="rich-text-btn" onclick="insertText('✨')" title="Sparkles">✨</button>
                            <span style="border-left: 1px solid #ddd; margin: 0 0.5rem;"></span>
                            <button class="rich-text-btn" onclick="insertPlaceholder('[NAME1]')"
                                title="Name Person 1">[NAME1]</button>
                            <button class="rich-text-btn" onclick="insertPlaceholder('[NAME2]')"
                                title="Name Person 2">[NAME2]</button>
                            <span style="border-left: 1px solid #ddd; margin: 0 0.5rem;"></span>
                            <button class="rich-text-btn" onclick="resetEmailTemplate()"
                                title="Zurücksetzen">🔄</button>
                        </div>
                        <div id="email-intro-editor" class="rich-text-editor" contenteditable="true">
                            Hi <strong>[NAME1]</strong> und <strong>[NAME2]</strong>,<br><br>

                            hier ist ein Tandemvorschlag für euch 😊 Lest euch das gerne einmal durch – ich finde,
                            <strong>ihr habt einige Gemeinsamkeiten und Interessen</strong>. Lest euch die Tabelle gerne
                            durch.<br><br>

                            <strong>Ihr findet:</strong> Eure Angaben, die Angaben der anderen Person, meine
                            Einschätzung.<br><br>

                            <em>Auch wenn es auf den ersten Blick nicht zu 100% passt, probiert es vielleicht aus.</em>
                            Natürlich nur, wenn ihr Lust drauf habt. Wenn nicht, ist das auch okay.<br><br>

                            Unter der Tabelle findet ihr einen Link. <strong>Bitte drückt hier drauf.</strong> Dann
                            könnt ihr sagen, ob ihr das Tandem annehmen oder ablehnen wollt 😊<br><br>

                            <strong>Wichtig:</strong> Wenn ihr das Tandem ablehnt schreibt mir bitte die Gründe
                            auf.<br><br>

                            Ich freue mich über eure Rückmeldung!<br><br>

                            <strong>Eure Gemeinsamkeiten und Profile im Überblick</strong>
                        </div>
                    </div>

                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 1rem;">
                        <button class="btn btn-secondary" onclick="saveEmailTemplate()">💾 Vorlage speichern</button>
                        <button class="btn btn-outline" onclick="loadEmailTemplate()">📥 Vorlage laden</button>
                        <button class="btn btn-outline" onclick="previewEmail()">👀 E-Mail-Vorschau</button>
                    </div>
                </div>

                <!-- Tandem Auswahl -->
                <div class="card">
                    <h3>Tandem auswählen</h3>
                    <select id="tandem-selector" onchange="loadTandemForEditing()" style="font-size: 1.1rem; padding: 0.75rem; min-height: 50px; font-weight: 600;">
                        <option value="">-- Tandem auswählen --</option>
                    </select>

                    <div class="card" style="margin-bottom: 1.5rem;">
                        <h3>📝 Textbausteine für Gemeinsamkeiten</h3>

                        <div
                            style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                            <h4>💡 Zwei Arten von Formulierungsvorschlägen:</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                                <div
                                    style="background: white; padding: 1rem; border-radius: 4px; border: 2px solid var(--swaf-teal);">
                                    <h5 style="color: var(--swaf-teal); margin-top: 0;">🎯 Fragespezifische Vorschläge
                                    </h5>
                                    <p style="font-size: 0.9rem; margin: 0.5rem 0;">Automatisch passende Vorschläge je
                                        nach Frage (Alter, Hobbys, PLZ, etc.)</p>
                                    <button class="btn btn-primary" onclick="editContextualTemplates()"
                                        style="width: 100%;">
                                        ⚙️ Fragespezifische Templates verwalten
                                    </button>
                                </div>
                                <div
                                    style="background: white; padding: 1rem; border-radius: 4px; border: 2px solid var(--swaf-red);">
                                    <h5 style="color: var(--swaf-red); margin-top: 0;">📋 Allgemeine Vorschläge</h5>
                                    <p style="font-size: 0.9rem; margin: 0.5rem 0;">Universelle Formulierungen für alle
                                        Situationen</p>
                                    <button class="btn btn-secondary" onclick="editPredefinedTemplates()"
                                        style="width: 100%;">
                                        ✏️ Allgemeine Templates bearbeiten
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div
                            style="background: var(--swaf-lightest-red); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                            <h4>🎯 Bearbeitungs-Tipps:</h4>
                            <ul style="margin: 0.5rem 0 0 1rem; font-size: 0.9rem;">
                                <li><strong>Doppelklick auf Textbausteine</strong> um sie in ausgewählte Zellen
                                    einzufügen</li>
                                <li><strong>Gemeinsamkeiten-Spalte:</strong> Hier kannst du individuelle Texte für das
                                    Matching schreiben</li>
                                <li><strong>Floating Templates:</strong> Klick in eine Gemeinsamkeiten-Zelle für
                                    passende Vorschläge</li>
                            </ul>
                        </div>

                        <div class="grid grid-2">
                            <div>
                                <h4>🔧 Neuen Textbaustein erstellen:</h4>
                                <div class="form-group">
                                    <label>Titel/Kategorie:</label>
                                    <input type="text" id="template-title" placeholder="z.B. Sport-Gemeinsamkeit">
                                </div>
                                <div class="form-group">
                                    <label>Textbaustein:</label>
                                    <textarea id="template-text" rows="3"
                                        placeholder="z.B. Ihr interessiert euch beide für Sport und Bewegung"></textarea>
                                </div>
                                <button class="btn btn-primary" onclick="saveTextTemplate()">💾 Textbaustein
                                    speichern</button>
                            </div>

                            <div>
                                <h4>📋 Gespeicherte Textbausteine:</h4>
                                <div id="saved-templates"
                                    style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem;">
                                    <!-- Wird dynamisch gefüllt -->
                                </div>
                                <div style="margin-top: 0.5rem;">
                                    <button class="btn btn-outline btn-small" onclick="loadTextTemplates()">🔄
                                        Aktualisieren</button>
                                    <button class="btn btn-outline btn-small" onclick="clearAllTemplates()">🗑️ Alle
                                        löschen</button>
                                </div>
                            </div>
                        </div>

                        <!-- NEU: Allgemeine Formulierungsvorschläge -->
                        <div style="margin-top: 2rem; padding: 1.5rem; border: 2px solid var(--swaf-red); border-radius: 8px; background: var(--swaf-lightest-red);">
                            <h4 style="color: var(--swaf-red); margin-top: 0;">📋 Allgemeine Formulierungsvorschläge</h4>
                            <p style="margin-bottom: 1rem; font-size: 0.9rem;">Diese Vorschläge stehen in allen Tandem-Bearbeitungen zur Verfügung:</p>
                            
                            <div id="predefined-templates">
                                <!-- Wird dynamisch gefüllt -->
                            </div>
                        </div>
                    </div>

                    <div id="tandem-editor" class="hidden" style="margin-top: 1rem;">
                        <div
                            style="background: var(--swaf-lightest-red); padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">
                            <h4>🎯 Bearbeitungs-Tipps:</h4>
                            <ul style="margin: 0.5rem 0 0 1rem; font-size: 0.9rem;">
                                <li><strong>Doppelklick auf Textbausteine</strong> um sie in ausgewählte Zellen
                                    einzufügen</li>
                                <li><strong>Gemeinsamkeiten-Spalte:</strong> Hier kannst du individuelle Texte für das
                                    Matching schreiben</li>
                                <li><strong>Floating Templates:</strong> Klick in eine Gemeinsamkeiten-Zelle für
                                    passende Vorschläge</li>
                            </ul>
                        </div>

                        <table class="tandem-table" id="tandem-table">
                            <thead>
                                <tr>
                                    <th>Frage</th>
                                    <th>Antwort Person 1</th>
                                    <th>Antwort Person 2</th>
                                    <th>Gemeinsamkeiten</th>
                                    <th>Aktionen</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>

                        <div style="margin-top: 1rem;">
                            <button class="btn btn-secondary" onclick="saveTandem()">💾 Tandem speichern</button>
                            <button class="btn btn-primary" onclick="generateCompleteEmail()">📧 Komplette E-Mail
                                erstellen</button>
                            <button class="btn btn-outline" onclick="copyTandemToClipboard()">📋 Nur Tabelle
                                kopieren</button>
                            <button class="btn btn-outline" onclick="recomputeCommonalities()">🔄 Gemeinsamkeiten neu
                                berechnen</button>
                            <button class="btn btn-secondary" onclick="updatePLZDistancesOnly()">🗺️ Distanz berechnen</button>
                            <button class="btn btn-secondary" onclick="generateSmartTextsLocally()" title="Generiert intelligente Texte basierend auf den Antworten">🧠 Intelligente Texte</button>
                            <button class="btn btn-primary" onclick="testAdvancedPLZFeatures()" title="Teste erweiterte PLZ-Funktionen mit echten Routen">🗺️ PLZ-Features testen</button>                                
                        </div>
                    </div>
                </div>

                <!-- E-Mail Vorschau -->
                <div id="email-preview-section" class="email-template-section hidden">
                    <h3>📧 E-Mail-Vorschau</h3>
                    <div id="email-preview-content" class="email-preview">
                        <!-- Wird dynamisch gefüllt -->
                    </div>
                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                        <button class="btn btn-primary" onclick="copyCompleteEmailToClipboard()">📋 Komplette E-Mail
                            kopieren</button>
                        <button class="btn btn-secondary" onclick="downloadEmailAsHTML()">📥 Als HTML-Datei
                            speichern</button>
                        <button class="btn btn-outline" onclick="hideEmailPreview()">❌ Vorschau schließen</button>
                    </div>
                </div>
            </div>

            <!-- Tab 5: Verwaltung -->
            <div class="tab-panel" id="tab-4">
                <h2>🗂️ Daten und Vorschläge verwalten</h2>

                <div class="grid grid-2">
                    <div class="card">
                        <h3>Gespeicherte Tandems</h3>
                        <div id="saved-tandems-list" style="max-height: 300px; overflow-y: auto;"></div>
                        <div style="margin-top: 1rem;">
                            <button class="btn btn-outline" onclick="loadSavedTandems()">🔄 Tandems laden</button>
                            <button class="btn btn-outline" onclick="exportAllTandems()">📤 Alle exportieren</button>
                        </div>
                    </div>

                    <div class="card">
                        <h3>Datenverwaltung</h3>
                        <div class="alert alert-warning">
                            <strong>Achtung:</strong> Diese Aktionen können nicht rückgängig gemacht werden!
                        </div>

                        <div style="margin: 1rem 0;">
                            <button class="btn btn-secondary" onclick="exportAppData()">💾 Daten sichern</button>
                            <button class="btn btn-outline" onclick="importAppData()">📥 Daten wiederherstellen</button>
                        </div>

                        <div style="margin: 1rem 0;">
                            <button class="btn btn-outline" onclick="clearProfiles()">🗑️ Profile löschen</button>
                            <button class="btn btn-outline" onclick="clearTandems()">🗑️ Tandems löschen</button>
                        </div>

                        <div style="margin-top: 2rem;">
                            <button class="btn btn-primary" onclick="resetAllData()"
                                style="background-color: var(--swaf-red);">🔄 Alle Daten zurücksetzen</button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>📊 Statistiken</h3>
                    <div class="grid grid-3">
                        <div style="text-align: center;">
                            <h4 id="stats-profiles">0</h4>
                            <p>Gesammelte Profile</p>
                        </div>
                        <div style="text-align: center;">
                            <h4 id="stats-tandems">0</h4>
                            <p>Erstellte Tandems</p>
                        </div>
                        <div style="text-align: center;">
                            <h4 id="stats-fields">0</h4>
                            <p>Durchschn. Felder/Profil</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Action Button für Schnellzugriff -->
    <button class="fab" onclick="quickSave()" title="Schnell speichern">💾</button>

    <!-- Status Bar -->
    <div class="status-bar">
        <div id="status-text">Bereit</div>
        <div>SwaF Tandem Matcher v2.0 - Repariert</div>
    </div>

    <!-- Floating Templates Panel -->
    <div id="floating-templates" class="floating-templates">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <h4 id="floating-templates-title">📝 Vorschläge</h4>
            <button onclick="toggleFloatingTemplates()"
                style="background: none; border: none; font-size: 1.2rem; cursor: pointer; color: var(--swaf-teal);">✕</button>
        </div>
        <div id="floating-templates-content">
            <!-- Wird dynamisch gefüllt -->
        </div>
    </div>

    <button id="floating-templates-toggle" class="floating-templates-toggle" onclick="toggleFloatingTemplates()"
        title="Formulierungsvorschläge">
        📝
    </button>

    <!-- Hidden file inputs -->
    <input type="file" id="import-data-input" accept=".json" style="display: none;" onchange="handleDataImport(event)">

    <!-- Quick Actions für schnelleres Arbeiten -->
    <div class="quick-actions" id="quick-actions" style="display: none;">
        <button class="quick-action-btn quick-save" onclick="quickSave()" title="Strg+S: Schnell speichern">💾</button>
        <button class="quick-action-btn quick-common" onclick="fillCommonPhrases()" title="Strg+F: Häufige Phrasen einfügen">⚡</button>
        <button class="quick-action-btn quick-clear" onclick="clearAllCommonalities()" title="Strg+L: Alle Gemeinsamkeiten löschen">🧹</button>
    </div>

    <!-- Keyboard Shortcuts Info -->
    <div class="keyboard-shortcuts" id="keyboard-shortcuts">
        <strong>Shortcuts:</strong> Strg+S=Speichern | Strg+F=Schnell-Phrasen | Strg+N=Navigation (PLZ) | Strg+L=Löschen | Strg+B=Bulk-Edit | Esc=Schließen
    </div>

    <!-- Bulk Edit Toolbar -->
    <div class="bulk-edit-toolbar" id="bulk-edit-toolbar">
        <h4 style="margin-top: 0; color: var(--swaf-red);">🚀 Bulk-Edit Modus</h4>
        <div style="margin-bottom: 1rem;">
            <label>Schnell-Text für alle leeren Zellen:</label>
            <select id="bulk-template-select" style="width: 100%; margin-top: 0.5rem;">
                <option value="">-- Template auswählen --</option>
                <option value="Passt gut zusammen! :)">Passt gut zusammen! :)</option>
                <option value="Könnt ihr euch drüber austauschen">Könnt ihr euch drüber austauschen</option>
                <option value="Unterschiedlich - aber spannend!">Unterschiedlich - aber spannend!</option>
                <option value="Na, das wird sicher lustig! :D">Na, das wird sicher lustig! :D</option>
            </select>
        </div>
        <div style="display: flex; gap: 0.5rem;">
            <button class="btn btn-primary" onclick="applyBulkTemplate()">📝 Text anwenden</button>
            <button class="btn btn-outline" onclick="exitBulkEditMode()">❌ Beenden</button>
        </div>
    </div>

    <script>
        // ===============================
        // GLOBALE VARIABLEN
        // ===============================
        let profiles = JSON.parse(localStorage.getItem('swaf_profiles') || '[]');
        let tandems = JSON.parse(localStorage.getItem('swaf_tandems') || '[]');
        let selectedProfiles = [];
        let currentTandem = null;
        let selectedFields = JSON.parse(localStorage.getItem('swaf_selected_fields') || '[]');
        let textTemplates = JSON.parse(localStorage.getItem('swaf_text_templates') || '[]');
        let selectedTableCell = null;
        let floatingTemplatesVisible = false;
        let currentContextQuestion = '';
        let activeTemplateCell = null;
        let selectedTandemPairId = null;

        // ===============================
        // GLOBALE HILFSFUNKTIONEN FÜR INTELLIGENTE ANALYSE
        // ===============================

        function shouldExcludeFromMatching(question) {
            const excludeFromMatching = [
                // Namen und IDs
                'vorname', 'nachname', 'name', 'vollständiger name',
                'e-mail-adresse', 'e-mail', 'email', 'telefonnummer', 'telefon',
                'geschlecht', 'gender',
                
                // Administrative Felder
                'id', 'user-id', 'teilnehmer-id', 'profil-id',
                'gruppe', 'vermittler', 'vermittler*in', 'durchgeführt von',
                'datum/uhrzeit', 'datum', 'uhrzeit', 'termin', 'terminart',
                'status', 'bearbeitungsstatus', 'anmeldestatus',
                
                // System-/Meta-Felder
                'standort-newsletter', 'newsletter', 'dsgvo', 'einverständnis',
                'notizen', 'interne notizen', 'bemerkungen admin',
                'url', 'link', 'portal-link',
                
                // Bewertungs-/Einschätzungsfelder (subjektiv)
                'wie wirkt die person auf dich', 'eindruck', 'bewertung',
                'wie schätzt du ein', 'einschätzung', 'beurteilung',
                
                // Prozess-/Workflow-Felder  
                'sind weitere schritte nötig', 'nächste schritte', 'follow-up',
                'infoabend', 'aufnahmegespräch datum', 'gespräch datum'
            ];
            
            const normalized = question.toLowerCase().trim();
            
            return excludeFromMatching.some(excluded => {
                return normalized.includes(excluded.toLowerCase()) || 
                    excluded.toLowerCase().includes(normalized);
            });
        }

        // Cache für PLZ-Koordinaten
        let plzCache = JSON.parse(localStorage.getItem('swaf_plz_cache') || '{}');
        
        // Rate Limiting für API-Calls
        let lastApiCall = 0;
        const API_DELAY = 1000;

        // Email Template System
        let emailTemplate = {
            subject: '🤝 Euer Tandem-Vorschlag von Start with a Friend',
            intro: '', 
            link: '[HIER TANDEM-LINK EINFÜGEN]'
        };

        // Vordefinierte Textbausteine
        const predefinedTemplates = [
            // Sport & Bewegung
            { title: 'Sport allgemein', text: 'Ihr habt beide Interesse an Sport und Bewegung' },
            { title: 'Fußball', text: 'Ihr interessiert euch beide für Fußball' },
            { title: 'Fitnessstudio', text: 'Ihr geht beide gerne ins Fitnessstudio' },
            { title: 'Wandern', text: 'Ihr wandert beide gerne und mögt die Natur' },
            { title: 'Laufen', text: 'Ihr lauft beide gerne und haltet euch fit' },

            // Kultur & Freizeit
            { title: 'Kultur allgemein', text: 'Ihr interessiert euch beide für kulturelle Veranstaltungen' },
            { title: 'Kino/Filme', text: 'Ihr schaut beide gerne Filme und geht ins Kino' },
            { title: 'Theater/Museum', text: 'Ihr mögt beide Theateraufführungen und Museumsbesuche' },
            { title: 'Konzerte', text: 'Ihr geht beide gerne zu Konzerten und Livemusik' },
            { title: 'Festivals', text: 'Ihr mögt beide Festivals und Veranstaltungen' },

            // Musik & Kunst  
            { title: 'Musik allgemein', text: 'Ihr habt beide eine Leidenschaft für Musik' },
            { title: 'Musikinstrument', text: 'Ihr spielt beide ein Musikinstrument' },
            { title: 'Tanzen', text: 'Ihr tanzt beide gerne' },
            { title: 'Singen', text: 'Ihr singt beide gerne' },

            // Essen & Kochen
            { title: 'Kochen allgemein', text: 'Ihr kocht beide gerne und probiert neue Rezepte aus' },
            { title: 'Restaurants', text: 'Ihr geht beide gerne in Restaurants und probiert neues Essen' },
            { title: 'Backen', text: 'Ihr backt beide gerne' },
            { title: 'Vegetarisch/Vegan', text: 'Ihr ernährt euch beide vegetarisch/vegan' },

            // Sprachen & Kommunikation
            { title: 'Sprachen lernen', text: 'Ihr lernt beide gerne neue Sprachen' },
            { title: 'Deutsch üben', text: 'Ihr möchtet beide euer Deutsch verbessern' },
            { title: 'Englisch sprechen', text: 'Ihr sprecht beide gerne Englisch' },
            { title: 'Mehrsprachig', text: 'Ihr seid beide mehrsprachig und sprachbegeistert' },

            // Soziales & Persönlichkeit
            { title: 'Freunde treffen', text: 'Ihr trefft beide gerne Freunde und seid gesellig' },
            { title: 'Neue Leute kennenlernen', text: 'Ihr lernt beide gerne neue Menschen kennen' },
            { title: 'Hilfsbereit', text: 'Ihr helft beide gerne anderen Menschen' },
            { title: 'Aufgeschlossen', text: 'Ihr seid beide aufgeschlossen und neugierig' },

            // Alter & Lebenssituation
            { title: 'Ähnliches Alter', text: 'Ihr seid etwa gleich alt' },
            { title: 'Junge Erwachsene', text: 'Ihr seid beide junge Erwachsene' },
            { title: 'Studium/Ausbildung', text: 'Ihr studiert oder macht beide eine Ausbildung' },
            { title: 'Berufstätig', text: 'Ihr arbeitet beide und seid berufstätig' },
            { title: 'Hochschulerfahrung', text: 'Ihr habt beide Hochschulerfahrung' },

            // Wohnen & Region
            { title: 'Gleiche PLZ', text: 'Ihr wohnt in derselben PLZ' },
            { title: 'Gleicher Bezirk', text: 'Ihr wohnt im gleichen Bezirk' },
            { title: 'Gleiche Stadt', text: 'Ihr wohnt in derselben Stadt' },
            { title: 'Nah beieinander', text: 'Ihr wohnt nah beieinander' },
            { title: 'Gut erreichbar', text: 'Ihr könnt euch gut mit öffentlichen Verkehrsmitteln erreichen' },

            // Interessen & Hobbys
            { title: 'Lesen', text: 'Ihr lest beide gerne Bücher' },
            { title: 'Reisen', text: 'Ihr reist beide gerne und entdeckt neue Orte' },
            { title: 'Fotografie', text: 'Ihr fotografiert beide gerne' },
            { title: 'Gaming', text: 'Ihr spielt beide gerne Computerspiele' },
            { title: 'Handwerk/DIY', text: 'Ihr bastelt und werkt beide gerne' },
            { title: 'Gärtnern', text: 'Ihr mögt beide Pflanzen und Gärtnern' },

            // Mobilität & Verkehr
            { title: 'Fahrrad fahren', text: 'Ihr fahrt beide gerne Fahrrad' },
            { title: 'Öffentliche Verkehrsmittel', text: 'Ihr nutzt beide gerne öffentliche Verkehrsmittel' },
            { title: 'Zu Fuß gehen', text: 'Ihr geht beide gerne zu Fuß und seid gut zu Fuß erreichbar' },

            // Zeitplanung
            { title: 'Wochenende', text: 'Ihr habt beide am Wochenende Zeit' },
            { title: 'Abends', text: 'Ihr könnt euch beide abends treffen' },
            { title: 'Flexibel', text: 'Ihr seid beide zeitlich flexibel' },

            // Unterstützend/Positiv
            { title: 'Ergänzende Unterschiede', text: 'Eure unterschiedlichen Interessen können euch gegenseitig bereichern' },
            { title: 'Voneinander lernen', text: 'Ihr könnt viel voneinander lernen' },
            { title: 'Neue Erfahrungen', text: 'Ihr könnt zusammen neue Erfahrungen machen' },
            { title: 'Gegenseitige Unterstützung', text: 'Ihr könnt euch gegenseitig unterstützen und motivieren' }
        ];

        // Kontextspezifische Template-Kategorien
        let contextualTemplates = {
            'alter': [
                { text: 'Ihr seid etwa gleich alt', priority: true },
                { text: 'Ihr seid beide junge Erwachsene', priority: false },
                { text: 'Generationsunterschied kann bereichernd sein', priority: false }
            ],
            'hobby': [
                { text: 'Ihr habt ähnliche Hobbys', priority: true },
                { text: 'Ihr interessiert euch beide für Sport', priority: true },
                { text: 'Ihr könnt euch gegenseitig neue Hobbys zeigen', priority: false }
            ],
            'sprache': [
                { text: 'Ihr sprecht beide mehrere Sprachen', priority: true },
                { text: 'Ihr könnt euch beim Deutschlernen helfen', priority: true },
                { text: 'Ihr habt eine gemeinsame Sprache', priority: false }
            ],
            'postleitzahl': [
                { text: 'Ihr wohnt nah beieinander', priority: true },
                { text: 'Ihr könnt euch gut erreichen', priority: true },
                { text: 'Kurze Wege für Treffen', priority: false }
            ],
            'wohnort': [
                { text: 'Ihr wohnt in der gleichen Gegend', priority: true },
                { text: 'Ihr kennt die gleichen Orte', priority: false }
            ],
            'beruf': [
                { text: 'Ihr arbeitet in ähnlichen Bereichen', priority: true },
                { text: 'Ihr könnt euch beruflich austauschen', priority: false }
            ],
            'studium': [
                { text: 'Ihr habt beide studiert', priority: true },
                { text: 'Ihr habt Hochschulerfahrung', priority: false }
            ],
            'zeit': [
                { text: 'Ihr habt zur gleichen Zeit frei', priority: true },
                { text: 'Eure Zeitpläne passen gut zusammen', priority: false }
            ],
            'verkehr': [
                { text: 'Ihr nutzt die gleichen Verkehrsmittel', priority: true },
                { text: 'Ihr kommt gut zueinander', priority: false }
            ]
        };

        // ===============================
        // INITIALISIERUNG
        // ===============================
        document.addEventListener('DOMContentLoaded', function () {
            console.log('🚀 SwaF Tandem Matcher wird initialisiert...');
            
            // Initialisiere UI
            updateUI();
            
            // Starte Background-Services
            startDataChecker();
            setupClipboardDetection();
            
            // Update Status
            updateStatus('SwaF Tandem Matcher bereit');
            showNotification('✅ Anwendung geladen! Beginne mit dem Sammeln von Profilen.', 'success', 3000);

            // Bookmarklet-Status wiederherstellen
            const bookmarkletInstalled = localStorage.getItem('swaf_bookmarklet_installed') === 'true';
            if (bookmarkletInstalled) {
                document.getElementById('bookmarklet-installed').checked = true;
                document.getElementById('bookmarklet-install-section').style.display = 'none';
            }

            // Auto-Clipboard-Detection Status wiederherstellen
            const autoDetection = localStorage.getItem('swaf_auto_clipboard_detection') !== 'false'; // Default: true
            const autoClipboardCheckbox = document.getElementById('auto-clipboard-detection');
            if (autoClipboardCheckbox) {
                autoClipboardCheckbox.checked = autoDetection;
            }

            // Templates initialisieren
            initializeTextTemplates();
            initializeFloatingTemplates();
            loadContextualTemplatesFromStorage();
            
            // Email-Template laden
            loadEmailTemplate();
            
            // Rich-Text-Editor Events
            const editor = document.getElementById('email-intro-editor');
            if (editor) {
                editor.addEventListener('keyup', updateToolbarState);
                editor.addEventListener('mouseup', updateToolbarState);
            }
        });

        // ===============================
        // TAB-FUNKTIONEN
        // ===============================
        function switchTab(tabIndex) {
            console.log(`🔄 Wechsle zu Tab ${tabIndex}`);

            // Entferne active Klassen
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

            // Füge active Klassen hinzu
            document.querySelectorAll('.tab')[tabIndex].classList.add('active');
            document.getElementById(`tab-${tabIndex}`).classList.add('active');

            // Tab-spezifische Aktionen mit Verzögerung
            setTimeout(() => {
                switch (tabIndex) {
                    case 0:
                        updateCollectedProfiles();
                        updateMergeProfileLists();
                        break;
                    case 1:
                        console.log('🔄 Initialisiere Matching-Tab...');
                        loadAvailableProfiles();
                        updateMatchedPairs();
                        updateMatchingStatus();
                        break;
                    case 2:
                        loadFieldSelection();
                        break;
                    case 3:
                        loadTandemSelector();
                        updateExportPreview();
                        initializeTextTemplates();
                        // NEU: Explizit allgemeine Templates laden
                        setTimeout(() => {
                            loadPredefinedTemplates();
                        }, 300);
                        break;
                    case 4:
                        loadSavedTandems();
                        updateStatistics();
                        break;
                    case 'i': // Strg+I für Intelligente Texte
                        e.preventDefault();
                        generateSmartTextsLocally();
                        showShortcutFeedback('🧠 Intelligente Texte generiert!');
                        break;    
                }
            }, 100);
        }

        // ===============================
        // ZWISCHENABLAGE-ERKENNUNG
        // ===============================
        function setupClipboardDetection() {
            console.log('📋 Richte Zwischenablage-Erkennung ein...');

            // Überwache Paste-Events (diese sind immer erlaubt)
            document.addEventListener('paste', function (e) {
                console.log('📋 Paste-Event erkannt');
                handlePasteEvent(e);
            });

            // Überwache Fokus-Events nur wenn automatische Erkennung aktiviert ist
            window.addEventListener('focus', function () {
                const autoDetection = localStorage.getItem('swaf_auto_clipboard_detection') !== 'false';
                if (autoDetection) {
                    console.log('🔍 Fenster wieder im Fokus - prüfe Zwischenablage...');
                    // Weniger aufdringlich - nur einmal und mit längerer Verzögerung
                    setTimeout(() => {
                        checkClipboardForProfileDataSilently();
                    }, 1000);
                }
            });
        }

        function handlePasteEvent(e) {
            try {
                const pastedText = (e.clipboardData || window.clipboardData).getData('text');
                console.log('📋 Eingefügter Text:', pastedText.substring(0, 100) + '...');

                if (pastedText.includes('SWAF_PROFILE_START') && pastedText.includes('SWAF_PROFILE_END')) {
                    e.preventDefault();
                    console.log('✅ SwaF-Profildaten erkannt!');
                    processClipboardProfileData(pastedText);
                }
            } catch (error) {
                console.error('❌ Fehler beim Verarbeiten des Paste-Events:', error);
            }
        }

        function checkClipboardForProfileDataSilently() {
            try {
                navigator.clipboard.readText().then(function (text) {
                    if (text && text.includes('SWAF_PROFILE_START') && text.includes('SWAF_PROFILE_END')) {
                        console.log('📋 SwaF-Profildaten in Zwischenablage gefunden!');
                        processClipboardProfileData(text);
                        // Leere die Zwischenablage nach Verarbeitung
                        navigator.clipboard.writeText('').catch(() => { });
                    }
                }).catch(function (error) {
                    // Stumm ignorieren - keine Benutzerbenachrichtigung
                    console.log('ℹ️ Zwischenablage-Zugriff nicht möglich');
                });
            } catch (error) {
                // Stumm ignorieren
                console.log('ℹ️ Clipboard API nicht verfügbar');
            }
        }

        function checkClipboardForProfileData() {
            try {
                navigator.clipboard.readText().then(function (text) {
                    if (text && text.includes('SWAF_PROFILE_START') && text.includes('SWAF_PROFILE_END')) {
                        console.log('📋 SwaF-Profildaten in Zwischenablage gefunden!');
                        processClipboardProfileData(text);
                        // Leere die Zwischenablage nach Verarbeitung
                        navigator.clipboard.writeText('').catch(() => { });
                    }
                }).catch(function (error) {
                    console.log('ℹ️ Zwischenablage-Zugriff nicht möglich (normal in manchen Browsern)');
                });
            } catch (error) {
                console.log('ℹ️ Clipboard API nicht verfügbar');
            }
        }


        function processClipboardProfileData(text) {
            try {
                console.log('🔍 Verarbeite Zwischenablage-Daten...');
                console.log('📄 Rohdaten (erste 200 Zeichen):', text.substring(0, 200));

                const startMarker = 'SWAF_PROFILE_START';
                const endMarker = 'SWAF_PROFILE_END';

                const startIndex = text.indexOf(startMarker);
                const endIndex = text.indexOf(endMarker);

                console.log('📍 Start-Position:', startIndex, 'End-Position:', endIndex);

                if (startIndex === -1) {
                    throw new Error('Start-Marker "SWAF_PROFILE_START" nicht gefunden');
                }

                if (endIndex === -1) {
                    throw new Error('End-Marker "SWAF_PROFILE_END" nicht gefunden');
                }

                if (endIndex <= startIndex) {
                    throw new Error('End-Marker muss nach Start-Marker stehen');
                }

                // Extrahiere JSON-Daten zwischen den Markern
                const jsonStart = startIndex + startMarker.length;
                const jsonData = text.substring(jsonStart, endIndex).trim();

                console.log('📋 Extrahierte JSON-Daten:', jsonData.substring(0, 200) + '...');
                console.log('📏 JSON-Länge:', jsonData.length);

                if (!jsonData) {
                    throw new Error('Keine JSON-Daten zwischen den Markern gefunden');
                }

                // Versuche JSON zu parsen
                let profileData;
                try {
                    profileData = JSON.parse(jsonData);
                } catch (parseError) {
                    console.error('❌ JSON-Parse-Fehler:', parseError);
                    console.log('🔍 Problematische JSON-Daten:', jsonData);

                    // Versuche häufige Probleme zu reparieren
                    let cleanedJson = jsonData
                        .replace(/[\r\n\t]/g, '') // Entferne Zeilenumbrüche und Tabs
                        .replace(/\\"/g, '"')      // Repariere escaped quotes
                        .trim();

                    console.log('🔧 Bereinigte JSON-Daten:', cleanedJson.substring(0, 200) + '...');

                    try {
                        profileData = JSON.parse(cleanedJson);
                        console.log('✅ JSON erfolgreich nach Bereinigung geparst');
                    } catch (secondParseError) {
                        console.error('❌ Auch nach Bereinigung Parse-Fehler:', secondParseError);
                        throw new Error('JSON-Daten sind beschädigt: ' + parseError.message);
                    }
                }

                // Validiere die Profildaten
                if (!profileData || typeof profileData !== 'object') {
                    throw new Error('Profildaten sind kein gültiges Objekt');
                }

                if (!profileData.name && !profileData.url) {
                    throw new Error('Profildaten enthalten weder Name noch URL');
                }

                if (!Array.isArray(profileData.fields)) {
                    console.log('⚠️ Felder sind kein Array, korrigiere...');
                    profileData.fields = [];
                }

                console.log('📥 Profildaten erfolgreich verarbeitet:', profileData);
                console.log('👤 Name:', profileData.name);
                console.log('📊 Anzahl Felder:', profileData.fields.length);

                receiveProfileData(profileData);
                showNotification('🎉 Profil automatisch aus Zwischenablage importiert!', 'success', 5000);

                // Leere die Zwischenablage nach erfolgreicher Verarbeitung
                try {
                    navigator.clipboard.writeText('').catch(() => { });
                } catch (e) {
                    console.log('ℹ️ Zwischenablage konnte nicht geleert werden (normal)');
                }

            } catch (error) {
                console.error('❌ Fehler beim Verarbeiten der Zwischenablage-Daten:', error);
                console.log('📄 Vollständiger Text:', text);

                showNotification('❌ Fehler beim Verarbeiten der Profildaten: ' + error.message, 'error', 8000);
                showDebugClipboardData(text, error.message);
            }
        }

        // ===============================
        // PROFIL-SAMMLUNG
        // ===============================
        function startDataChecker() {
            console.log('🔍 Starte Daten-Checker...');

            // Prüfe localStorage für Batch-Daten (weniger häufig)
            setInterval(() => {
                try {
                    // Prüfe localStorage für Fallback-Unterstützung
                    const data = localStorage.getItem('swaf_bookmarklet_data');
                    if (data) {
                        console.log('📥 Fallback: Bookmarklet-Daten in localStorage gefunden');
                        try {
                            const profileData = JSON.parse(data);
                            console.log('📊 localStorage Profil:', profileData.name, 'mit', profileData.fields.length, 'Feldern');
                            receiveProfileData(profileData);
                            localStorage.removeItem('swaf_bookmarklet_data');
                            showNotification('📥 Profil über localStorage empfangen: ' + profileData.name, 'success');
                        } catch (error) {
                            console.error('❌ Fehler beim Parsen der localStorage-Daten:', error);
                            localStorage.removeItem('swaf_bookmarklet_data');
                        }
                    }
                } catch (e) {
                    // Ignoriere Fehler
                }
            }, 3000); // Reduziert von 1000ms auf 3000ms
        }

        function receiveProfileData(data) {
            console.log('📥 Empfange Profildaten:', data);

            if (!data || !data.name) {
                console.error('❌ Ungültige Profildaten');
                showNotification('❌ Ungültige Profildaten empfangen', 'error');
                return;
            }

            // Erweiterte Information über Seitentyp
            const pageType = data.pageType || 'Unbekannt';
            console.log('📄 Seitentyp:', pageType);

            // Definiere erlaubte Fragen (erweiterte Liste)
            const validInterviewQuestions = [
                // Ursprüngliche Fragen
                'Welche Sprachen sprichst du?', 'Warum möchtest du bei SwaF mitmachen?',
                'Woher kennst du SwaF?', 'Was machst du gerade im Leben?', 'Branche',
                'Hast du schonmal ein Studium angefangen?', 'Welches Abschluss-Zeugnis ist das höchste, das du bekommen hast?',
                'Wann hast du Zeit dich mit deinem Tandem zu treffen?', 'In welchem Land bist du geboren?',
                'Bist du in Deutschland geboren?', 'Seit wann lebst du in Deutschland?',
                'Möchtest du dich mit deinen Kindern anmelden?', 'Hobbys',
                'Was ist dir in einer Freundschaft besonders wichtig?', 'Gibt es einen zusätzlichen Schwerpunkt im Tandem?',
                'Wie kann man dich gut erreichen?', 'Wie groß darf der Altersunterschied sein?',
                'Geschlecht der Tandempartner*in', 'Wie lange kannst du anreisen um dich mit deinem Tandem zu treffen?',
                'Wie bewegst du dich in der Stadt?',
                
                // Neue/fehlende Interview-Fragen hinzufügen
                'Was machst du gerne in deiner Freizeit?',
                'Was hast du vorher gemacht? Was hast du gelernt?',
                'Was möchtest du in Zukunft gerne machen?',
                'Gibt es etwas Neues, was du gerne einmal ausprobieren möchtest?',
                'Gibt es Themen, die dich besonders interessieren?',
                'Was würdest du gerne bei einem Community-Event unternehmen?',
                'Wie stellst du dir dein Tandem vor?',
                
                // Weitere häufige Fragen
                'Was sind deine Hobbys?',
                'Welche Interessen hast du?',
                'Was machst du beruflich?',
                'Wo wohnst du?',
                'Wie alt bist du?',
                'Was studierst du?',
                'Welche Musik hörst du gerne?',
                'Welchen Sport machst du gerne?',
                'Was liest du gerne?',
                'Kochst du gerne?',
                'Reist du gerne?',
                'Gehst du gerne ins Kino?',
                'Welche Filme/Serien schaust du gerne?',
                'Machst du gerne Ausflüge?',
                'Gehst du gerne in Museen?',
                'Machst du gerne Musik?',
                'Tanzt du gerne?',
                'Spielst du gerne Spiele?',
                'Wie verbringst du deine Freizeit?',
                'Was machst du am Wochenende?',
                'Hast du Haustiere?',
                'Welche Farbe magst du?',
                'Was ist dein Lieblings...?',
                'Magst du...?',
                'Hast du schon mal...?',
                'Warst du schon mal...?',
                'Kennst du...?',
                'Kannst du...?'
            ];

            const validMainProfileQuestions = [
                'Vorname', 'Nachname', 'Gruppe', 'Standort', 'Region', 'Vermittler*in',
                'E-Mail-Adresse', 'Telefonnummer', 'Postleitzahl', 'Geburtstag', 'Alter',
                'Geschlecht', 'Standort-Newsletter', 'Terminart', 'Status', 'Durchgeführt von',
                'Datum/Uhrzeit', 'Infoabend', 'Wie wirkt die Person auf dich?',
                'Wie wirkt die Person auf dich? (Freitext)', 'Wie schätzt du die Deutschkenntnisse ein?',
                'Wie schätzt du die Deutschkenntnisse ein? (Freitext)',
                'Worauf sollte bei der Auswahl der Tandempartner*in geachtet werden?',
                'Gibt es besondere Herausforderungen?', 'Sind weitere Schritte nötig? Wenn ja welche?',
                'PLZ', 'Wohnort', 'Land', 'Nationalität', 'Geburtsdatum'
            ];

            // Bereinige und validiere Felder
            if (!Array.isArray(data.fields)) {
                data.fields = [];
            }

            function normalizeQuestion(question) {
                let normalized = question.trim()
                    // Entferne Satzzeichen am Ende
                    .replace(/[:\?\.!]*$/, '')
                    // Normalisiere Leerzeichen
                    .replace(/\s+/g, ' ')
                    // Kleinschreibung für Vergleiche
                    .toLowerCase()
                    // Normalisiere häufige Variationen
                    .replace(/\bmöchtest\b/g, 'willst')
                    .replace(/\bwürdest\b/g, 'willst') 
                    .replace(/\bwürden\b/g, 'wollen')
                    .replace(/\bmöchten\b/g, 'wollen')
                    .replace(/\bmöchte\b/g, 'will')
                    .replace(/\bwürde\b/g, 'will')
                    // Normalisiere Du/du Variationen
                    .replace(/\bdu\b/g, 'du')
                    .replace(/\bdich\b/g, 'dich')
                    .replace(/\bdir\b/g, 'dir')
                    // Entferne überflüssige Wörter
                    .replace(/\bgerne\b/g, '')
                    .replace(/\beinmal\b/g, '')
                    .replace(/\bmal\b/g, '')
                    // Normalisiere Leerzeichen erneut
                    .replace(/\s+/g, ' ')
                    .trim();
                
                return normalized;
            }

            function isValidQuestion(question, pageType) {
                const normalized = normalizeQuestion(question);
                
                // Blacklist statt Whitelist - nur offensichtlich irrelevante Fragen ausschließen
                const excludePatterns = [
                    // Technische/System-Felder
                    /^(id|uid|token|csrf|session|cookie)/i,
                    /^(submit|button|hidden|temp)/i,
                    
                    // Leere oder zu kurze Fragen
                    /^.{0,2}$/,
                    
                    // Nur Zahlen oder Sonderzeichen
                    /^[\d\s\-_.,:;!?()[\]{}]+$/,
                    
                    // Offensichtliche Platzhalter
                    /^(test|example|sample|placeholder|dummy)/i,
                    
                    // Admin-Felder
                    /^(admin|moderator|staff|internal)/i
                ];
                
                // Prüfe Blacklist
                if (excludePatterns.some(pattern => pattern.test(normalized))) {
                    console.log(`❌ Frage durch Blacklist ausgeschlossen: "${question}"`);
                    return false;
                }
                
                // Für Interview-Fragen: Akzeptiere alle sinnvollen Fragen
                if (pageType === 'Interview') {
                    // Akzeptiere Fragen die wie echte Fragen aussehen
                    const looksLikeQuestion = /^.{3,200}$/.test(normalized) && // Angemessene Länge
                                            !/^[\d\s\-_.,:;!?()[\]{}]+$/.test(normalized); // Nicht nur Sonderzeichen
                    
                    if (looksLikeQuestion) {
                        console.log(`✅ Interview-Frage akzeptiert: "${question}"`);
                        return true;
                    }
                }
                
                // Für Hauptprofile: Verwende die bekannte Liste
                const validQuestions = pageType === 'Interview' ? validInterviewQuestions : validMainProfileQuestions;

                const isInWhitelist = validQuestions.some(validQ => {
                    const normalizedValid = normalizeQuestion(validQ);
                    return normalizedValid.toLowerCase() === normalized.toLowerCase() ||
                        normalized.toLowerCase().includes(normalizedValid.toLowerCase()) ||
                        normalizedValid.toLowerCase().includes(normalized.toLowerCase());
                });
                
                if (isInWhitelist) {
                    console.log(`✅ Frage in Whitelist gefunden: "${question}"`);
                    return true;
                }
                
                console.log(`❓ Frage nicht in Whitelist, aber möglicherweise gültig: "${question}"`);
                return pageType === 'Interview'; // Bei Interviews: Im Zweifel akzeptieren
            }

            data.fields = data.fields.filter(f => {
                if (!f || !f.question || !f.answer) return false;

                const question = f.question.trim();
                let answer = f.answer.trim();

                if (question === '' || answer === '') return false;

                // Validierung gegen bekannte Fragen
                if (!isValidQuestion(question, data.pageType)) {
                    console.log(`❌ Unbekannte Frage ignoriert: "${question}"`);
                    return false;
                }

                // WICHTIG: Bereinige die Antwort von störenden Formulierungen
                answer = cleanProfileAnswer(answer);

                // Nach Bereinigung prüfen ob noch Inhalt vorhanden
                if (!answer || answer.length === 0) {
                    console.log(`❌ Antwort nach Bereinigung leer: "${f.answer}" → "${answer}"`);
                    return false;
                }

                // Normalisiere Frage
                f.question = normalizeQuestion(question);
                f.answer = answer; // Verwende bereinigte Antwort

                return true;
            }).map(f => ({
                question: normalizeQuestion(f.question),
                answer: f.answer // Bereits bereinigt
            }));

            console.log(`✅ ${data.fields.length} validierte Felder für ${data.pageType}`);

            // Erweiterte Duplikatserkennung für Profile-Kombination
            let existingProfile = null;
            let existingIndex = -1;

            // Hilfsfunktion für Namen-Normalisierung
            function normalizeNameForComparison(name) {
                const normalized = name.toLowerCase()
                    .trim()
                    // Normalisiere Umlaute
                    .replace(/ä/g, 'ae').replace(/ö/g, 'oe').replace(/ü/g, 'ue').replace(/ß/g, 'ss')
                    // Entferne Sonderzeichen außer Leerzeichen und Bindestriche
                    .replace(/[^a-z0-9\s\-]/g, '')
                    // Normalisiere Leerzeichen
                    .replace(/\s+/g, ' ')
                    .trim();
                
                // Sicherheit: Blockiere offensichtlich generische Namen
                if (normalized.match(/^(aufnahmegespraech|interview|gespräch|locals?|einwander)/)) {
                    console.log(`⚠️ Generischer Name blockiert: "${normalized}"`);
                    return ''; // Leerer String wird nicht gematcht
                }
                
                return normalized;
            }

            // Hilfsfunktion für erweiterte Namensextraktion
            function extractCoreNames(name) {
                const names = [];
                
                // 1. Name aus Klammern extrahieren (PRIORITÄT!)
                const bracketMatch = name.match(/\(([^)]+)\)/);
                if (bracketMatch) {
                    const nameInBrackets = bracketMatch[1].trim();
                    // Nur echte Personennamen, keine generischen Begriffe
                    if (nameInBrackets.length > 2 && !nameInBrackets.match(/^(locals?|einwander|interview|gespräch|aufnahme)/i)) {
                        names.push(nameInBrackets);
                        console.log(`📛 Hauptname aus Klammern: "${nameInBrackets}"`);
                    }
                }
                
                // 2. Wenn KEIN Name in Klammern vorhanden ist, dann vorsichtig andere Namen extrahieren
                if (names.length === 0) {
                    // Prüfe ob es ein "nackter" Name ohne Präfix ist
                    const withoutPrefix = name.replace(/^(aufnahmegespräch\s+locals?\s*|aufnahmegespräch\s+einwander\*innen\s*|interview\s+|gespräch\s+)/i, '').trim();
                    
                    // Nur wenn der bereinigte Name deutlich kürzer ist als der Original UND mindestens 3 Zeichen hat
                    if (withoutPrefix && withoutPrefix.length >= 3 && withoutPrefix.length < name.length * 0.6) {
                        names.push(withoutPrefix);
                        console.log(`📛 Name ohne Präfix: "${withoutPrefix}"`);
                    }
                    
                    // Als letzter Fallback: Original Name, aber nur wenn er nicht rein generisch ist
                    if (names.length === 0 && !name.match(/^(aufnahmegespräch|interview|gespräch)/i)) {
                        names.push(name);
                        console.log(`📛 Original Name als Fallback: "${name}"`);
                    }
                }
                
                // Filtere nochmals generische/problematische Namen heraus
                const filteredNames = names.filter(n => {
                    if (!n || n.length < 3) return false;
                    
                    // Entferne explizit generische Begriffe
                    const isGeneric = n.match(/^(aufnahmegespräch|interview|gespräch|locals?|einwander)/i);
                    if (isGeneric) {
                        console.log(`❌ Generischer Name ignoriert: "${n}"`);
                        return false;
                    }
                    
                    return true;
                });
                
                console.log(`📝 Finale extrahierte Namen für "${name}":`, filteredNames);
                return filteredNames;
            }

            // 1. Erweiterte Namensübereinstimmung mit Normalisierung
            const incomingNames = extractCoreNames(data.name);
            const normalizedIncomingNames = incomingNames.map(normalizeNameForComparison);

            console.log('🔍 Suche Duplikate für:', data.name);
            console.log('📝 Extrahierte Namen:', incomingNames);
            console.log('🔧 Normalisierte Namen:', normalizedIncomingNames);

            for (let i = 0; i < profiles.length; i++) {
                const profile = profiles[i];
                const existingNames = extractCoreNames(profile.name);
                const normalizedExistingNames = existingNames.map(normalizeNameForComparison);
                
                // Prüfe alle Kombinationen mit SEHR strengen Kriterien
                let matchFound = false;
                for (const normIncoming of normalizedIncomingNames) {
                    for (const normExisting of normalizedExistingNames) {
                        // Sehr strenge Überprüfung: Namen müssen identisch und echte Personennamen sein
                        if (normIncoming === normExisting && normIncoming.length >= 3) {
                            
                            // KRITISCH: Überprüfe ob es ein echter Personenname ist (enthält Vor- und Nachname)
                            const hasSpaceOrHyphen = normIncoming.includes(' ') || normIncoming.includes('-');
                            const isNotGeneric = !normIncoming.match(/^(aufnahmegespraech|interview|gespräch|locals?|einwander|profile|person|teilnehmer)/);
                            const isLongEnough = normIncoming.length >= 6; // Mindestens "max schmidt" = 11 Zeichen normalisiert
                            
                            if (hasSpaceOrHyphen && isNotGeneric && isLongEnough) {
                                console.log(`✅ Duplikat gefunden (Personenname): "${data.name}" ↔ "${profile.name}" (${normIncoming})`);
                                existingProfile = profile;
                                existingIndex = i;
                                matchFound = true;
                                break;
                            } else {
                                console.log(`🚫 Potentielles Duplikat ABGELEHNT: "${normIncoming}" (hasSpace:${hasSpaceOrHyphen}, notGeneric:${isNotGeneric}, longEnough:${isLongEnough})`);
                            }
                        }
                    }
                    if (matchFound) break;
                }
                if (matchFound) break;
            }

            // 2. URL-basierte Erkennung (Fallback)
            if (!existingProfile && data.url) {
                existingIndex = profiles.findIndex(p => p.url === data.url);
                if (existingIndex !== -1) {
                    existingProfile = profiles[existingIndex];
                    console.log('✅ Duplikat über URL gefunden:', data.url);
                }
            }

            // 2.5 Zusätzliche Sicherheitsprüfung bei Interview-Profilen
            if (!existingProfile && data.pageType === 'Interview') {
                // Bei Interview-Profilen: Prüfe ob bereits ein Hauptprofil mit gleichem Namen existiert
                const personNameFromBrackets = data.name.match(/\(([^)]+)\)/)?.[1]?.trim();
                if (personNameFromBrackets) {
                    existingIndex = profiles.findIndex(p => {
                        // Suche nach exakter Namensübereinstimmung
                        const existingPersonName = p.name.match(/\(([^)]+)\)/)?.[1]?.trim() || p.name.trim();
                        return existingPersonName.toLowerCase() === personNameFromBrackets.toLowerCase();
                    });
                    
                    if (existingIndex !== -1) {
                        existingProfile = profiles[existingIndex];
                        console.log(`✅ Interview-Profil zu Hauptprofil zugeordnet: "${personNameFromBrackets}"`);
                    }
                }
            }

            // 3. Manuelle Duplikatsprüfung für unklare Fälle
            if (!existingProfile) {
                // Zeige potentielle Duplikate zur manuellen Prüfung
                const possibleDuplicates = profiles.filter(p => {
                    const pNames = extractCoreNames(p.name);
                    const pNormalized = pNames.map(normalizeNameForComparison);
                    
                    // Prüfe ob ein eingehender Name mit einem Profil-Namen ähnlich ist
                    for (const inName of normalizedIncomingNames) {
                        for (const pName of pNormalized) {
                            // Prüfe auf Teilstring-Übereinstimmung bei ausreichender Länge
                            if ((inName.includes(pName) || pName.includes(inName)) && 
                                Math.min(inName.length, pName.length) > 2) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
                
                if (possibleDuplicates.length > 0) {
                    console.log('🤔 Mögliche Duplikate gefunden:', possibleDuplicates.map(p => p.name));
                    
                    // Zeige Merge-Dialog
                    setTimeout(() => showPossibleDuplicatesDialog(data, possibleDuplicates), 500);
                }
            }

            if (existingProfile) {
                console.log('🔄 Kombiniere Daten mit bestehendem Profil:', existingProfile.name);

                // Kombiniere Felder und entferne Duplikate
                const combinedFields = [...existingProfile.fields];

                data.fields.forEach(newField => {
                    const normalizedNewQuestion = normalizeQuestion(newField.question);

                    const existingFieldIndex = combinedFields.findIndex(f =>
                        normalizeQuestion(f.question).toLowerCase() === normalizedNewQuestion.toLowerCase()
                    );

                    if (existingFieldIndex !== -1) {
                        const existingField = combinedFields[existingFieldIndex];
                        console.log(`🔄 Duplikat gefunden: "${normalizedNewQuestion}"`);

                        // Kombiniere oder aktualisiere Antworten
                        if (newField.answer.length > existingField.answer.length) {
                            console.log(`  → Längere Antwort übernommen: "${newField.answer}"`);
                            combinedFields[existingFieldIndex].answer = newField.answer;
                        }
                    } else {
                        // Füge neues Feld hinzu
                        console.log(`➕ Neues Feld: "${normalizedNewQuestion}" = "${newField.answer}"`);
                        combinedFields.push({
                            question: normalizedNewQuestion,
                            answer: newField.answer
                        });
                    }
                });

                // Aktualisiere bestehendes Profil
                profiles[existingIndex] = {
                    ...existingProfile,
                    fields: combinedFields,
                    pageType: existingProfile.pageType && data.pageType ?
                        `${existingProfile.pageType} + ${data.pageType}` :
                        (data.pageType || existingProfile.pageType),
                    lastUpdated: new Date().toISOString(),
                    url: data.url || existingProfile.url
                };

                saveProfiles();
                updateUI();

                const addedFields = data.fields.length;
                const totalFields = combinedFields.length;
                showNotification(
                    `🔄 Profil "${data.name}" aktualisiert: +${addedFields} neue Felder (${pageType}) → Total: ${totalFields} Felder`,
                    'success',
                    4000
                );

                updateStatus(`Profil "${data.name}" kombiniert • ${addedFields} neue Felder hinzugefügt • Gesamt: ${profiles.length}`);
                return;
            }

            // Prüfe auf andere Duplikate
            existingIndex = profiles.findIndex(p =>
                (p.url && data.url && p.url === data.url && p.name === data.name)
            );

            if (existingIndex !== -1) {
                if (confirm(`Profil "${data.name}" existiert bereits. Überschreiben?`)) {
                    profiles.splice(existingIndex, 1);
                } else {
                    showNotification('⚠️ Profil nicht hinzugefügt (Duplikat)', 'warning');
                    return;
                }
            }

            // Erstelle neues Profil
            const newProfile = {
                id: Date.now() + Math.random(),
                name: data.name,
                url: data.url || 'unknown',
                fields: data.fields,
                pageType: data.pageType,
                timestamp: new Date().toISOString()
            };

            profiles.push(newProfile);
            saveProfiles();
            updateUI();

            const pageInfo = data.pageType ? ` (${data.pageType})` : '';
            showNotification(
                `✅ Neues Profil "${data.name}" hinzugefügt${pageInfo} (${data.fields.length} Felder)`,
                'success',
                4000
            );

            updateStatus(`Profil "${data.name}" erfolgreich hinzugefügt • Gesamt: ${profiles.length}`);
        }

        function showPossibleDuplicatesDialog(newProfile, possibleDuplicates) {
            if (possibleDuplicates.length === 0) return;
            
            const modal = createModal('🔍 Mögliche Duplikate erkannt', `
                <div style="margin-bottom: 1rem;">
                    <h4>Neues Profil: <strong style="color: var(--swaf-red);">${newProfile.name}</strong></h4>
                    <p>Die folgenden Profile könnten dieselbe Person sein:</p>
                </div>
                
                <div style="max-height: 300px; overflow-y: auto;">
                    ${possibleDuplicates.map((profile, index) => `
                        <div style="border: 2px solid #ddd; padding: 1rem; margin: 0.5rem 0; border-radius: 6px;">
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="merge-choice" value="${index}" style="margin-right: 1rem; margin-top: 0.2rem;">
                                <div style="flex: 1;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                        <strong>${profile.name}</strong>
                                        <span style="background: var(--swaf-teal); color: white; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.9rem;">
                                            ${profile.fields.length} Felder
                                        </span>
                                    </div>
                                    <div style="font-size: 0.9rem; color: var(--swaf-dark-gray);">
                                        URL: ${profile.url}<br>
                                        Erstellt: ${new Date(profile.timestamp).toLocaleString('de-DE')}
                                    </div>
                                </div>
                            </label>
                        </div>
                    `).join('')}
                </div>
                
                <div style="margin-top: 1rem;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio" name="merge-choice" value="new" style="margin-right: 0.5rem;">
                        <span><strong>Als neues Profil hinzufügen</strong> (nicht zusammenführen)</span>
                    </label>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Zusammenführen', class: 'btn-primary', action: function() { processDuplicateChoice(newProfile, possibleDuplicates); } }
            ]);
        }

        function processDuplicateChoice(newProfile, possibleDuplicates) {
            console.log('🔄 Verarbeite Duplikat-Wahl...');
            
            const selectedRadio = document.querySelector('input[name="merge-choice"]:checked');
            
            if (!selectedRadio) {
                alert('Bitte wähle eine Option aus.');
                return;
            }
            
            closeModal();
            
            if (selectedRadio.value === 'new') {
                // Als neues Profil hinzufügen
                console.log('👤 Profil als neu markiert:', newProfile.name);
                addNewProfile(newProfile);
            } else {
                // Mit ausgewähltem Profil zusammenführen
                const selectedIndex = parseInt(selectedRadio.value);
                
                if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= possibleDuplicates.length) {
                    console.error('❌ Ungültiger Index:', selectedIndex);
                    alert('Fehler bei der Auswahl. Bitte versuche es erneut.');
                    return;
                }
                
                const existingProfile = possibleDuplicates[selectedIndex];
                
                if (!existingProfile) {
                    console.error('❌ Ausgewähltes Profil nicht gefunden');
                    alert('Profil nicht gefunden. Bitte versuche es erneut.');
                    return;
                }
                
                console.log('🔄 Führe Profile zusammen:', newProfile.name, '→', existingProfile.name);
                mergeProfiles(existingProfile, newProfile);
            }
        }

        function addNewProfile(profileData) {
            // Erstelle neues Profil (Originaler Code)
            const newProfile = {
                id: Date.now() + Math.random(),
                name: profileData.name,
                url: profileData.url || 'unknown',
                fields: profileData.fields,
                pageType: profileData.pageType,
                timestamp: new Date().toISOString()
            };

            profiles.push(newProfile);
            saveProfiles();
            updateUI();

            const pageInfo = profileData.pageType ? ` (${profileData.pageType})` : '';
            showNotification(
                `✅ Neues Profil "${profileData.name}" hinzugefügt${pageInfo} (${profileData.fields.length} Felder)`,
                'success',
                4000
            );

            updateStatus(`Profil "${profileData.name}" erfolgreich hinzugefügt • Gesamt: ${profiles.length}`);
        }

        function mergeProfiles(existingProfile, newProfileData) {
            console.log('🔄 Kombiniere Daten mit bestehendem Profil:', existingProfile.name);

            const existingIndex = profiles.findIndex(p => p.id === existingProfile.id);
            if (existingIndex === -1) {
                console.error('❌ Bestehendes Profil nicht gefunden');
                return;
            }

            // Kombiniere Felder und entferne Duplikate
            const combinedFields = [...existingProfile.fields];

            newProfileData.fields.forEach(newField => {
                const normalizedNewQuestion = normalizeQuestion(newField.question);

                const existingFieldIndex = combinedFields.findIndex(f =>
                    normalizeQuestion(f.question).toLowerCase() === normalizedNewQuestion.toLowerCase()
                );

                if (existingFieldIndex !== -1) {
                    const existingField = combinedFields[existingFieldIndex];
                    console.log(`🔄 Duplikat gefunden: "${normalizedNewQuestion}"`);

                    // Kombiniere oder aktualisiere Antworten
                    if (newField.answer.length > existingField.answer.length) {
                        console.log(`  → Längere Antwort übernommen: "${newField.answer}"`);
                        combinedFields[existingFieldIndex].answer = newField.answer;
                    }
                } else {
                    // Füge neues Feld hinzu
                    console.log(`➕ Neues Feld: "${normalizedNewQuestion}" = "${newField.answer}"`);
                    combinedFields.push({
                        question: normalizedNewQuestion,
                        answer: newField.answer
                    });
                }
            });

            // Aktualisiere bestehendes Profil
            profiles[existingIndex] = {
                ...existingProfile,
                fields: combinedFields,
                pageType: existingProfile.pageType && newProfileData.pageType ?
                    `${existingProfile.pageType} + ${newProfileData.pageType}` :
                    (newProfileData.pageType || existingProfile.pageType),
                lastUpdated: new Date().toISOString(),
                url: newProfileData.url || existingProfile.url
            };

            saveProfiles();
            updateUI();

            const addedFields = newProfileData.fields.length;
            const totalFields = combinedFields.length;
            showNotification(
                `🔄 Profil "${existingProfile.name}" aktualisiert: +${addedFields} neue Felder (${newProfileData.pageType}) → Total: ${totalFields} Felder`,
                'success',
                4000
            );

            updateStatus(`Profil "${existingProfile.name}" kombiniert • ${addedFields} neue Felder hinzugefügt • Gesamt: ${profiles.length}`);
        }

        function updateMergeProfileLists() {
            const select1 = document.getElementById('merge-profile-1');
            const select2 = document.getElementById('merge-profile-2');
            
            if (!select1 || !select2) return;
            
            const options = profiles.map(p => 
                `<option value="${p.id}">${p.name} (${p.fields.length} Felder)</option>`
            ).join('');
            
            select1.innerHTML = '<option value="">-- Profil auswählen --</option>' + options;
            select2.innerHTML = '<option value="">-- Profil auswählen --</option>' + options;
            
            console.log('🔄 Merge-Listen aktualisiert mit', profiles.length, 'Profilen');
        }

        function showMergePreview() {
            const id1 = document.getElementById('merge-profile-1').value;
            const id2 = document.getElementById('merge-profile-2').value;
            
            if (!id1 || !id2) {
                alert('Bitte wähle beide Profile aus.');
                return;
            }
            
            if (id1 === id2) {
                alert('Bitte wähle zwei verschiedene Profile aus.');
                return;
            }
            
            const profile1 = profiles.find(p => p.id == id1);
            const profile2 = profiles.find(p => p.id == id2);
            
            if (!profile1 || !profile2) {
                alert('Profile nicht gefunden.');
                return;
            }
            
            const modal = createModal('👀 Merge-Vorschau', `
                <div style="margin-bottom: 1rem;">
                    <h4>Profile werden zusammengeführt:</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
                        <div style="border: 2px solid var(--swaf-red); padding: 1rem; border-radius: 6px;">
                            <h5 style="color: var(--swaf-red); margin-top: 0;">Hauptprofil (bleibt erhalten)</h5>
                            <strong>${profile1.name}</strong><br>
                            <small>${profile1.fields.length} Felder</small>
                        </div>
                        <div style="border: 2px solid var(--swaf-teal); padding: 1rem; border-radius: 6px;">
                            <h5 style="color: var(--swaf-teal); margin-top: 0;">Zusatzprofil (wird eingemischt)</h5>
                            <strong>${profile2.name}</strong><br>
                            <small>${profile2.fields.length} Felder</small>
                        </div>
                    </div>
                </div>
                
                <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px;">
                    <h4>Was passiert:</h4>
                    <ul style="margin: 0.5rem 0 0 1rem;">
                        <li><strong>Felder werden kombiniert:</strong> Alle einzigartigen Felder aus beiden Profilen</li>
                        <li><strong>Bei Duplikaten:</strong> Längere/vollständigere Antwort wird behalten</li>
                        <li><strong>Profil 2 wird gelöscht</strong> nach dem Zusammenführen</li>
                        <li><strong>Alle Tandems bleiben erhalten</strong> (Referenzen werden aktualisiert)</li>
                    </ul>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Jetzt zusammenführen', class: 'btn-primary', action: function() { confirmManualMerge(profile1, profile2); } }
            ]);
        }

        function confirmManualMerge(profile1, profile2) {
            closeModal();
            
            if (!confirm(`Wirklich "${profile2.name}" in "${profile1.name}" einmischen?\n\nProfile 2 wird danach gelöscht!`)) {
                return;
            }
            
            // Führe Merge durch
            const profile2Data = {
                name: profile2.name,
                fields: profile2.fields,
                pageType: profile2.pageType,
                url: profile2.url
            };
            
            mergeProfiles(profile1, profile2Data);
            
            // Lösche das zweite Profil
            const index2 = profiles.findIndex(p => p.id === profile2.id);
            if (index2 !== -1) {
                profiles.splice(index2, 1);
                saveProfiles();
            }
            
            // Aktualisiere Tandem-Referenzen
            updateTandemReferences(profile2.id, profile1.id);
            
            // UI aktualisieren
            updateUI();
            updateMergeProfileLists();
            
            showNotification(`✅ Profile erfolgreich zusammengeführt: "${profile2.name}" → "${profile1.name}"`, 'success', 5000);
        }

        function manualMergeProfiles() {
            const id1 = document.getElementById('merge-profile-1').value;
            const id2 = document.getElementById('merge-profile-2').value;
            
            if (!id1 || !id2) {
                alert('Bitte wähle beide Profile aus.');
                return;
            }
            
            if (id1 === id2) {
                alert('Bitte wähle zwei verschiedene Profile aus.');
                return;
            }
            
            showMergePreview();
        }

        function updateTandemReferences(oldProfileId, newProfileId) {
            let updatedTandems = 0;
            
            tandems.forEach(tandem => {
                if (tandem.profile1.id == oldProfileId) {
                    const newProfile = profiles.find(p => p.id == newProfileId);
                    if (newProfile) {
                        tandem.profile1 = newProfile;
                        tandem.name = `${tandem.profile1.name} & ${tandem.profile2.name}`;
                        updatedTandems++;
                    }
                }
                if (tandem.profile2.id == oldProfileId) {
                    const newProfile = profiles.find(p => p.id == newProfileId);
                    if (newProfile) {
                        tandem.profile2 = newProfile;
                        tandem.name = `${tandem.profile1.name} & ${tandem.profile2.name}`;
                        updatedTandems++;
                    }
                }
            });
            
            if (updatedTandems > 0) {
                saveTandems();
                console.log(`✅ ${updatedTandems} Tandem-Referenzen aktualisiert`);
            }
        }

        function normalizeQuestion(question) {
            return question.trim().replace(/[:\?\.]*$/, '').replace(/\s+/g, ' ');
        }

        // ===============================
        // KARTENANSICHT
        // ===============================
        let profileMap = null;
        let profileMarkers = [];
        let currentView = 'list';
        
        function switchProfileView(view) {
            currentView = view;
            const listView = document.getElementById('available-profiles');
            const mapView = document.getElementById('map-view-container');
            const listBtn = document.getElementById('list-view-btn');
            const mapBtn = document.getElementById('map-view-btn');
        
            if (view === 'list') {
                listView.style.display = 'block';
                mapView.style.display = 'none';
                listBtn.style.background = 'var(--swaf-teal)';
                listBtn.style.color = 'white';
                mapBtn.style.background = '';
                mapBtn.style.color = '';
            } else {
                listView.style.display = 'none';
                mapView.style.display = 'block';
                listBtn.style.background = '';
                listBtn.style.color = '';
                mapBtn.style.background = 'var(--swaf-teal)';
                mapBtn.style.color = 'white';
                loadProfileMap();
            }
        }
        
        async function loadProfileMap() {
            console.log('🗺️ Lade Kartenansicht...');
        
            // Initialisiere Karte wenn noch nicht vorhanden
            if (!profileMap) {
                profileMap = L.map('profile-map').setView([51.1657, 10.4515], 6); // Deutschland Zentrum
        
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(profileMap);
            }
        
            // Lösche alte Marker
            profileMarkers.forEach(marker => profileMap.removeLayer(marker));
            profileMarkers = [];
        
            // Filtere verfügbare Profile
            const matchedProfileIds = new Set();
            tandems.forEach(tandem => {
                matchedProfileIds.add(tandem.profile1.id);
                matchedProfileIds.add(tandem.profile2.id);
            });
        
            const availableProfiles = profiles.filter(profile => !matchedProfileIds.has(profile.id));
        
            if (availableProfiles.length === 0) {
                showNotification('Keine verfügbaren Profile zum Anzeigen', 'info');
                return;
            }
        
            const bounds = [];
        
            // Erstelle Marker für jedes Profil
            for (const profile of availableProfiles) {
                const plzField = profile.fields.find(f => 
                    f.question.toLowerCase().includes('postleitzahl') || 
                    f.question.toLowerCase().includes('plz')
                );
        
                if (!plzField) continue;
        
                const plz = extractPLZ(plzField.answer);
                if (!plz) continue;
        
                // Hole Koordinaten
                const coords = await getPLZCoordinates(plz);
                if (!coords) continue;
        
                // Extrahiere Profilinformationen
                const alter = profile.fields.find(f => f.question.toLowerCase().includes('alter'))?.answer || 'N/A';
                const geschlecht = profile.fields.find(f => f.question.toLowerCase().includes('geschlecht'))?.answer || 'N/A';
                const gruppe = profile.fields.find(f => 
                    f.question.toLowerCase().includes('gruppe') || 
                    f.question.toLowerCase().includes('local') || 
                    f.question.toLowerCase().includes('einwander')
                )?.answer || 'N/A';
                const maxAltersdiff = profile.fields.find(f => 
                    f.question.toLowerCase().includes('maximale altersdifferenz') ||
                    f.question.toLowerCase().includes('altersunterschied')
                )?.answer || 'N/A';
                const geschlechtTandem = profile.fields.find(f => 
                    f.question.toLowerCase().includes('geschlecht') && 
                    f.question.toLowerCase().includes('tandem')
                )?.answer || 'N/A';
        
                // Bestimme Marker-Farbe basierend auf Auswahl
                const isSelected = selectedProfiles.some(id => id == profile.id);
                const markerColor = isSelected ? '#C30045' : '#009892';
        
                // Erstelle Custom Icon
                const customIcon = L.divIcon({
                    className: 'custom-marker',
                    html: `<div style="background-color: ${markerColor}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">${profile.name.substring(0, 1).toUpperCase()}</div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });
        
                // Erstelle Marker
                const marker = L.marker(coords, { icon: customIcon }).addTo(profileMap);
        
                // Popup-Inhalt
                const popupContent = `
                    <div style="min-width: 200px;">
                        <h4 style="margin: 0 0 0.5rem 0; color: var(--swaf-red);">${profile.name}</h4>
                        <table style="width: 100%; font-size: 0.9rem;">
                            <tr><td><strong>Alter:</strong></td><td>${alter}</td></tr>
                            <tr><td><strong>Geschlecht:</strong></td><td>${geschlecht}</td></tr>
                            <tr><td><strong>Gruppe:</strong></td><td>${gruppe}</td></tr>
                            <tr><td><strong>PLZ:</strong></td><td>${plz}</td></tr>
                            <tr><td><strong>Max. Altersdiff.:</strong></td><td>${maxAltersdiff}</td></tr>
                            <tr><td><strong>Geschlecht Tandem:</strong></td><td>${geschlechtTandem}</td></tr>
                        </table>
                        <button class="btn btn-primary" onclick="toggleProfileSelectionFromMap('${profile.id}')" style="width: 100%; margin-top: 0.5rem;">
                            ${isSelected ? '✓ Ausgewählt' : 'Auswählen'}
                        </button>
                    </div>
                `;
        
                marker.bindPopup(popupContent);
                profileMarkers.push(marker);
                bounds.push(coords);
            }
        
            // Passe Kartenansicht an alle Marker an
            if (bounds.length > 0) {
                profileMap.fitBounds(bounds, { padding: [50, 50] });
            }
        
            console.log(`✅ ${profileMarkers.length} Profile auf Karte angezeigt`);
        }
        
        function toggleProfileSelectionFromMap(profileId) {
            // Konvertiere zu Number für konsistenten Vergleich
            const numericId = typeof profileId === 'string' ? parseFloat(profileId) : profileId;
            
            const index = selectedProfiles.findIndex(id => {
                const numericSelectedId = typeof id === 'string' ? parseFloat(id) : id;
                return numericSelectedId === numericId;
            });
        
            if (index > -1) {
                selectedProfiles.splice(index, 1);
            } else {
                if (selectedProfiles.length >= 2) {
                    showNotification('Maximal 2 Profile können ausgewählt werden', 'warning');
                    return;
                }
                selectedProfiles.push(numericId);
            }
        
            updateMatchingStatus();
            
            // Aktualisiere Karte
            loadProfileMap();
            
            console.log('📊 Ausgewählte Profile nach Karten-Toggle:', selectedProfiles);
        }
        
        // ===============================
        // MATCHING-FUNKTIONEN
        // ===============================
        function loadAvailableProfiles() {
            console.log('🔄 Lade verfügbare Profile für Matching...');
            console.log('📊 Anzahl Profile im Array:', profiles.length);

            const container = document.getElementById('available-profiles');

            if (!container) {
                console.error('❌ Container "available-profiles" nicht gefunden!');
                return;
            }

            // Filtere Profile: Entferne bereits gematchte Profile
            const matchedProfileIds = new Set();
            tandems.forEach(tandem => {
                matchedProfileIds.add(tandem.profile1.id);
                matchedProfileIds.add(tandem.profile2.id);
            });

            const availableProfiles = profiles.filter(profile => !matchedProfileIds.has(profile.id));

            console.log('📊 Gematchte Profile:', matchedProfileIds.size, 'Verfügbare Profile:', availableProfiles.length);

            if (availableProfiles.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--swaf-dark-gray);">
                        ${profiles.length === 0
                        ? 'Keine Profile verfügbar. Bitte zuerst Profile sammeln.'
                        : 'Alle Profile sind bereits zu Tandems gematcht!'
                    }
                        ${matchedProfileIds.size > 0
                        ? `<p style="margin-top: 1rem; font-size: 0.9rem;"><strong>${matchedProfileIds.size} Profile bereits gematcht:</strong><br>${tandems.map(t => t.name).join('<br>')}</p>`
                        : ''
                    }
                    </div>
                `;
                return;
            }

            console.log('✅ Erstelle verfügbare Profile-Liste für Matching...');

            try {
                container.innerHTML = availableProfiles.map((profile, index) => {
                    console.log(`📋 Verfügbares Profil ${index + 1}: ${profile.name} (${profile.fields.length} Felder) ID: ${profile.id}`);

                    // Prüfe ob dieses Profil bereits ausgewählt ist
                    const isSelected = selectedProfiles.some(id => id == profile.id);
                    const selectedClass = isSelected ? 'selected' : '';

                    console.log(`  -> Ist ausgewählt: ${isSelected} (${selectedClass})`);

                    return `
                        <div class="profile-item ${selectedClass}" onclick="selectProfile('${profile.id}')" data-profile-id="${profile.id}">
                            <strong>${profile.name}</strong>
                            <p><small>${profile.fields.length} Felder</small></p>
                            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--swaf-dark-gray);">
                                ${profile.fields.slice(0, 3).map(f => f.question).join(', ')}
                                ${profile.fields.length > 3 ? '...' : ''}
                            </div>
                        </div>
                    `;
                }).join('');

                console.log('✅ Profile-Liste erfolgreich erstellt');
                console.log('📊 Bereits ausgewählte Profile:', selectedProfiles);

                // Zeige Info über verfügbare vs. gematchte Profile
                const message = matchedProfileIds.size > 0
                    ? `✅ ${availableProfiles.length} verfügbare Profile geladen (${matchedProfileIds.size} bereits gematcht)`
                    : `✅ ${availableProfiles.length} Profile für Matching geladen`;
                showNotification(message, 'success', 3000);

            } catch (error) {
                console.error('❌ Fehler beim Erstellen der Profile-Liste:', error);
                container.innerHTML = `
                    <div class="alert alert-error">
                        <strong>Fehler beim Laden der Profile:</strong> ${error.message}<br>
                        <button onclick="loadAvailableProfiles()" class="btn btn-outline btn-small" style="margin-top: 0.5rem;">🔄 Erneut versuchen</button>
                    </div>
                `;
            }
        }

        function selectProfile(profileId) {
            console.log('🎯 Profile auswählen:', profileId, 'Typ:', typeof profileId);
            console.log('📋 Aktuell ausgewählte Profile vor Änderung:', selectedProfiles);

            const element = event.target.closest('.profile-item');

            if (!element) {
                console.error('❌ Profile-Element nicht gefunden');
                return;
            }

            // Verwende == für flexiblen Typ-Vergleich
            const isCurrentlySelected = selectedProfiles.some(id => id == profileId);
            console.log('🔍 Profil bereits ausgewählt?', isCurrentlySelected);

            if (isCurrentlySelected) {
                console.log('➖ Entferne Profile aus Auswahl');
                element.classList.remove('selected');
                selectedProfiles = selectedProfiles.filter(id => id != profileId);
            } else {
                if (selectedProfiles.length >= 2) {
                    console.log('⚠️ Maximale Anzahl Profile bereits ausgewählt');
                    showNotification('Maximal 2 Profile können gleichzeitig ausgewählt werden. Entferne zuerst ein anderes Profil.', 'warning');
                    return;
                }

                console.log('➕ Füge Profile zur Auswahl hinzu');
                element.classList.add('selected');
                selectedProfiles.push(profileId);
            }

            console.log('✅ Neue Auswahl nach Änderung:', selectedProfiles);
            updateMatchingStatus();
        }

        function updateMatchingStatus() {
            // Zeige Status der Auswahl
            const statusElement = document.getElementById('matching-status');
            const matchBtn = document.getElementById('match-btn');

            if (statusElement) {
                statusElement.textContent = `${selectedProfiles.length} von 2 Profilen ausgewählt`;

                if (selectedProfiles.length === 0) {
                    statusElement.style.background = 'var(--swaf-light-gray)';
                    statusElement.style.color = 'var(--swaf-dark-gray)';
                } else if (selectedProfiles.length === 1) {
                    statusElement.style.background = 'var(--swaf-lightest-red)';
                    statusElement.style.color = 'var(--swaf-red)';
                    statusElement.textContent += ' - Wähle noch ein Profil';
                } else if (selectedProfiles.length === 2) {
                    statusElement.style.background = 'var(--swaf-lightest-teal)';
                    statusElement.style.color = 'var(--swaf-teal)';
                    statusElement.textContent += ' - Bereit zum Matchen!';
                }
            }

            // Aktiviere/Deaktiviere Match-Button
            if (matchBtn) {
                matchBtn.disabled = selectedProfiles.length !== 2;
                if (selectedProfiles.length === 2) {
                    matchBtn.textContent = '🤝 Profile matchen';
                } else {
                    matchBtn.textContent = `🤝 Ausgewählte Profile matchen (${selectedProfiles.length}/2)`;
                }
            }
        }

        function matchSelectedProfiles() {
            console.log('🤝 Starte Profile-Matching...');
            console.log('📋 Ausgewählte Profile:', selectedProfiles);
            console.log('📋 Typ der ausgewählten IDs:', selectedProfiles.map(id => typeof id));

            if (selectedProfiles.length !== 2) {
                const message = `Bitte wähle genau 2 Profile aus. Aktuell ausgewählt: ${selectedProfiles.length}`;
                console.log('❌ ' + message);
                showNotification(message, 'warning');
                return;
            }

            // Verwende == statt === für flexiblen Typ-Vergleich
            const profile1 = profiles.find(p => p.id == selectedProfiles[0]);
            const profile2 = profiles.find(p => p.id == selectedProfiles[1]);

            console.log('🔍 Suche Profil 1 mit ID:', selectedProfiles[0], 'Typ:', typeof selectedProfiles[0]);
            console.log('🔍 Suche Profil 2 mit ID:', selectedProfiles[1], 'Typ:', typeof selectedProfiles[1]);
            console.log('📊 Alle verfügbaren Profile-IDs:', profiles.map(p => `${p.id} (${typeof p.id})`));

            console.log('👤 Profil 1 gefunden:', profile1 ? profile1.name : 'NICHT GEFUNDEN');
            console.log('👤 Profil 2 gefunden:', profile2 ? profile2.name : 'NICHT GEFUNDEN');

            if (!profile1 || !profile2) {
                const message = 'Fehler beim Laden der Profile. ID-Typ-Problem erkannt - verwende "🔍 Debug Matching" für Details.';
                console.error('❌ ' + message);

                // Zusätzliche Debug-Info
                console.error('🐛 DEBUG: Profile-Suche fehlgeschlagen:');
                console.error('- Gesuchte ID 1:', selectedProfiles[0], typeof selectedProfiles[0]);
                console.error('- Gesuchte ID 2:', selectedProfiles[1], typeof selectedProfiles[1]);
                console.error('- Verfügbare IDs:', profiles.map(p => ({ id: p.id, type: typeof p.id, name: p.name })));

                showNotification(message, 'error');
                return;
            }

            console.log('🔍 Analysiere Gemeinsamkeiten...');
            const commonalities = findCommonalities(profile1, profile2);
            console.log('📊 Gefundene Gemeinsamkeiten:', commonalities.length);

            const tandem = {
                id: Date.now() + Math.random(),
                profile1: profile1,
                profile2: profile2,
                name: `${profile1.name} & ${profile2.name}`,
                created: new Date().toISOString(),
                commonalities: commonalities
            };

            console.log('✅ Neues Tandem erstellt:', tandem.name);

            tandems.push(tandem);
            saveTandems();

            updateMatchedPairs();
            clearProfileSelection();
            updateStatistics();

            // WICHTIG: Profile-Liste aktualisieren
            loadAvailableProfiles();

            const successMessage = `✅ Tandem "${tandem.name}" erstellt (${commonalities.filter(c => c.commonality).length} Gemeinsamkeiten)`;
            showNotification(successMessage, 'success');
            updateStatus(`Tandem "${tandem.name}" erstellt`);

            console.log('🎉 Matching erfolgreich abgeschlossen!');
        }

        function generateSmartCommonalityText(question, answer1, answer2, profile1, profile2) {
            const q = question.toLowerCase();
            const a1 = cleanAnswer(answer1).toLowerCase();
            const a2 = cleanAnswer(answer2).toLowerCase();
            
            const name1 = extractFirstName(profile1.name);
            const name2 = extractFirstName(profile2.name);
            
            console.log(`🧠 Intelligente Analyse: "${question}" | "${a1}" vs "${a2}"`);
            
            // Identische Antworten
            if (a1 === a2 && a1.length > 0) {
                if (q.includes('hobby') || q.includes('freizeit')) {
                    return `Gemeinsames Hobby: ${answer1}! 🎯`;
                }
                if (q.includes('interesse') || q.includes('thema')) {
                    return `Geteiltes Interesse: ${answer1} 💡`;
                }
                if (q.includes('sprache')) {
                    return `Sprechen beide: ${answer1} 🗣️`;
                }
                return `Haben gemeinsam: ${answer1}`;
            }
            
            // Hobbies und Freizeitaktivitäten
            if (q.includes('hobby') || q.includes('freizeit') || q.includes('gerne')) {
                const hobbies1 = splitAndNormalize(a1);
                const hobbies2 = splitAndNormalize(a2);
                const common = findCommonHobbies(hobbies1, hobbies2);
                
                if (common.length > 0) {
                    return `Gemeinsame Interessen: ${common.join(', ')} 🎪`;
                } else {
                    return `${name1}: ${answer1} | ${name2}: ${answer2} - super Mix! 🌟`;
                }
            }
            
            // Interessen und Themen
            if (q.includes('interesse') || q.includes('thema')) {
                const interests1 = splitAndNormalize(a1);
                const interests2 = splitAndNormalize(a2);
                const common = findCommonInterests(interests1, interests2);
                
                if (common.length > 0) {
                    return `Gemeinsame Themen: ${common.join(', ')} 💬`;
                } else {
                    return `Verschiedene Perspektiven - perfekt zum Austauschen! 🔄`;
                }
            }
            
            // Berufliches
            if (q.includes('beruf') || q.includes('arbeit') || q.includes('job')) {
                if (findCareerSimilarity(a1, a2)) {
                    return `Ähnliche Bereiche - viel zu besprechen! 💼`;
                } else {
                    return `${name1}: ${answer1} | ${name2}: ${answer2} - unterschiedliche Welten! 🌍`;
                }
            }
            
            // Alter
            if (q.includes('alter') || q.includes('geburt')) {
                const age1 = extractNumber(answer1);
                const age2 = extractNumber(answer2);
                if (age1 && age2) {
                    const diff = Math.abs(age1 - age2);
                    if (diff <= 2) {
                        return `Fast gleich alt (${age1} & ${age2}) 👥`;
                    } else if (diff <= 5) {
                        return `Ähnliche Generation (${age1} & ${age2}) 👫`;
                    } else {
                        return `Verschiedene Generationen (${age1} & ${age2}) - interessant! 🔄`;
                    }
                }
            }
            
            // Default für andere Felder
            return '';
        }

        function findCommonHobbies(hobbies1, hobbies2) {
            const commonHobbies = [];
            const hobbyKeywords = {
                'sport': ['sport', 'fitness', 'laufen', 'joggen', 'gym', 'training'],
                'lesen': ['lesen', 'bücher', 'buch', 'literatur'],
                'musik': ['musik', 'konzert', 'singen', 'instrument'],
                'kochen': ['kochen', 'backen', 'küche', 'rezept'],
                'reisen': ['reisen', 'urlaub', 'länder', 'kultur'],
                'film': ['filme', 'kino', 'serie', 'netflix'],
                'natur': ['natur', 'wandern', 'spazieren', 'park']
            };
            
            Object.entries(hobbyKeywords).forEach(([category, keywords]) => {
                const found1 = hobbies1.some(h => keywords.some(k => h.includes(k)));
                const found2 = hobbies2.some(h => keywords.some(k => h.includes(k)));
                if (found1 && found2) {
                    commonHobbies.push(category);
                }
            });
            
            // Direkte Übereinstimmungen
            hobbies1.forEach(h1 => {
                hobbies2.forEach(h2 => {
                    if (h1.includes(h2) || h2.includes(h1) || h1 === h2) {
                        if (!commonHobbies.includes(h1)) {
                            commonHobbies.push(h1);
                        }
                    }
                });
            });
            
            return commonHobbies;
        }

        function findCommonInterests(interests1, interests2) {
            const common = [];
            const interestMap = {
                'politik': ['politik', 'gesellschaft', 'demokratie'],
                'technik': ['technik', 'computer', 'digital', 'technologie'],
                'kunst': ['kunst', 'museum', 'galerie', 'kreativ'],
                'wissenschaft': ['wissenschaft', 'forschung', 'studien']
            };
            
            Object.entries(interestMap).forEach(([category, keywords]) => {
                const found1 = interests1.some(i => keywords.some(k => i.includes(k)));
                const found2 = interests2.some(i => keywords.some(k => i.includes(k)));
                if (found1 && found2) {
                    common.push(category);
                }
            });
            
            return common;
        }

        function findCareerSimilarity(career1, career2) {
            const careerFields = {
                'it': ['it', 'computer', 'software', 'entwickler', 'programm'],
                'gesundheit': ['medizin', 'pflege', 'arzt', 'gesundheit', 'therapie'],
                'bildung': ['lehrer', 'schule', 'bildung', 'universität', 'student'],
                'sozial': ['sozial', 'beratung', 'hilfe', 'unterstützung']
            };
            
            for (const [field, keywords] of Object.entries(careerFields)) {
                const match1 = keywords.some(k => career1.includes(k));
                const match2 = keywords.some(k => career2.includes(k));
                if (match1 && match2) return true;
            }
            
            return false;
        }

        function findCommonalities(profile1, profile2) {
            console.log('🔍 Analysiere Gemeinsamkeiten zwischen:', profile1.name, 'und', profile2.name);

            const commonalities = [];

            // Definiere Sortier-Priorität für Felder
            const fieldPriority = {
                // Basis-Infos zuerst
                'Vorname': 1, 'Nachname': 2, 'Alter': 3, 'Geschlecht': 4,
                'Standort': 5, 'Postleitzahl': 6, 'Region': 7,

                // Kontakt
                'E-Mail-Adresse': 10, 'Telefonnummer': 11,

                // Wichtige Matching-Felder
                'Welche Sprachen sprichst du?': 20, 'Hobbys': 21,
                'Was machst du gerade im Leben?': 22, 'Branche': 23,
                'In welchem Land bist du geboren?': 24,
                'Bist du in Deutschland geboren?': 25,
                'Seit wann lebst du in Deutschland?': 26,

                // Tandem-spezifisch
                'Warum möchtest du bei SwaF mitmachen?': 30,
                'Was ist dir in einer Freundschaft besonders wichtig?': 31,
                'Wann hast du Zeit dich mit deinem Tandem zu treffen?': 32,
                'Wie groß darf der Altersunterschied sein?': 33,
                'Geschlecht der Tandempartner*in': 34,
                'Wie lange kannst du anreisen um dich mit deinem Tandem zu treffen?': 35,
                'Wie bewegst du dich in der Stadt?': 36,

                // Sonstige (niedrige Priorität)
                'Gruppe': 100, 'Vermittler*in': 101, 'Status': 102,
                'Terminart': 103, 'Durchgeführt von': 104
            };

            // Sammle alle Fragen und normalisiere sie für bessere Zuordnung
            const questionMap = new Map(); // normalisiert -> original
            const allQuestions = new Set();

            profile1.fields.forEach(f => {
                const normalized = normalizeQuestion(f.question);
                if (!questionMap.has(normalized)) {
                    questionMap.set(normalized, f.question);
                    allQuestions.add(f.question);
                }
            });

            profile2.fields.forEach(f => {
                const normalized = normalizeQuestion(f.question);
                if (!questionMap.has(normalized)) {
                    questionMap.set(normalized, f.question);
                    allQuestions.add(f.question);
                }
            });

            console.log(`📊 Gefunden: ${allQuestions.size} einzigartige Fragen nach Normalisierung`);

            console.log('📊 Anzahl einzigartige Fragen:', allQuestions.size);

            // Konvertiere zu Array und sortiere nach Priorität
            const sortedQuestions = Array.from(allQuestions).sort((a, b) => {
                const priorityA = fieldPriority[a] || 999;
                const priorityB = fieldPriority[b] || 999;

                if (priorityA !== priorityB) {
                    return priorityA - priorityB;
                }

                // Bei gleicher Priorität alphabetisch sortieren
                return a.localeCompare(b);
            });

            sortedQuestions.forEach(question => {
                const normalizedQuestion = normalizeQuestion(question);
                
                // Überspringe Fragen, die nicht für Matching geeignet sind
                if (shouldExcludeFromMatching(question)) {
                    console.log(`⏭️ Überspringe Matching für: "${question}" (in Ausschlussliste)`);
                    
                    // Füge trotzdem zur Übersicht hinzu, aber ohne Gemeinsamkeiten-Analyse
                    const field1 = profile1.fields.find(f => normalizeQuestion(f.question) === normalizedQuestion);
                    const field2 = profile2.fields.find(f => normalizeQuestion(f.question) === normalizedQuestion);
                    const displayQuestion = field1?.question || field2?.question || question;
                    
                    commonalities.push({
                        question: displayQuestion,
                        answer1: field1 ? field1.answer : '',
                        answer2: field2 ? field2.answer : '',
                        commonality: '' // Bewusst leer für ausgeschlossene Felder
                    });
                    return; // Überspringe den Rest der Matching-Logik
                }
                
                // Finde Felder mit normalisierter Frage (berücksichtigt Variationen)
                const field1 = profile1.fields.find(f => normalizeQuestion(f.question) === normalizedQuestion);
                const field2 = profile2.fields.find(f => normalizeQuestion(f.question) === normalizedQuestion);
                
                // Verwende die Hauptversion der Frage für die Anzeige
                const displayQuestion = field1?.question || field2?.question || question;

                const answer1 = field1 ? field1.answer : '';
                const answer2 = field2 ? field2.answer : '';

                let commonality = '';

                // Prüfe Gemeinsamkeiten nur wenn beide Antworten haben
                if (answer1 && answer2) {
                    // Für Listen-Felder (Hobbys, Sprachen, etc.) mit intelligenter Synonymerkennung
                    if (question.toLowerCase().includes('hobby') ||
                        question.toLowerCase().includes('sprache') ||
                        question.toLowerCase().includes('interesse')) {

                        // Hobby-Synonyme für besseren Abgleich
                        const hobbyMappings = {
                            'feiern': ['feiern gehen', 'ausgehen', 'party'],
                            'feiern gehen': ['feiern', 'ausgehen', 'party'],
                            'freunde treffen': ['leute treffen', 'soziale kontakte', 'gesellschaft'],
                            'leute treffen': ['freunde treffen', 'soziale kontakte', 'gesellschaft'],
                            'handwerkliche tätigkeiten': ['handwerk', 'basteln', 'diy'],
                            'it/technik': ['technik', 'computer', 'technologie'],
                            'kino': ['ins kino gehen', 'filme schauen', 'film'],
                            'ins kino gehen': ['kino', 'filme schauen', 'film'],
                            'kochen': ['gemeinsam kochen', 'kulinarik', 'essen zubereiten'],
                            'gemeinsam kochen': ['kochen', 'kulinarik', 'essen zubereiten'],
                            'konzerte': ['konzerte besuchen', 'livemusik', 'musik live'],
                            'konzerte besuchen': ['konzerte', 'livemusik', 'musik live'],
                            'kultur/museum/theater': ['ins museum oder theater gehen', 'kulturveranstaltungen', 'museum', 'theater'],
                            'ins museum oder theater gehen': ['kultur/museum/theater', 'kulturveranstaltungen', 'museum', 'theater'],
                            'literatur': ['lesen', 'bücher', 'literatur'],
                            'lesen': ['literatur', 'bücher'],
                            'politik und gesellschaft': ['über politik und gesellschaft sprechen', 'politische diskussionen'],
                            'über politik und gesellschaft sprechen': ['politik und gesellschaft', 'politische diskussionen'],
                            'wandern und natur': ['wandern', 'natur', 'outdoor'],
                            'serien und filme zu hause schauen': ['filme schauen', 'serien', 'netflix'],
                            'gesellschaftsspiele/brettspiele': ['brettspiele', 'spiele', 'gaming']
                        };

                        function normalizeHobby(hobby) {
                            const normalized = hobby.trim().toLowerCase();
                            // Entferne häufige Zusätze
                            return normalized
                                .replace(/\s*(gehen|besuchen|schauen|sprechen)\s*$/, '')
                                .replace(/^(gemeinsam|ins?)\s+/, '')
                                .trim();
                        }

                        function findHobbyMatches(item1, item2) {
                            const norm1 = normalizeHobby(item1);
                            const norm2 = normalizeHobby(item2);

                            // Exakte Übereinstimmung
                            if (norm1 === norm2) return true;

                            // Substring-Übereinstimmung
                            if (norm1.includes(norm2) || norm2.includes(norm1)) return true;

                            // Synonym-Überprüfung
                            const synonyms1 = hobbyMappings[norm1] || [];
                            const synonyms2 = hobbyMappings[norm2] || [];

                            if (synonyms1.some(syn => syn === norm2 || norm2.includes(syn))) return true;
                            if (synonyms2.some(syn => syn === norm1 || norm1.includes(syn))) return true;

                            return false;
                        }

                        const items1 = answer1.split(/[,;]/).map(s => s.trim()).filter(s => s.length > 0);
                        const items2 = answer2.split(/[,;]/).map(s => s.trim()).filter(s => s.length > 0);
                        const commonItems = [];

                        items1.forEach(item1 => {
                            items2.forEach(item2 => {
                                if (findHobbyMatches(item1, item2)) {
                                    // Verwende die längere/spezifischere Version
                                    const betterItem = item1.length >= item2.length ? item1 : item2;
                                    if (!commonItems.some(existing => findHobbyMatches(existing, betterItem))) {
                                        commonItems.push(betterItem);
                                    }
                                }
                            });
                        });

                        if (commonItems.length > 0) {
                            if (commonItems.length === 1) {
                                commonality = `Gemeinsames Hobby: ${commonItems[0]}! Das verbindet sofort 🎯`;
                            } else if (commonItems.length <= 3) {
                                commonality = `${commonItems.length} gemeinsame Hobbys: ${commonItems.join(', ')}! Perfekte Basis 🎨`;
                            } else {
                                commonality = `Viele gemeinsame Hobbys: ${commonItems.slice(0, 3).join(', ')} und mehr! Ihr werdet viel Spaß haben 🎉`;
                            }
                        }
                    }
                    // Für exakte Übereinstimmungen
                    else if (answer1.toLowerCase().trim() === answer2.toLowerCase().trim()) {
                        commonality = answer1;
                    }
                    // Für Alters-Ähnlichkeit
                    else if (question.toLowerCase().includes('alter')) {
                        const age1 = parseInt(answer1);
                        const age2 = parseInt(answer2);
                        if (!isNaN(age1) && !isNaN(age2)) {
                            const diff = Math.abs(age1 - age2);
                            if (diff <= 5) {
                                commonality = `Ihr seid etwa gleich alt (${diff} Jahre Unterschied)`;
                            }
                        }
                    }
                    // Für PLZ-basierte Entfernungsberechnung
                    else if (question.toLowerCase().includes('postleitzahl') || question.toLowerCase().includes('plz')) {
                        const plz1 = extractPLZ(answer1);
                        const plz2 = extractPLZ(answer2);

                        if (plz1 && plz2) {
                            // Verwende Promise für async Berechnung
                            calculatePLZDistanceAdvanced(plz1, plz2).then(result => {
                                if (result && result.distance !== null) {
                                    let commonalityText = '';
                                    if (result.distance === 0) {
                                        commonalityText = 'Ihr wohnt in derselben PLZ';
                                    } else {
                                        // Verbesserte Texte mit Links
                                        const routingInfo = result.routingInfo === 'Echte Routing-Distanz' ? '🎯' : '📏';
                                        
                                        if (result.type === 'very_close') {
                                            commonalityText = `${routingInfo} Sehr nah: ${result.distance}km (🚲 ${result.estimatedTimes.cycling}min, 🚌 ${result.estimatedTimes.transit}min)`;
                                        } else if (result.type === 'close') {
                                            commonalityText = `${routingInfo} Nah: ${result.distance}km (🚌 ${result.estimatedTimes.transit}min, 🚗 ${result.estimatedTimes.driving}min)`;
                                        } else if (result.type === 'medium') {
                                            commonalityText = `${routingInfo} Erreichbar: ${result.distance}km (🚌 ${result.estimatedTimes.transit}min, 🚗 ${result.estimatedTimes.driving}min)`;
                                        } else if (result.type === 'far') {
                                            commonalityText = `${routingInfo} Weiter entfernt: ${result.distance}km (🚗 ${result.estimatedTimes.driving}min)`;
                                        }
                                        
                                        // Füge Maps-Link-Info hinzu
                                        commonalityText += ` | 🗺️ Navigation: Google Maps, ÖPNV`;
                                    }

                                    // Aktualisiere die Gemeinsamkeit in der bereits erstellten Liste
                                    const existingEntry = commonalities.find(c => c.question === question);
                                    if (existingEntry) {
                                        existingEntry.commonality = commonalityText;
                                        // Speichere Maps-Links für späteren Zugriff
                                        existingEntry.mapsLinks = result.mapsLinks;
                                    }
                                }
                            });

                            // Sofortige Luftlinien-Berechnung als Fallback
                            const coords1Cache = plzCache[plz1];
                            const coords2Cache = plzCache[plz2];

                            if (coords1Cache && coords2Cache) {
                                const airDistance = calculateHaversineDistance(
                                    coords1Cache[0], coords1Cache[1],
                                    coords2Cache[0], coords2Cache[1]
                                );
                                const estimatedDistance = Math.round(airDistance * 1.3);
                                
                                if (estimatedDistance <= 10) {
                                    commonality = `Sehr nah: ca. ${estimatedDistance}km - quasi Nachbarn! 🏠`;
                                } else if (estimatedDistance <= 25) {
                                    commonality = `Gute Erreichbarkeit: ca. ${estimatedDistance}km mit ÖPNV 🚋`;
                                } else if (estimatedDistance <= 50) {
                                    commonality = `Regionale Nähe: ca. ${estimatedDistance}km - gut machbar 📍`;
                                } else {
                                    commonality = `Weitere Entfernung: ca. ${estimatedDistance}km - aber zu schaffen 🗺️`;
                                }
                            } else {
                                commonality = 'Distanz wird berechnet... 🗺️';
}
                        }
                    }
                    // Für Wohnort/Standort-Felder
                    else if (question.toLowerCase().includes('wohnort') ||
                        question.toLowerCase().includes('standort') ||
                        question.toLowerCase().includes('ort')) {

                        // Erst nach exakter Übereinstimmung suchen
                        if (answer1.toLowerCase().trim() === answer2.toLowerCase().trim()) {
                            commonality = answer1;
                        } else {
                            // Dann nach PLZ in den Antworten suchen
                            const plz1 = extractPLZ(answer1);
                            const plz2 = extractPLZ(answer2);
                            if (plz1 && plz2) {
                                calculatePLZDistanceAdvanced(plz1, plz2).then(result => {
                                    if (result && result.distance !== null && result.distance <= 50) {
                                        const distance = result.distance;
                                        if (distance === 0) {
                                            commonality = 'Gleiche PLZ';
                                        } else if (distance <= 10) {
                                            commonality = `Nahegelegene Orte (ca. ${distance} km)`;
                                        } else if (distance <= 25) {
                                            commonality = `Gleiche Region (ca. ${distance} km)`;
                                        } else {
                                            commonality = `Ähnliche Region (ca. ${distance} km)`;
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
                // Füge ALLE Fragen hinzu (wichtig für vollständige Übersicht)
                // ABER: Verwende intelligente Analyse für bessere Texte
                let finalCommonality = commonality;

                // Intelligente Texterstellung für geeignete Felder
                if (!shouldExcludeFromMatching(question) && answer1 && answer2) {
                    const intelligentText = generateSmartCommonalityText(question, answer1, answer2, profile1, profile2);
                    if (intelligentText && intelligentText.length > 0) {
                        finalCommonality = intelligentText;
                        console.log(`🧠 Intelligente Analyse für "${displayQuestion}": "${intelligentText}"`);
                    }
                }

                commonalities.push({
                    question: displayQuestion,
                    answer1: answer1,
                    answer2: answer2,
                    commonality: finalCommonality
                });
            });

            console.log('📋 Gemeinsamkeiten gefunden:', commonalities.filter(c => c.commonality).length, 'von', commonalities.length);
            return commonalities;
        }

        function updateMatchedPairs() {
            console.log('🔄 Aktualisiere Tandem-Liste...');
            console.log('📊 Anzahl Tandems:', tandems.length);

            const container = document.getElementById('matched-pairs');
            const tandemCountElement = document.getElementById('tandem-count');
            const removePairBtn = document.getElementById('remove-pair-btn');

            // Update Counter
            if (tandemCountElement) {
                tandemCountElement.textContent = tandems.length;
            }

            if (tandems.length === 0) {
                container.innerHTML = '<li style="padding: 1rem; text-align: center; color: var(--swaf-dark-gray); font-style: italic;">Noch keine Tandems erstellt.</li>';
                if (removePairBtn) removePairBtn.disabled = true;
                return;
            }

            try {
                container.innerHTML = tandems.map((tandem, index) => {
                    const isSelected = selectedTandemPairId == tandem.id; 
                    const selectedClass = isSelected ? 'selected' : '';

                    return `
                        <li class="matched-pair ${selectedClass}" onclick="selectTandemPair('${tandem.id}')" data-tandem-id="${tandem.id}">
                            <div style="flex: 1;">
                                <strong>${tandem.name}</strong>
                                <div style="font-size: 0.8rem; color: var(--swaf-dark-gray); margin-top: 0.2rem;">
                                    ${tandem.commonalities.filter(c => c.commonality).length} Gemeinsamkeiten
                                    ${tandem.autoMatch ? ' • Auto-Match' : ''}
                                    ${isSelected ? ' • Ausgewählt' : ''}
                                </div>
                            </div>
                            <button onclick="event.stopPropagation(); removeTandem('${tandem.id}')" 
                                    class="btn btn-outline btn-small" 
                                    style="margin-left: 1rem;">
                                🗑️
                            </button>
                        </li>
                    `;
                }).join('');

                console.log('✅ Tandem-Liste erfolgreich aktualisiert');

                if (removePairBtn) removePairBtn.disabled = false;

            } catch (error) {
                console.error('❌ Fehler beim Aktualisieren der Tandem-Liste:', error);
                container.innerHTML = `
                    <li style="padding: 1rem;">
                        <div class="alert alert-error">
                            Fehler beim Laden der Tandems: ${error.message}
                            <button onclick="updateMatchedPairs()" class="btn btn-outline btn-small" style="margin-top: 0.5rem;">🔄 Erneut versuchen</button>
                        </div>
                    </li>
                `;
            }
        }

        // ===============================
        // UI-UPDATE-FUNKTIONEN  
        // ===============================
        function updateUI() {
            updateCollectedProfiles();
            updateStatistics();
            updateProfileCounts();
        }

        function updateCollectedProfiles() {
            const container = document.getElementById('collected-profiles-display');

            if (profiles.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--swaf-dark-gray); font-style: italic;">
                        <p>Noch keine Profile gesammelt.</p>
                        <p>Verwende das Bookmarklet, um Profile aus dem Portal zu sammeln!</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                    <h4 style="color: var(--swaf-teal); margin-bottom: 0.5rem;">✅ Gesammelte Profile (${profiles.length}):</h4>
                    <div style="max-height: 200px; overflow-y: auto;">
                        ${profiles.map((profile, index) => `
                            <div style="background: white; padding: 0.75rem; margin: 0.5rem 0; border-radius: 4px; border: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: var(--swaf-red);">${index + 1}. ${profile.name}</strong><br>
                                    <small style="color: var(--swaf-dark-gray);">
                                        ${profile.fields.length} Felder${profile.pageType ? ' • ' + profile.pageType : ''} • ${new Date(profile.timestamp).toLocaleString('de-DE')}
                                    </small>
                                </div>
                                <button onclick="removeProfile('${profile.id}')" 
                                        style="background: var(--swaf-red); color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 3px; cursor: pointer;">
                                    ❌
                                </button>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function updateProfileCounts() {
            document.getElementById('profile-count').textContent = profiles.length;
            document.getElementById('profile-count-btn').textContent = profiles.length;

            const continueBtn = document.getElementById('continue-btn');
            if (profiles.length > 0) {
                continueBtn.style.display = 'inline-block';
                updateProgress('download-progress', Math.min((profiles.length / 5) * 100, 100));
            } else {
                continueBtn.style.display = 'none';
                updateProgress('download-progress', 0);
            }
        }

        function updateStatistics() {
            document.getElementById('stats-profiles').textContent = profiles.length;
            document.getElementById('stats-tandems').textContent = tandems.length;

            const avgFields = profiles.length > 0
                ? Math.round(profiles.reduce((sum, p) => sum + p.fields.length, 0) / profiles.length)
                : 0;
            document.getElementById('stats-fields').textContent = avgFields;
        }

        function showNotification(message, type = 'info', duration = 5000) {
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(n => n.remove());

            const notification = document.createElement('div');
            notification.className = 'notification';

            const bgColors = {
                info: 'var(--swaf-teal)',
                success: '#28a745',
                warning: '#ffc107',
                error: 'var(--swaf-red)'
            };

            notification.style.background = bgColors[type] || bgColors.info;
            notification.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>${message}</span>
                    <button onclick="this.closest('.notification').remove()" style="background: none; border: none; color: white; font-size: 1.2rem; cursor: pointer; margin-left: 1rem;">×</button>
                </div>
            `;

            document.body.appendChild(notification);

            if (duration > 0) {
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, duration);
            }
        }

        function updateStatus(message) {
            document.getElementById('status-text').textContent = message;
            console.log('Status:', message);
        }

        function updateProgress(elementId, percentage) {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.width = percentage + '%';
            }
        }

        // ===============================
        // WEITERE MATCHING-FUNKTIONEN
        // ===============================
        function selectTandemPair(tandemId) {
            console.log('🎯 Tandem-Paar auswählen:', tandemId);

            // Entferne vorherige Auswahl
            document.querySelectorAll('.matched-pair.selected').forEach(el => {
                el.classList.remove('selected');
            });

            // Wähle neues Paar aus
            const element = document.querySelector(`[data-tandem-id="${tandemId}"]`);
            if (element) {
                element.classList.add('selected');
                selectedTandemPairId = tandemId;

                const removePairBtn = document.getElementById('remove-pair-btn');
                if (removePairBtn) {
                    removePairBtn.disabled = false;
                    removePairBtn.textContent = '🗑️ Ausgewähltes Paar entfernen';
                }
            }
        }

        function removeTandem(tandemId) {
            console.log('🗑️ Entferne Tandem mit ID:', tandemId);

            const tandemToRemove = tandems.find(t => t.id == tandemId);
            if (!tandemToRemove) {
                console.error('❌ Tandem nicht gefunden:', tandemId);
                showNotification('❌ Tandem nicht gefunden', 'error');
                return;
            }

            if (confirm(`Tandem "${tandemToRemove.name}" wirklich entfernen?`)) {
                console.log('✅ Entferne Tandem:', tandemToRemove.name);

                tandems = tandems.filter(t => t.id != tandemId);
                saveTandems();
                updateMatchedPairs();
                updateStatistics();

                // Aktualisiere verfügbare Profile
                loadAvailableProfiles();

                // Reset Auswahl wenn das entfernte Tandem ausgewählt war
                if (selectedTandemPairId == tandemId) {
                    selectedTandemPairId = null;
                    const removePairBtn = document.getElementById('remove-pair-btn');
                    if (removePairBtn) {
                        removePairBtn.disabled = true;
                        removePairBtn.textContent = '🗑️ Ausgewähltes Paar entfernen';
                    }
                }

                showNotification(`✅ Tandem "${tandemToRemove.name}" entfernt`, 'success');
                updateStatus(`Tandem "${tandemToRemove.name}" entfernt`);
            }
        }

        function removeSelectedPair() {
            console.log('🗑️ Entferne ausgewähltes Tandem-Paar. Ausgewählt:', selectedTandemPairId);

            if (!selectedTandemPairId) {
                showNotification('⚠️ Bitte wähle zuerst ein Tandem-Paar aus, indem du es in der Liste anklickst.', 'warning', 4000);
                return;
            }

            removeTandem(selectedTandemPairId);
        }

        function clearProfileSelection() {
            console.log('🗑️ Lösche Profile-Auswahl...');
            console.log('📋 Auswahl vor Löschung:', selectedProfiles);

            // Setze Arrays zurück
            selectedProfiles = [];
            selectedTandemPairId = null;

            // Entferne visuelle Auswahl von Profilen
            document.querySelectorAll('.profile-item.selected').forEach((el, index) => {
                console.log(`➖ Entferne Auswahl von Profil ${index + 1}`);
                el.classList.remove('selected');
            });

            // Entferne visuelle Auswahl von Tandems
            document.querySelectorAll('.matched-pair.selected').forEach(el => {
                el.classList.remove('selected');
            });

            // Update UI-Status
            updateMatchingStatus();

            console.log('✅ Auswahl erfolgreich gelöscht. Neue Auswahl:', selectedProfiles);
            showNotification('✅ Auswahl gelöscht', 'success', 2000);
        }

        function clearAllTandems() {
            if (tandems.length === 0) {
                showNotification('Keine Tandems zum Löschen vorhanden.', 'warning');
                return;
            }

            if (confirm(`Wirklich alle ${tandems.length} Tandems löschen? Diese Aktion kann nicht rückgängig gemacht werden!`)) {
                tandems = [];
                saveTandems();
                updateMatchedPairs();
                updateStatistics();

                // Profile wieder verfügbar machen
                loadAvailableProfiles();

                showNotification('✅ Alle Tandems gelöscht', 'success');
                updateStatus('Alle Tandems gelöscht');
            }
        }

        function filterProfiles() {
            const search = document.getElementById('profile-search').value.toLowerCase();
            const profileItems = document.querySelectorAll('.profile-item');

            profileItems.forEach(item => {
                const name = item.textContent.toLowerCase();
                item.style.display = name.includes(search) ? 'block' : 'none';
            });
        }

        function suggestAutoMatches() {
            if (profiles.length < 2) {
                showNotification('Mindestens 2 Profile benötigt für Auto-Matching.', 'warning');
                return;
            }

            updateStatus('Auto-Matching wird berechnet...');

            setTimeout(() => {
                const suggestions = [];

                for (let i = 0; i < profiles.length; i++) {
                    for (let j = i + 1; j < profiles.length; j++) {
                        const commonalities = findCommonalities(profiles[i], profiles[j]);
                        const score = commonalities.filter(c => c.commonality).length;

                        if (score > 0) {
                            suggestions.push({
                                profile1: profiles[i],
                                profile2: profiles[j],
                                score: score,
                                commonalities: commonalities
                            });
                        }
                    }
                }

                suggestions.sort((a, b) => b.score - a.score);

                if (suggestions.length > 0) {
                    showAutoMatchModal(suggestions.slice(0, 5));
                } else {
                    showNotification('Keine geeigneten Matches gefunden.', 'warning');
                }

                updateStatus('Auto-Matching abgeschlossen');
            }, 1000);
        }

        function showAutoMatchModal(suggestions) {
            const modal = createModal('🎯 Auto-Match Vorschläge', `
                <p style="margin-bottom: 1.5rem;">Basierend auf Gemeinsamkeiten wurden folgende Tandems vorgeschlagen:</p>
                
                <div id="suggestion-list">
                    ${suggestions.map((suggestion, index) => `
                        <div style="border: 2px solid #ddd; padding: 1rem; margin: 0.5rem 0; border-radius: 6px;">
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="checkbox" value="${index}" style="margin-right: 1rem; margin-top: 0.2rem;">
                                <div style="flex: 1;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                        <strong>${suggestion.profile1.name} & ${suggestion.profile2.name}</strong>
                                        <span style="background: var(--swaf-teal); color: white; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.9rem;">
                                            ${suggestion.score} Gemeinsamkeiten
                                        </span>
                                    </div>
                                    <div style="font-size: 0.9rem; color: var(--swaf-dark-gray);">
                                        ${suggestion.commonalities.filter(c => c.commonality).slice(0, 3).map(c =>
                    `• ${c.question}: ${c.commonality}`
                ).join('<br>')}
                                    </div>
                                </div>
                            </label>
                        </div>
                    `).join('')}
                </div>
            `, [
                {
                    text: 'Alle auswählen', class: 'btn-outline btn-small', action: function() {
                        document.querySelectorAll('#suggestion-list input[type=checkbox]').forEach(cb => cb.checked = true);
                    }
                },
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Ausgewählte anwenden', class: 'btn-primary', action: function() { applyAutoMatches(suggestions); } }
            ]);
        }

        function applyAutoMatches(suggestions) {
            const checkboxes = document.querySelectorAll('#suggestion-list input[type="checkbox"]:checked');
            let applied = 0;

            checkboxes.forEach(checkbox => {
                const index = parseInt(checkbox.value);
                const suggestion = suggestions[index];

                if (suggestion) {
                    const tandem = {
                        id: Date.now() + Math.random() + applied,
                        profile1: suggestion.profile1,
                        profile2: suggestion.profile2,
                        name: `${suggestion.profile1.name} & ${suggestion.profile2.name}`,
                        created: new Date().toISOString(),
                        commonalities: suggestion.commonalities,
                        autoMatch: true
                    };

                    tandems.push(tandem);
                    applied++;
                }
            });

            if (applied > 0) {
                saveTandems();
                updateMatchedPairs();
                updateStatistics();
                showNotification(`✅ ${applied} Auto-Matches erfolgreich angewendet`, 'success');
            }

            closeModal();
        }

        // ===============================
        // FRAGEN-DEDUPLIZIERUNG (VOR loadFieldSelection!)
        // ===============================

        function findSimilarQuestions(questions) {
            const groups = [];
            const used = new Set();
            
            questions.forEach((question, index) => {
                if (used.has(index)) return;
                
                const normalized = normalizeQuestion(question);
                const group = [question];
                used.add(index);
                
                // Finde ähnliche Fragen
                questions.forEach((otherQuestion, otherIndex) => {
                    if (otherIndex === index || used.has(otherIndex)) return;
                    
                    const otherNormalized = normalizeQuestion(otherQuestion);
                    
                    // Prüfe verschiedene Ähnlichkeitskriterien
                    if (areQuestionsSimilar(normalized, otherNormalized)) {
                        group.push(otherQuestion);
                        used.add(otherIndex);
                    }
                });
                
                groups.push(group);
            });
            
            return groups;
        }

        function areQuestionsSimilar(q1, q2) {
            // Exakte Übereinstimmung nach Normalisierung
            if (q1 === q2) return true;
            
            // Sehr hohe Wortübereinstimmung (90%+)
            const words1 = q1.split(' ').filter(w => w.length > 2);
            const words2 = q2.split(' ').filter(w => w.length > 2);
            
            if (words1.length === 0 || words2.length === 0) return false;
            
            const commonWords = words1.filter(w => words2.includes(w));
            const similarity = (commonWords.length * 2) / (words1.length + words2.length);
            
            // 90% Ähnlichkeit oder mehr
            if (similarity >= 0.9) {
                console.log(`🔍 Ähnliche Fragen erkannt (${Math.round(similarity*100)}%): "${q1}" ↔ "${q2}"`);
                return true;
            }
            
            return false;
        }

        // ===============================
        // FELD-AUSWAHL
        // ===============================
        function loadFieldSelection() {
            const container = document.getElementById('field-selection');

            if (profiles.length === 0) {
                container.innerHTML = '<p>Keine Profile verfügbar. Bitte zuerst Profile sammeln.</p>';
                return;
            }

            const allFields = new Set();
            profiles.forEach(profile => {
                profile.fields.forEach(field => {
                    allFields.add(field.question);
                });
            });

            const excludeFields = [
                'Nachname', 'E-Mail-Adresse', 'Telefonnummer', 'Status',
                'Terminart', 'Durchgeführt von', 'Datum/Uhrzeit', 'Gruppe',
                'Standort-Newsletter', 'Vermittler*in'
            ];

            // Gruppiere ähnliche Fragen und wähle Hauptvariante
            const questionGroups = findSimilarQuestions(Array.from(allFields));
            const deduplicatedFields = questionGroups.map(group => {
                if (group.length === 1) return group[0];
                
                // Wähle die häufigste oder kürzeste Variante als Hauptfrage
                const fieldCounts = group.map(field => ({
                    field: field,
                    count: profiles.reduce((count, profile) => 
                        count + (profile.fields.some(f => f.question === field) ? 1 : 0), 0
                    )
                }));
                
                // Sortiere nach Häufigkeit, dann nach Kürze
                fieldCounts.sort((a, b) => {
                    if (b.count !== a.count) return b.count - a.count;
                    return a.field.length - b.field.length;
                });
                
                const mainField = fieldCounts[0].field;
                console.log(`📝 Hauptfrage gewählt: "${mainField}" (aus ${group.length} Varianten)`);
                
                return mainField;
            });

            // Sortiere deduplizierte Felder alphabetisch
            const sortedFields = deduplicatedFields.sort();

            // Initialisiere selectedFields falls leer
            if (selectedFields.length === 0) {
                selectedFields = sortedFields.filter(field => !excludeFields.includes(field));
                localStorage.setItem('swaf_selected_fields', JSON.stringify(selectedFields));
            }

            container.innerHTML = `
                <div style="margin-bottom: 1rem; background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px;">
                    <h4 style="margin-top: 0; color: var(--swaf-teal);">📊 Feld-Statistiken:</h4>
                    <p style="margin: 0.5rem 0;">
                        <strong>Gesamt:</strong> ${sortedFields.length} verschiedene Felder gefunden<br>
                        <strong>Ausgewählt:</strong> <span id="selected-fields-count">${selectedFields.length}</span> Felder<br>
                        <strong>Automatisch ausgeschlossen:</strong> ${excludeFields.length} Felder (sensible Daten)
                    </p>
                </div>
                
                ${sortedFields.map(field => {
                    const isSelected = selectedFields.includes(field);
                    const isExcluded = excludeFields.includes(field);
                    const fieldCount = profiles.reduce((count, profile) => 
                        count + (profile.fields.some(f => f.question === field) ? 1 : 0), 0
                    );

                    return `
                        <div style="display: flex; align-items: center; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; margin: 0.3rem 0; ${isExcluded ? 'background: #f0f0f0; opacity: 0.7;' : ''}">
                            <input type="checkbox" 
                                id="field-${field.replace(/[^a-zA-Z0-9]/g, '_')}" 
                                ${isSelected ? 'checked' : ''} 
                                ${isExcluded ? 'disabled' : ''}
                                onchange="toggleField('${field.replace(/'/g, "\\'")}')" 
                                style="margin-right: 0.75rem; transform: scale(1.2);">
                            <div style="flex: 1;">
                                <label for="field-${field.replace(/[^a-zA-Z0-9]/g, '_')}" style="margin: 0; cursor: pointer;">
                                    <strong>${field}</strong>
                                    ${isExcluded ? '<em style="color: var(--swaf-red);"> (Automatisch ausgeschlossen)</em>' : ''}
                                </label>
                                <div style="font-size: 0.8rem; color: var(--swaf-dark-gray); margin-top: 0.2rem;">
                                    In ${fieldCount} von ${profiles.length} Profilen vorhanden
                                </div>
                            </div>
                        </div>
                    `;
                }).join('')}
            `;
            
            console.log('📊 Feld-Auswahl geladen:', selectedFields.length, 'von', sortedFields.length, 'Feldern ausgewählt');
        }

        function toggleField(field) {
            console.log('🔧 Toggle Feld:', field);
            
            if (selectedFields.includes(field)) {
                selectedFields = selectedFields.filter(f => f !== field);
                console.log('➖ Feld entfernt:', field);
            } else {
                selectedFields.push(field);
                console.log('➕ Feld hinzugefügt:', field);
            }
            
            localStorage.setItem('swaf_selected_fields', JSON.stringify(selectedFields));
            
            // Update Counter
            const counter = document.getElementById('selected-fields-count');
            if (counter) {
                counter.textContent = selectedFields.length;
            }
            
            console.log('✅ Neue Auswahl:', selectedFields.length, 'Felder');
        }

        function toggleField(field) {
            if (selectedFields.includes(field)) {
                selectedFields = selectedFields.filter(f => f !== field);
            } else {
                selectedFields.push(field);
            }
            localStorage.setItem('swaf_selected_fields', JSON.stringify(selectedFields));
        }

        function selectAllFields(select) {
            const checkboxes = document.querySelectorAll('#field-selection input[type="checkbox"]');
            selectedFields = [];

            checkboxes.forEach(checkbox => {
                checkbox.checked = select;
                if (select) {
                    const field = checkbox.id.replace('field-', '');
                    selectedFields.push(field);
                }
            });

            localStorage.setItem('swaf_selected_fields', JSON.stringify(selectedFields));
        }

        // ===============================
        // BEARBEITUNGS-FUNKTIONEN
        // ===============================
        function loadTandemSelector() {
            const selector = document.getElementById('tandem-selector');

            selector.innerHTML = '<option value="">-- Tandem auswählen --</option>' +
                tandems.map(tandem => `<option value="${tandem.id}">${tandem.name}</option>`).join('');
        }

        function loadTandemForEditing() {
            const tandemId = document.getElementById('tandem-selector').value;
            if (!tandemId) {
                document.getElementById('tandem-editor').classList.add('hidden');
                return;
            }

            currentTandem = tandems.find(t => t.id == tandemId);
            if (!currentTandem) return;

            document.getElementById('tandem-editor').classList.remove('hidden');

            const tbody = document.querySelector('#tandem-table tbody');
            tbody.innerHTML = '';

            // Filtere nach ausgewählten Feldern
            const filteredCommonalities = currentTandem.commonalities.filter(c => {
                // Wenn keine Felder ausgewählt, zeige alle
                if (selectedFields.length === 0) return true;
                
                // Zeige nur Felder, die in der Auswahl enthalten sind
                return selectedFields.includes(c.question);
            });

            console.log(`📊 Zeige ${filteredCommonalities.length} von ${currentTandem.commonalities.length} Feldern (basierend auf Feldauswahl)`);

            filteredCommonalities.forEach(c => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${c.question}</td>
                    <td contenteditable="true">${c.answer1}</td>
                    <td contenteditable="true">${c.answer2}</td>
                    <td contenteditable="true" 
                        style="background: var(--swaf-lightest-teal); cursor: text;" 
                        title="Klick hier für passende Formulierungsvorschläge"
                        onfocus="handleCellFocus(this)">${c.commonality}</td>
                    <td>
                        <button onclick="deleteRow(this)" class="btn btn-outline btn-small">🗑️</button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            // Info-Hinweis wenn Felder gefiltert wurden
            if (filteredCommonalities.length < currentTandem.commonalities.length) {
                const infoRow = document.createElement('tr');
                infoRow.innerHTML = `
                    <td colspan="5" style="text-align: center; padding: 1rem; background: var(--swaf-lightest-red); color: var(--swaf-red); font-style: italic;">
                        📊 ${currentTandem.commonalities.length - filteredCommonalities.length} Felder durch Feldkonfiguration ausgeblendet. 
                        <button onclick="showAllFields()" class="btn btn-outline btn-small" style="margin-left: 1rem;">Alle anzeigen</button>
                    </td>
                `;
                tbody.appendChild(infoRow);
            }
        }

        function deleteRow(button) {
            if (confirm('Zeile wirklich löschen?')) {
                button.closest('tr').remove();
            }
        }

        function saveTandemSilently() {
            if (!currentTandem) return false;

            const rows = document.querySelectorAll('#tandem-table tbody tr');
            const updatedCommonalities = [];

            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 4) {
                    updatedCommonalities.push({
                        question: cells[0].textContent,
                        answer1: cells[1].textContent,
                        answer2: cells[2].textContent,
                        commonality: cells[3].textContent
                    });
                }
            });

            const tandemIndex = tandems.findIndex(t => t.id === currentTandem.id);
            if (tandemIndex !== -1) {
                tandems[tandemIndex].commonalities = updatedCommonalities;
                tandems[tandemIndex].lastEdited = new Date().toISOString();
                saveTandems();
                console.log('✅ Tandem automatisch gespeichert (still)');
                return true;
            }
            return false;
        }

        function saveTandem() {
            if (saveTandemSilently()) {
                showNotification('✅ Tandem gespeichert', 'success');
                updateStatus('Tandem gespeichert');
            }
        }

        function recomputeCommonalities() {
            if (!currentTandem) {
                showNotification('Kein Tandem ausgewählt.', 'warning');
                return;
            }

            if (confirm('Gemeinsamkeiten neu berechnen? Manuelle Änderungen gehen verloren.')) {
                // Berechne Gemeinsamkeiten neu
                const newCommonalities = findCommonalities(currentTandem.profile1, currentTandem.profile2);
                currentTandem.commonalities = newCommonalities;

                // Aktualisiere die Tabelle
                loadTandemForEditing();

                showNotification('✅ Gemeinsamkeiten neu berechnet', 'success');
            }
        }

        // Aktualisiert nur PLZ-Distanzen ohne andere Gemeinsamkeiten zu überschreiben
        async function updatePLZDistancesOnly() {
            if (!currentTandem) {
                showNotification('Kein Tandem ausgewählt.', 'warning');
                return;
            }

            const table = document.getElementById('tandem-table');
            const rows = table.querySelectorAll('tbody tr');
            let updatedCount = 0;
            
            console.log('🗺️ Starte PLZ-Distanz-Update...');
            
            for (const row of rows) {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 4) {
                    const question = cells[0].textContent.trim();
                    const answer1 = cells[1].textContent.trim();
                    const answer2 = cells[2].textContent.trim();
                    const currentCommonality = cells[3];

                    // Prüfe ob es sich um PLZ/Wohnort-Feld handelt
                    const isLocationField = question.toLowerCase().includes('postleitzahl') || 
                                        question.toLowerCase().includes('plz') ||
                                        question.toLowerCase().includes('wohnort') ||
                                        question.toLowerCase().includes('standort');

                    if (isLocationField) {
                        const plz1 = extractPLZ(answer1);
                        const plz2 = extractPLZ(answer2);

                        if (plz1 && plz2) {
                            console.log(`📍 Berechne Distanz: ${plz1} ↔ ${plz2}`);
                            
                            // Zeige Loading-Status
                            currentCommonality.textContent = '🔄 Berechne Distanz...';
                            currentCommonality.style.background = 'var(--swaf-lightest-teal)';

                            try {
                                const result = await calculatePLZDistanceAdvanced(plz1, plz2);
                                
                                if (result && result.distance !== null) {
                                    let distanceText = '';
                                    
                                    if (result.distance === 0) {
                                        distanceText = 'Ihr wohnt in derselben PLZ';
                                    } else {
                                        const routingInfo = result.routingInfo === 'Echte Routing-Distanz' ? '🎯' : '📏';
                                        
                                        if (result.type === 'very_close') {
                                            distanceText = `${routingInfo} Sehr nah: ${result.distance}km (🚲 ${result.estimatedTimes.cycling}min, 🚌 ${result.estimatedTimes.transit}min)`;
                                        } else if (result.type === 'close') {
                                            distanceText = `${routingInfo} Nah: ${result.distance}km (🚌 ${result.estimatedTimes.transit}min, 🚗 ${result.estimatedTimes.driving}min)`;
                                        } else if (result.type === 'medium') {
                                            distanceText = `${routingInfo} Erreichbar: ${result.distance}km (🚌 ${result.estimatedTimes.transit}min, 🚗 ${result.estimatedTimes.driving}min)`;
                                        } else if (result.type === 'far') {
                                            distanceText = `${routingInfo} Weiter entfernt: ${result.distance}km (🚗 ${result.estimatedTimes.driving}min)`;
                                        }
                                    }
                                    
                                    // Verwende verbesserte PLZ-Zellen-Behandlung
                                    if (result.mapsLinks) {
                                        enhancePLZCell(currentCommonality, result.mapsLinks, plz1, plz2, distanceText);
                                    } else {
                                        currentCommonality.textContent = distanceText;
                                    }
                                    
                                    // Visuelles Feedback
                                    currentCommonality.style.background = 'var(--swaf-lightest-teal)';
                                    setTimeout(() => {
                                        currentCommonality.style.background = '';
                                    }, 2000);
                                    
                                    updatedCount++;
                                    console.log(`✅ ${plz1} ↔ ${plz2}: ${result.distance}km`);
                                } else {
                                    currentCommonality.textContent = '❌ Distanz nicht berechenbar';
                                    currentCommonality.style.background = 'var(--swaf-lightest-red)';
                                }
                            } catch (error) {
                                console.error(`❌ Fehler bei ${plz1} ↔ ${plz2}:`, error);
                                currentCommonality.textContent = '❌ Berechnung fehlgeschlagen';
                                currentCommonality.style.background = 'var(--swaf-lightest-red)';
                            }
                        } else {
                            console.log(`⚠️ Keine PLZ in "${question}" gefunden: "${answer1}" | "${answer2}"`);
                        }
                    }
                }
            }
            
            if (updatedCount > 0) {
                showNotification(`🗺️ ${updatedCount} PLZ-Distanzen aktualisiert`, 'success', 4000);
            } else {
                showNotification('ℹ️ Keine PLZ-Felder zum Aktualisieren gefunden', 'info', 3000);
            }
        }

        // Zeigt Navigations-Optionen für PLZ-Kombination
        function showNavigationOptions(mapsLinks, plz1, plz2) {
            console.log(`🗺️ Öffne Navigation für ${plz1} → ${plz2}`);
            
            // Spezielle Behandlung für verschiedene Regionen
            const regionInfo = getRegionInfo(plz1, plz2);
            const modal = createModal(`🗺️ Navigation: ${plz1} → ${plz2}`, `
                <div style="text-align: center;">
                    <p style="margin-bottom: 1.5rem;">Wähle deinen bevorzugten Navigationsservice:</p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                        <button class="btn btn-primary" onclick="window.open('${mapsLinks.googleMaps}', '_blank')" style="padding: 1rem;">
                            🚗 Google Maps<br><small>Auto-Navigation</small>
                        </button>
                        <button class="btn btn-secondary" onclick="window.open('${mapsLinks.googleMapsTransit}', '_blank')" style="padding: 1rem;">
                            🚌 Google ÖPNV<br><small>Bus & Bahn</small>
                        </button>
                        <button class="btn btn-outline" onclick="window.open('${mapsLinks.openStreetMap}', '_blank')" style="padding: 1rem;">
                            🌍 OpenStreetMap<br><small>Open Source</small>
                        </button>
                        <button class="btn btn-outline" onclick="window.open('${mapsLinks.localTransit}', '_blank')" style="padding: 1rem;">
                            🚇 Lokale ÖPNV<br><small>BVG/MVV/HVV</small>
                        </button>
                    </div>
                    
                    <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <h4 style="margin-top: 0;">📋 Links kopieren:</h4>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center;">
                            <button class="btn btn-outline btn-small" onclick="copyToClipboard('${mapsLinks.googleMaps}')">
                                📋 Google Maps
                            </button>
                            <button class="btn btn-outline btn-small" onclick="copyToClipboard('${mapsLinks.googleMapsTransit}')">
                                📋 ÖPNV
                            </button>
                            <button class="btn btn-outline btn-small" onclick="copyToClipboard('${mapsLinks.localTransit}')">
                                📋 Lokale ÖPNV
                            </button>
                        </div>
                    </div>
                </div>
            `, [
                { text: 'Schließen', class: 'btn-outline', action: 'closeModal' }
            ]);
        }

        // Verbesserte PLZ-Zellen-Behandlung für bessere UX
        function enhancePLZCell(cell, mapsLinks, plz1, plz2, distanceText) {
            // Entferne alte Event Listener
            cell.onclick = null;
            cell.ondblclick = null;
            
            // Setze Inhalt und Style
            cell.textContent = distanceText;
            cell.style.cursor = 'text';
            cell.title = `📝 Klick zum Bearbeiten | 🗺️ Doppelklick für Navigation (${plz1} → ${plz2})`;
            
            // Doppelklick für Navigation
            cell.addEventListener('dblclick', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Kurzes visuelles Feedback
                cell.style.background = 'var(--swaf-light-teal)';
                setTimeout(() => {
                    cell.style.background = 'var(--swaf-lightest-teal)';
                }, 200);
                
                showNavigationOptions(mapsLinks, plz1, plz2);
            });
            
            // Hover-Effekt für bessere UX
            cell.addEventListener('mouseenter', function() {
                if (!cell.matches(':focus')) {
                    cell.style.background = 'var(--swaf-lightest-teal)';
                    cell.style.borderLeft = '3px solid var(--swaf-teal)';
                }
            });
            
            cell.addEventListener('mouseleave', function() {
                if (!cell.matches(':focus')) {
                    cell.style.background = '';
                    cell.style.borderLeft = '';
                }
            });
            
            // Focus-Behandlung für Bearbeitung
            cell.addEventListener('focus', function() {
                cell.style.background = '#fff';
                cell.style.borderLeft = '3px solid var(--swaf-red)';
                cell.title = `📝 Bearbeitung aktiv | Esc zum Beenden`;
            });
            
            cell.addEventListener('blur', function() {
                cell.style.background = '';
                cell.style.borderLeft = '';
                cell.title = `📝 Klick zum Bearbeiten | 🗺️ Doppelklick für Navigation (${plz1} → ${plz2})`;
            });
            
            // Speichere Maps-Links als Data-Attribut
            cell.setAttribute('data-maps-links', JSON.stringify(mapsLinks));
            cell.setAttribute('data-plz-pair', `${plz1}-${plz2}`);
        }

        // Hilfsfunktion zum Kopieren in Zwischenablage
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification('📋 Link in Zwischenablage kopiert', 'success', 2000);
            }).catch(() => {
                // Fallback für ältere Browser
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showNotification('📋 Link kopiert', 'success', 2000);
            });
        }        

        // Ermittelt regionale Informationen für bessere ÖPNV-Links
        function getRegionInfo(plz1, plz2) {
            const regions = {
                berlin: { name: 'Berlin', pattern: /^(10|12|13)/, transport: 'BVG' },
                munich: { name: 'München', pattern: /^8[0-5]/, transport: 'MVV' },
                hamburg: { name: 'Hamburg', pattern: /^2[0-2]/, transport: 'HVV' },
                cologne: { name: 'Köln/NRW', pattern: /^(4|5)/, transport: 'VRS/VRR' },
                frankfurt: { name: 'Frankfurt', pattern: /^6/, transport: 'RMV' }
            };
            
            for (const [key, region] of Object.entries(regions)) {
                if (region.pattern.test(plz1) || region.pattern.test(plz2)) {
                    return region;
                }
            }
            
            return { name: 'Deutschland', transport: 'Deutsche Bahn' };
        }

        // Keyboard-Shortcut für Navigation in PLZ-Zellen
        document.addEventListener('keydown', function(e) {
            // Strg+N für Navigation wenn PLZ-Zelle fokussiert ist
            if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
                const focusedElement = document.activeElement;
                
                if (focusedElement && focusedElement.hasAttribute('data-maps-links')) {
                    e.preventDefault();
                    
                    const mapsLinks = JSON.parse(focusedElement.getAttribute('data-maps-links'));
                    const plzPair = focusedElement.getAttribute('data-plz-pair').split('-');
                    
                    showNavigationOptions(mapsLinks, plzPair[0], plzPair[1]);
                    showShortcutFeedback('🗺️ Navigation geöffnet!');
                }
            }
});

        // ===============================
        // EMAIL TEMPLATE SYSTEM
        // ===============================
        function formatText(command) {
            document.execCommand(command, false, null);
            updateToolbarState();
        }

        function insertText(text) {
            document.execCommand('insertHTML', false, text);
        }

        function insertPlaceholder(placeholder) {
            document.execCommand('insertHTML', false, `<strong>${placeholder}</strong>`);
        }

        function updateToolbarState() {
            const commands = ['bold', 'italic', 'underline'];
            commands.forEach(cmd => {
                const btn = document.querySelector(`[onclick="formatText('${cmd}')"]`);
                if (btn) {
                    btn.classList.toggle('active', document.queryCommandState(cmd));
                }
            });
        }

        function saveEmailTemplate() {
            emailTemplate.subject = document.getElementById('email-subject').value;
            emailTemplate.intro = document.getElementById('email-intro-editor').innerHTML;
            emailTemplate.link = document.getElementById('tandem-link').value;

            localStorage.setItem('swaf_email_template', JSON.stringify(emailTemplate));
            showNotification('✅ E-Mail-Vorlage gespeichert', 'success');
        }

        function loadEmailTemplate() {
            const saved = localStorage.getItem('swaf_email_template');
            if (saved) {
                try {
                    emailTemplate = JSON.parse(saved);
                    document.getElementById('email-subject').value = emailTemplate.subject;
                    document.getElementById('email-intro-editor').innerHTML = emailTemplate.intro;
                    document.getElementById('tandem-link').value = emailTemplate.link;
                    showNotification('✅ E-Mail-Vorlage geladen', 'success');
                } catch (error) {
                    console.error('Fehler beim Laden der E-Mail-Vorlage:', error);
                    showNotification('❌ Fehler beim Laden der Vorlage', 'error');
                }
            } else {
                showNotification('ℹ️ Keine gespeicherte Vorlage gefunden', 'info');
            }
        }

        function resetEmailTemplate() {
            if (confirm('E-Mail-Vorlage auf Standardwerte zurücksetzen?')) {
                document.getElementById('email-intro-editor').innerHTML = `
                    Hi <strong>[NAME1]</strong> und <strong>[NAME2]</strong>,<br><br>
                    
                    hier ist ein Tandemvorschlag für euch 😊 Lest euch das gerne einmal durch – ich finde, <strong>ihr habt einige Gemeinsamkeiten und Interessen</strong>. Lest euch die Tabelle gerne durch.<br><br>
                    
                    <strong>Ihr findet:</strong> Eure Angaben, die Angaben der anderen Person, meine Einschätzung.<br><br>
                    
                    <em>Auch wenn es auf den ersten Blick nicht zu 100% passt, probiert es vielleicht aus.</em> Natürlich nur, wenn ihr Lust drauf habt. Wenn nicht, ist das auch okay.<br><br>
                    
                    Unter der Tabelle findet ihr einen Link. <strong>Bitte drückt hier drauf.</strong> Dann könnt ihr sagen, ob ihr das Tandem annehmen oder ablehnen wollt 😊<br><br>
                    
                    <strong>Wichtig:</strong> Wenn ihr das Tandem ablehnt schreibt mir bitte die Gründe auf.<br><br>
                    
                    Ich freue mich über eure Rückmeldung!<br><br>
                    
                    <strong>Eure Gemeinsamkeiten und Profile im Überblick</strong>
                `;
                showNotification('✅ E-Mail-Vorlage zurückgesetzt', 'success');
            }
        }

        function generateCompleteEmail() {
            if (!currentTandem) {
                showNotification('❌ Bitte wähle zuerst ein Tandem aus', 'error');
                return;
            }

            // Automatisch Tandem speichern BEVOR E-Mail erstellt wird
            console.log('💾 Auto-Save: Speichere Tandem vor E-Mail-Erstellung...');
            saveTandemSilently();
            
            saveEmailTemplate(); // Aktuelle Eingaben speichern
            previewEmail();
            
            // Feedback für User
            showNotification('💾 Tandem automatisch gespeichert', 'success', 2000);
        }

        function previewEmail() {
            if (!currentTandem) {
                showNotification('❌ Bitte wähle zuerst ein Tandem aus', 'error');
                return;
            }

            const subject = document.getElementById('email-subject').value;
            const introHtml = document.getElementById('email-intro-editor').innerHTML;
            const tandemLink = document.getElementById('tandem-link').value;

            // Ersetze Platzhalter in der Einleitung (nur Vornamen)
            const firstName1 = extractFirstName(currentTandem.profile1.name);
            const firstName2 = extractFirstName(currentTandem.profile2.name);

            const processedIntro = introHtml
                .replace(/\[NAME1\]/g, firstName1)
                .replace(/\[NAME2\]/g, firstName2);

            // Erstelle Tabelle
            const tableHtml = createHTMLVersionForClipboard();

            // Komplette E-Mail zusammenstellen
            const completeEmail = `
                <div class="email-subject-line">
                    <strong>Betreff:</strong> ${escapeHtml(subject)}
                </div>
                
                <div>
                    ${processedIntro}
                </div>
                
                ${tableHtml}
                
            `;

            // Zeige Vorschau
            document.getElementById('email-preview-content').innerHTML = completeEmail;
            document.getElementById('email-preview-section').classList.remove('hidden');

            // Scroll zur Vorschau
            document.getElementById('email-preview-section').scrollIntoView({ behavior: 'smooth' });
        }

        function hideEmailPreview() {
            document.getElementById('email-preview-section').classList.add('hidden');
        }

        function copyCompleteEmailToClipboard() {
            if (!currentTandem) {
                showNotification('❌ Keine E-Mail-Vorschau verfügbar', 'error');
                return;
            }

            // Automatisch Tandem speichern BEVOR E-Mail kopiert wird
            console.log('💾 Auto-Save: Speichere Tandem vor E-Mail-Kopieren...');
            saveTandemSilently();

            const subject = document.getElementById('email-subject').value;
            const introHtml = document.getElementById('email-intro-editor').innerHTML;
            const tandemLink = document.getElementById('tandem-link').value;

            // Erstelle Text- und HTML-Version
            const textVersion = createCompleteEmailText(subject, introHtml, tandemLink);
            const htmlVersion = createCompleteEmailHTML(subject, introHtml, tandemLink);

            if (navigator.clipboard && navigator.clipboard.write) {
                const clipboardItems = [
                    new ClipboardItem({
                        'text/html': new Blob([htmlVersion], { type: 'text/html' }),
                        'text/plain': new Blob([textVersion], { type: 'text/plain' })
                    })
                ];

                navigator.clipboard.write(clipboardItems).then(() => {
                    showNotification('📧 Komplette E-Mail in Zwischenablage kopiert (Word & E-Mail kompatibel)', 'success', 4000);
                }).catch(error => {
                    console.error('Clipboard API Error:', error);
                    fallbackCopyToClipboard(textVersion, htmlVersion);
                });
            } else {
                fallbackCopyToClipboard(textVersion, htmlVersion);
            }

            // Feedback für User
            showNotification('💾 Tandem automatisch gespeichert', 'success', 2000);
        }

        function createCompleteEmailText(subject, introHtml, tandemLink) {
            // Konvertiere HTML zu Text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = introHtml;
            const introText = tempDiv.textContent || tempDiv.innerText || '';

            const firstName1 = extractFirstName(currentTandem.profile1.name);
            const firstName2 = extractFirstName(currentTandem.profile2.name);

            const processedIntro = introText
                .replace(/\[NAME1\]/g, firstName1)
                .replace(/\[NAME2\]/g, firstName2);

            const tableText = createTextVersionForClipboard();

            return `Betreff: ${subject}\n\n${processedIntro}\n\n${tableText}\n\nTandem-Link: ${tandemLink}\n`;
        }

        function createCompleteEmailHTML(subject, introHtml, tandemLink) {
            const firstName1 = extractFirstName(currentTandem.profile1.name);
            const firstName2 = extractFirstName(currentTandem.profile2.name);

            const processedIntro = introHtml
                .replace(/\[NAME1\]/g, firstName1)
                .replace(/\[NAME2\]/g, firstName2);

            const tableHtml = createHTMLVersionForClipboard();

            return `
                <!--StartFragment-->
                <html>
                <head>
                    <meta charset="utf-8">
                    <style>
                        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.5; }
                        .email-header { background: #f0f0f0; padding: 10px; border-radius: 4px; margin-bottom: 20px; }
                        .tandem-link { background: #fff3cd; padding: 15px; border-radius: 4px; margin: 20px 0; border-left: 4px solid #ffc107; }
                    </style>
                </head>
                <body>
                    <div class="email-header">
                        <strong>Betreff:</strong> ${escapeHtml(subject)}
                    </div>
                    
                    <div>
                        ${processedIntro}
                    </div>
                    
                    ${tableHtml}
                    
                </body>
                </html>
                <!--EndFragment-->
            `;
        }

        function downloadEmailAsHTML() {
            if (!currentTandem) {
                showNotification('❌ Keine E-Mail-Vorschau verfügbar', 'error');
                return;
            }

            // Automatisch Tandem speichern BEVOR Download
            console.log('💾 Auto-Save: Speichere Tandem vor Download...');
            saveTandemSilently();

            const subject = document.getElementById('email-subject').value;
            const introHtml = document.getElementById('email-intro-editor').innerHTML;
            const tandemLink = document.getElementById('tandem-link').value;

            const htmlContent = createCompleteEmailHTML(subject, introHtml, tandemLink);
            const filename = `SwaF_Email_${currentTandem.profile1.name}_${currentTandem.profile2.name}_${new Date().toISOString().split('T')[0]}.html`;

            downloadFile(htmlContent, filename, 'text/html');
            showNotification('📥 E-Mail als HTML-Datei gespeichert', 'success');
            showNotification('💾 Tandem automatisch gespeichert', 'success', 2000);
        }

        // ===============================
        // EXPORT-FUNKTIONEN
        // ===============================
        function copyTandemToClipboard() {
            if (!currentTandem) return;

            // Automatisch Tandem speichern BEVOR kopiert wird
            console.log('💾 Auto-Save: Speichere Tandem vor Kopieren...');
            saveTandemSilently();

            // Erstelle sowohl Text- als auch HTML-Version
            const textVersion = createTextVersionForClipboard();
            const htmlVersion = createHTMLVersionForClipboard();
            
            // Feedback für User (am Ende der Funktion)
            setTimeout(() => {
                showNotification('💾 Tandem automatisch gespeichert', 'success', 2000);
            }, 500);

            // Moderne Clipboard API mit mehreren Formaten
            if (navigator.clipboard && navigator.clipboard.write) {
                const clipboardItems = [
                    new ClipboardItem({
                        'text/html': new Blob([htmlVersion], { type: 'text/html' }),
                        'text/plain': new Blob([textVersion], { type: 'text/plain' })
                    })
                ];

                navigator.clipboard.write(clipboardItems).then(() => {
                    showNotification('📋 Tandem als Tabelle in Zwischenablage kopiert (Word-kompatibel)', 'success');
                }).catch(error => {
                    console.error('Clipboard API Error:', error);
                    fallbackCopyToClipboard(textVersion, htmlVersion);
                });
            } else {
                fallbackCopyToClipboard(textVersion, htmlVersion);
            }
        }

        function createTextVersionForClipboard() {
            if (!currentTandem) return '';

            let text = `${currentTandem.name}\n`;
            text += '='.repeat(currentTandem.name.length) + '\n\n';

            // Tabellen-ähnliche Formatierung für Plain Text
            const maxQuestionWidth = Math.max(...currentTandem.commonalities.map(c => c.question.length));
            const maxAnswer1Width = Math.max(...currentTandem.commonalities.map(c => c.answer1.length));
            const maxAnswer2Width = Math.max(...currentTandem.commonalities.map(c => c.answer2.length));

            // Header
            text += 'Frage'.padEnd(maxQuestionWidth + 2) + '| ';
            text += extractFirstName(currentTandem.profile1.name).padEnd(maxAnswer1Width + 2) + '| ';
            text += extractFirstName(currentTandem.profile2.name).padEnd(maxAnswer2Width + 2) + '| ';
            text += 'Gemeinsamkeiten\n';

            text += '-'.repeat(maxQuestionWidth + 2) + '+-';
            text += '-'.repeat(maxAnswer1Width + 2) + '+-';
            text += '-'.repeat(maxAnswer2Width + 2) + '+-';
            text += '-'.repeat(20) + '\n';

            // Datenzeilen
            currentTandem.commonalities.forEach(c => {
                text += c.question.padEnd(maxQuestionWidth + 2) + '| ';
                text += (c.answer1 || '').padEnd(maxAnswer1Width + 2) + '| ';
                text += (c.answer2 || '').padEnd(maxAnswer2Width + 2) + '| ';
                text += (c.commonality || '') + '\n';
            });

            return text;
        }

        function createHTMLVersionForClipboard() {
            if (!currentTandem) return '';

            // Word-optimierte HTML-Tabelle
            const html = `
                <!--StartFragment-->
                <html xmlns:o="urn:schemas-microsoft-com:office:office" 
                    xmlns:w="urn:schemas-microsoft-com:office:word">
                <head>
                    <meta charset="utf-8">
                    <meta name="ProgId" content="Word.Document">
                    <meta name="Generator" content="SwaF Tandem Matcher">
                    <meta name="Originator" content="SwaF Tandem Matcher v2.0">
                    <!--[if gte mso 9]>
                    <xml>
                        <w:WordDocument>
                            <w:View>Normal</w:View>
                            <w:Zoom>0</w:Zoom>
                            <w:DoNotPromptForConvert/>
                            <w:DoNotShowInsertionsAndDeletions/>
                        </w:WordDocument>
                    </xml>
                    <![endif]-->
                    <style>
                        table {
                            border-collapse: collapse;
                            width: 100%;
                            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                            font-size: 11pt;
                        }
                        .table-title {
                            font-size: 14pt;
                            font-weight: bold;
                            color: #C3003B;
                            margin-bottom: 10pt;
                            text-align: center;
                        }
                        th {
                            background-color: #009892;
                            color: white;
                            font-weight: bold;
                            padding: 8pt;
                            border: 1px solid #ddd;
                            text-align: left;
                            vertical-align: top;
                        }
                        td {
                            padding: 8pt;
                            border: 1px solid #ddd;
                            text-align: left;
                            vertical-align: top;
                            max-width: 200pt;
                            word-wrap: break-word;
                        }
                        .question-col {
                            background-color: #f8f9fa;
                            font-weight: bold;
                            width: 25%;
                        }
                        .answer-col {
                            width: 25%;
                        }
                        .commonality-col {
                            background-color: #E6FFFD;
                            font-weight: bold;
                            color: #009892;
                            width: 25%;
                        }
                        .empty-cell {
                            color: #999;
                            font-style: italic;
                        }
                    </style>
                </head>
                <body>
                    <table border="1" cellspacing="0" cellpadding="8">
                        <thead>
                            <tr>
                                <th class="question-col">Frage</th>
                                <th class="answer-col">${escapeHtml(extractFirstName(currentTandem.profile1.name))}</th>
                                <th class="answer-col">${escapeHtml(extractFirstName(currentTandem.profile2.name))}</th>
                                <th class="commonality-col">Gemeinsamkeiten</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${currentTandem.commonalities.map(c => `
                                <tr>
                                    <td class="question-col">${escapeHtml(c.question)}</td>
                                    <td class="answer-col">${c.answer1 ? escapeHtml(c.answer1) : '<span class="empty-cell">Keine Angabe</span>'}</td>
                                    <td class="answer-col">${c.answer2 ? escapeHtml(c.answer2) : '<span class="empty-cell">Keine Angabe</span>'}</td>
                                    <td class="commonality-col">${c.commonality ? escapeHtml(c.commonality) : '<span class="empty-cell">Keine Übereinstimmung</span>'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    
                </body>
                </html>
                <!--EndFragment-->
            `;

            return html;
        }

        function fallbackCopyToClipboard(textVersion, htmlVersion) {
            // Fallback für ältere Browser
            const textarea = document.createElement('textarea');
            textarea.value = textVersion;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            showNotification('📋 Tandem in Zwischenablage kopiert (Text-Format)', 'success');
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function extractFirstName(fullName) {
            if (!fullName || typeof fullName !== 'string') {
                return 'Partner*in';
            }

            console.log(`📛 Extrahiere Namen aus: "${fullName}"`);

            // 1. Suche nach Namen in Klammern (höchste Priorität)
            const bracketMatch = fullName.match(/\(([^)]+)\)/);
            if (bracketMatch) {
                const nameInBrackets = bracketMatch[1].trim();
                const firstName = nameInBrackets.split(/[\s,]+/)[0];
                if (firstName && firstName.length > 1 && !firstName.match(/^(locals?|einwander|interview|gespräch)/i)) {
                    console.log(`✅ Name aus Klammern extrahiert: "${firstName}"`);
                    return firstName;
                }
            }

            // 2. Prüfe ob es ein direkter Name ohne Präfix ist
            if (!fullName.match(/^(aufnahmegespräch|interview|gespräch)/i)) {
                const firstName = fullName.split(/[\s,]+/)[0];
                if (firstName && firstName.length > 1) {
                    console.log(`✅ Direkter Name: "${firstName}"`);
                    return firstName;
                }
            }

            // 3. Fallback für komplexe Fälle
            console.log(`⚠️ Fallback für: "${fullName}"`);
            return 'Partner*in';
        }

        // ===============================
        // VERWALTUNGS-FUNKTIONEN
        // ===============================
        function loadSavedTandems() {
            const container = document.getElementById('saved-tandems-list');

            if (tandems.length === 0) {
                container.innerHTML = '<p>Keine gespeicherten Tandems vorhanden.</p>';
                return;
            }

            container.innerHTML = tandems.map(tandem => `
                <div style="border: 1px solid #ddd; padding: 1rem; margin: 0.5rem 0; border-radius: 4px;">
                    <strong>${tandem.name}</strong>
                    <p><small>Erstellt: ${new Date(tandem.created).toLocaleString('de-DE')}</small></p>
                    <div>
                        <button onclick="editTandem('${tandem.id}')" class="btn btn-outline btn-small">✏️ Bearbeiten</button>
                        <button onclick="deleteSavedTandem('${tandem.id}')" class="btn btn-outline btn-small">🗑️ Löschen</button>
                    </div>
                </div>
            `).join('');
        }

        function editTandem(tandemId) {
            switchTab(3);
            document.getElementById('tandem-selector').value = tandemId;
            loadTandemForEditing();
        }

        function deleteSavedTandem(tandemId) {
            if (confirm('Tandem wirklich löschen?')) {
                tandems = tandems.filter(t => t.id != tandemId);
                saveTandems();
                loadSavedTandems();
                updateStatistics();
                showNotification('Tandem gelöscht', 'success');
            }
        }

        function exportAllTandems() {
            if (tandems.length === 0) {
                showNotification('Keine Tandems zum Exportieren vorhanden.', 'warning');
                return;
            }

            const data = {
                tandems: tandems,
                profiles: profiles,
                exported: new Date().toISOString(),
                version: '2.0'
            };

            downloadFile(JSON.stringify(data, null, 2), `SwaF_Tandems_${new Date().toISOString().split('T')[0]}.json`, 'application/json');
        }

        function exportAppData() {
            const data = {
                profiles: profiles,
                tandems: tandems,
                selectedFields: selectedFields,
                exported: new Date().toISOString(),
                version: '2.0'
            };

            downloadFile(JSON.stringify(data, null, 2), `SwaF_Backup_${new Date().toISOString().split('T')[0]}.json`, 'application/json');
            showNotification('✅ Daten erfolgreich gesichert', 'success');
        }

        function importAppData() {
            document.getElementById('import-data-input').click();
        }

        function handleDataImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (confirm('Möchtest du die importierten Daten mit den vorhandenen zusammenführen (Ja) oder alle vorhandenen Daten ersetzen (Nein)?')) {
                        if (data.profiles) profiles.push(...data.profiles);
                        if (data.tandems) tandems.push(...data.tandems);
                        if (data.selectedFields) selectedFields.push(...data.selectedFields.filter(f => !selectedFields.includes(f)));
                    } else {
                        if (data.profiles) profiles = data.profiles;
                        if (data.tandems) tandems = data.tandems;
                        if (data.selectedFields) selectedFields = data.selectedFields;
                    }

                    saveAllData();
                    updateUI();
                    showNotification('✅ Daten erfolgreich importiert', 'success');

                } catch (error) {
                    showNotification('❌ Fehler beim Importieren: ' + error.message, 'error');
                }
            };

            reader.readAsText(file);
        }

        function clearProfiles() {
            if (confirm('Wirklich alle Profile löschen?')) {
                profiles = [];
                saveProfiles();
                updateUI();
                showNotification('Alle Profile gelöscht', 'success');
            }
        }

        function clearTandems() {
            if (confirm('Wirklich alle Tandems löschen?')) {
                tandems = [];
                saveTandems();
                updateStatistics();
                loadSavedTandems();
                showNotification('Alle Tandems gelöscht', 'success');
            }
        }

        function clearAllProfiles() {
            if (confirm('Wirklich alle Profile löschen?')) {
                profiles = [];
                saveProfiles();
                updateUI();
                showNotification('Alle Profile gelöscht', 'success');
            }
        }

        function resetAllData() {
            if (confirm('ACHTUNG: Alle Daten werden unwiederbringlich gelöscht!\n\nBist du sicher?')) {
                if (confirm('Letzte Warnung: Diese Aktion löscht ALLE Profile, Tandems und Einstellungen!')) {
                    localStorage.clear();
                    location.reload();
                }
            }
        }

        function removeProfile(profileId) {
            if (confirm('Profil wirklich löschen?')) {
                profiles = profiles.filter(p => p.id != profileId);
                saveProfiles();
                updateUI();
                showNotification('Profil gelöscht', 'success');
            }
        }

        // ===============================
        // TEXTBAUSTEIN-FUNKTIONEN
        // ===============================
        function initializeTextTemplates() {
            console.log('📝 Initialisiere Textbausteine...');
            
            // Initialisiere vordefinierte Templates
            initializePredefinedTemplates();

            // Lade vordefinierte Templates falls noch keine existieren
            if (textTemplates.length === 0) {
                textTemplates = [...predefinedTemplates];
                saveTextTemplates();
            }

            loadTextTemplates();
            
            // NEU: Stelle sicher, dass allgemeine Templates geladen werden
            setTimeout(() => {
                loadPredefinedTemplates();
                console.log('📋 Allgemeine Templates geladen:', predefinedTemplates.length);
            }, 200);
        }

        function loadTextTemplates() {
            const container = document.getElementById('saved-templates');
            if (!container) return;

            if (textTemplates.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: var(--swaf-dark-gray); font-style: italic; padding: 1rem;">Noch keine eigenen Textbausteine gespeichert.</p>';
                return;
            }

            container.innerHTML = textTemplates.map((template, index) => `
                <div style="border: 1px solid #ddd; padding: 0.5rem; margin: 0.5rem 0; border-radius: 4px; background: white;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div style="flex: 1;" ondblclick="insertTemplate('${template.text.replace(/'/g, "\\'")}')">
                            <strong style="color: var(--swaf-red);">${template.title}</strong><br>
                            <span style="font-size: 0.9rem; color: var(--swaf-dark-gray);">${template.text}</span>
                        </div>
                        <button onclick="removeTemplate(${index})" 
                                style="background: var(--swaf-red); color: white; border: none; padding: 0.2rem 0.4rem; border-radius: 3px; cursor: pointer; margin-left: 0.5rem;">
                            ❌
                        </button>
                    </div>
                </div>
            `).join('');
            
            // NEU: Lade auch die allgemeinen Templates
            loadPredefinedTemplates();
        }

        function saveTextTemplate() {
            const title = document.getElementById('template-title').value.trim();
            const text = document.getElementById('template-text').value.trim();

            if (!title || !text) {
                showNotification('Bitte Titel und Text eingeben.', 'warning');
                return;
            }

            // Prüfe auf Duplikate
            if (textTemplates.some(t => t.title === title)) {
                if (!confirm(`Textbaustein "${title}" existiert bereits. Überschreiben?`)) {
                    return;
                }
                textTemplates = textTemplates.filter(t => t.title !== title);
            }

            textTemplates.push({ title, text });
            saveTextTemplates();
            loadTextTemplates();

            // Eingabefelder leeren
            document.getElementById('template-title').value = '';
            document.getElementById('template-text').value = '';

            showNotification(`✅ Textbaustein "${title}" gespeichert`, 'success');
        }

        function removeTemplate(index) {
            const template = textTemplates[index];
            if (confirm(`Textbaustein "${template.title}" wirklich löschen?`)) {
                textTemplates.splice(index, 1);
                saveTextTemplates();
                loadTextTemplates();
                showNotification(`Textbaustein "${template.title}" gelöscht`, 'success');
            }
        }

        function insertTemplate(text) {
            // Finde die aktuell ausgewählte/fokussierte Zelle
            const focusedCell = document.activeElement;

            if (focusedCell && focusedCell.contentEditable === 'true') {
                // Füge Text in die fokussierte Zelle ein
                const currentText = focusedCell.textContent.trim();
                if (currentText && !currentText.includes(text)) {
                    focusedCell.textContent = currentText + '; ' + text;
                } else if (!currentText) {
                    focusedCell.textContent = text;
                }

                // Zelle hervorheben
                focusedCell.style.background = 'var(--swaf-lightest-teal)';
                setTimeout(() => {
                    focusedCell.style.background = '';
                }, 1000);

                showNotification('✅ Textbaustein eingefügt', 'success', 2000);
            } else {
                // Fallback: Kopiere in Zwischenablage
                navigator.clipboard.writeText(text).then(() => {
                    showNotification('📋 Textbaustein in Zwischenablage kopiert. Klicke in eine Zelle und füge mit Strg+V ein.', 'info', 4000);
                }).catch(() => {
                    showNotification('Bitte klicke zuerst in eine Gemeinsamkeiten-Zelle.', 'warning');
                });
            }
        }

        function clearAllTemplates() {
            if (confirm('Wirklich alle eigenen Textbausteine löschen?')) {
                textTemplates = [];
                saveTextTemplates();
                loadTextTemplates();
                showNotification('Alle Textbausteine gelöscht', 'success');
            }
        }

        function saveTextTemplates() {
            localStorage.setItem('swaf_text_templates', JSON.stringify(textTemplates));
        }

        // ===============================
        // FLOATING TEMPLATES SYSTEM
        // ===============================
        function initializeFloatingTemplates() {
            // Event Listener für Tabellenzellen hinzufügen
            document.addEventListener('click', function (e) {
                if (e.target.closest('#tandem-table')) {
                    const cell = e.target.closest('td[contenteditable="true"]');
                    if (cell) {
                        handleCellFocus(cell);
                    }
                }
            });

            // Event Listener für Escape-Taste
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape' && floatingTemplatesVisible) {
                    hideFloatingTemplates();
                }
            });
        }

        function handleCellFocus(cell) {
            activeTemplateCell = cell;

            // Bestimme Kontext basierend auf der Frage in der gleichen Zeile
            const row = cell.closest('tr');
            const questionCell = row?.querySelector('td:first-child');
            const question = questionCell?.textContent?.toLowerCase() || '';

            console.log('🎯 Zelle fokussiert, Frage:', question);

            // Erkenne Kontext
            let context = detectQuestionContext(question);

            if (context) {
                showContextualTemplates(context, question);
            } else {
                showGeneralTemplates();
            }
        }

        function detectQuestionContext(question) {
            const contextMappings = {
                'alter': ['alter', 'geburt', 'age', 'altersunterschied', 'geboren', 'geburtstag', 'wie groß darf der altersunterschied'],
                'hobby': ['hobby', 'interesse', 'freizeit', 'sport', 'aktivität', 'machst du gerne', 'ausprobieren', 'gibt es etwas neues', 'hobbys'],
                'beruf': ['beruf', 'arbeit', 'job', 'branche', 'tätig', 'was machst du gerade', 'vorher gemacht', 'gelernt', 'was machst du'],
                'community': ['community', 'event', 'unternehmen', 'anbieten möchtest', 'bei einem community-event'],
                'sprache': ['sprache', 'language', 'sprichst', 'deutsch', 'welche sprachen'],
                'postleitzahl': ['postleitzahl', 'plz'],
                'wohnort': ['wohnort', 'standort', 'ort', 'wohnen', 'adresse', 'region'],
                'studium': ['studium', 'ausbildung', 'schule', 'hochschule', 'uni', 'abschluss', 'zeugnis', 'schonmal ein studium'],
                'zeit': ['zeit', 'treffen', 'verfügbar', 'wann hast du zeit'],
                'verkehr': ['verkehr', 'bewegst', 'transport', 'anreisen', 'wie bewegst du dich', 'wie lange kannst du anreisen'],
                'freundschaft': ['freundschaft', 'wichtig', 'tandem vor', 'wie stellst du dir'],
                'kinder': ['kinder', 'kindern anmelden'],
                'community': ['community', 'event', 'unternehmen', 'anbieten möchtest'],
                'erreichen': ['erreichen', 'kontakt', 'wie kann man dich'],
                'geschlecht': ['geschlecht', 'tandempartner'],
                'schwerpunkt': ['schwerpunkt', 'zusätzlich'],
                
                // NEUE KATEGORIEN basierend auf den Logs:
                'motivation': ['warum möchtest du', 'bei swaf mitmachen'],
                'herkunft_swaf': ['woher kennst du swaf'],
                'einwanderung': ['in welchem land bist du geboren', 'bist du in deutschland geboren', 'seit wann lebst du in deutschland'],
                'zukunft': ['was möchtest du in zukunft', 'gerne machen'],
                'themen': ['gibt es themen', 'besonders interessieren'],
                'name': ['vorname', 'nachname'],
                'gruppe': ['gruppe'],
                'vermittlung': ['vermittler', 'durchgeführt von'],
                'eindruck': ['wie wirkt die person auf dich'],
                'matching_hinweise': ['worauf sollte bei der auswahl', 'tandempartner'],
                'herausforderungen': ['gibt es besondere herausforderungen'],
                'kontakt': ['e-mail', 'telefon', 'adresse'],
                'termine': ['datum', 'uhrzeit', 'terminart', 'infoabend'],
                'status': ['status', 'durchgeführt']
            };

            for (const [context, keywords] of Object.entries(contextMappings)) {
                if (keywords.some(keyword => question.toLowerCase().includes(keyword.toLowerCase()))) {
                    console.log(`🎯 Kontext erkannt: "${context}" für Frage: "${question}"`);
                    return context;
                }
            }

            console.log(`❓ Kein spezifischer Kontext für: "${question}"`);
            return null;
        }

        function showContextualTemplates(context, question) {
            currentContextQuestion = question;
            const contextTemplates = contextualTemplates[context] || [];

            // Kombiniere kontextspezifische und allgemeine Templates
            const allTemplates = [
                ...contextTemplates,
                ...getRelevantGeneralTemplates(context)
            ];

            updateFloatingTemplatesContent(allTemplates, `${getContextDisplayName(context)}: ${question}`);
            showFloatingTemplates();
        }

        function getContextDisplayName(context) {
            const displayNames = {
                'alter': 'Alter',
                'hobby': 'Hobbys',
                'sprache': 'Sprachen',
                'postleitzahl': 'Wohnort',
                'wohnort': 'Wohnort',
                'beruf': 'Beruf',
                'studium': 'Bildung',
                'zeit': 'Zeitplanung',
                'verkehr': 'Mobilität'
            };

            return displayNames[context] || 'Kontext';
        }

        function getRelevantGeneralTemplates(context) {
            // Wähle passende allgemeine Templates basierend auf Kontext
            const relevantTitles = {
                'alter': ['Voneinander lernen', 'Neue Erfahrungen'],
                'hobby': ['Ergänzende Unterschiede', 'Neue Erfahrungen'],
                'sprache': ['Gegenseitige Unterstützung', 'Voneinander lernen'],
                'postleitzahl': ['Gut erreichbar', 'Flexibel'],
                'wohnort': ['Gut erreichbar', 'Gleiche Stadt'],
                'beruf': ['Voneinander lernen', 'Gegenseitige Unterstützung'],
                'studium': ['Voneinander lernen', 'Ähnliche Lebenssituation'],
                'zeit': ['Flexibel', 'Wochenende'],
                'verkehr': ['Gut erreichbar', 'Öffentliche Verkehrsmittel']
            };

            const titles = relevantTitles[context] || ['Voneinander lernen'];

            return predefinedTemplates
                .filter(template => titles.includes(template.title))
                .map(template => ({ text: template.text, priority: false }));
        }

        function showGeneralTemplates() {
            const generalTemplates = predefinedTemplates
                .slice(0, 10) // Erste 10 Templates
                .map(template => ({ text: template.text, priority: false }));

            updateFloatingTemplatesContent(generalTemplates, 'Allgemeine Vorschläge');
            showFloatingTemplates();
        }

        function updateFloatingTemplatesContent(templates, title) {
            const titleElement = document.getElementById('floating-templates-title');
            const contentElement = document.getElementById('floating-templates-content');

            titleElement.textContent = title;

            // Gruppiere nach Priorität
            const priorityTemplates = templates.filter(t => t.priority);
            const normalTemplates = templates.filter(t => !t.priority);

            let html = '';

            if (priorityTemplates.length > 0) {
                html += '<div class="template-category">';
                html += '<div class="template-category-title">Empfohlen</div>';
                priorityTemplates.forEach(template => {
                    html += `<button class="floating-template-btn priority" onclick="insertFloatingTemplate('${template.text.replace(/'/g, "\\'")}')">
                        ${template.text}
                    </button>`;
                });
                html += '</div>';
            }

            if (normalTemplates.length > 0) {
                html += '<div class="template-category">';
                html += '<div class="template-category-title">Weitere</div>';
                normalTemplates.forEach(template => {
                    html += `<button class="floating-template-btn" onclick="insertFloatingTemplate('${template.text.replace(/'/g, "\\'")}')">
                        ${template.text}
                    </button>`;
                });
                html += '</div>';
            }

            contentElement.innerHTML = html;
        }

        function insertFloatingTemplate(text) {
            if (activeTemplateCell) {
                const currentText = activeTemplateCell.textContent.trim();

                if (currentText && !currentText.includes(text)) {
                    activeTemplateCell.textContent = currentText + '; ' + text;
                } else if (!currentText) {
                    activeTemplateCell.textContent = text;
                }

                // Visuelles Feedback
                activeTemplateCell.style.background = 'var(--swaf-lightest-teal)';
                setTimeout(() => {
                    activeTemplateCell.style.background = '';
                }, 1000);

                // Template-Panel ausblenden nach Einfügung
                hideFloatingTemplates();

                showNotification('✅ Formulierung eingefügt', 'success', 2000);
            }
        }

        function showFloatingTemplates() {
            const panel = document.getElementById('floating-templates');
            const toggle = document.getElementById('floating-templates-toggle');

            panel.classList.add('visible');
            toggle.style.display = 'none';
            floatingTemplatesVisible = true;
        }

        function hideFloatingTemplates() {
            const panel = document.getElementById('floating-templates');
            const toggle = document.getElementById('floating-templates-toggle');

            panel.classList.remove('visible');
            toggle.style.display = 'block';
            floatingTemplatesVisible = false;
            activeTemplateCell = null;
        }

        function toggleFloatingTemplates() {
            if (floatingTemplatesVisible) {
                hideFloatingTemplates();
            } else {
                showGeneralTemplates();
            }
        }

        // ===============================
        // KONTEXTUELLE TEMPLATES
        // ===============================
        function editContextualTemplates() {
            loadContextualTemplatesFromStorage();

            const modal = createModal('📝 Fragespezifische Formulierungen bearbeiten', `
                <div style="max-height: 600px; overflow-y: auto;">
                    <div style="margin-bottom: 1rem;">
                        <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1rem;">
                            <button class="btn btn-primary" onclick="addNewContextCategory()">➕ Neue Kategorie</button>
                            <button class="btn btn-outline" onclick="resetContextualTemplates()">🔄 Auf Standard zurücksetzen</button>
                            <button class="btn btn-outline" onclick="exportContextualTemplates()">📤 Exportieren</button>
                            <button class="btn btn-outline" onclick="importContextualTemplates()">📥 Importieren</button>
                        </div>
                    </div>
                    
                    <div id="contextual-templates-editor">
                        ${generateContextualTemplatesHTML()}
                    </div>
                    
                    <div style="margin-top: 2rem; padding: 1rem; background: var(--swaf-lightest-teal); border-radius: 4px;">
                        <h4>💡 Verfügbare Kontext-Kategorien:</h4>
                        <p style="font-size: 0.9rem; margin: 0.5rem 0;">
                            <strong>alter:</strong> Alters-bezogene Fragen<br>
                            <strong>hobby:</strong> Hobbys, Interessen, Freizeit, Sport<br>
                            <strong>sprache:</strong> Sprachen, Deutsch, Kommunikation<br>
                            <strong>postleitzahl:</strong> PLZ-Felder<br>
                            <strong>wohnort:</strong> Wohnort, Standort, Adresse<br>
                            <strong>beruf:</strong> Beruf, Arbeit, Branche<br>
                            <strong>studium:</strong> Bildung, Studium, Ausbildung<br>
                            <strong>zeit:</strong> Zeitplanung, Verfügbarkeit<br>
                            <strong>verkehr:</strong> Mobilität, Transport, Anreise
                        </p>
                    </div>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Speichern & Schließen', class: 'btn-primary', action: 'saveContextualTemplates' }
            ]);
        }

        function loadContextualTemplatesFromStorage() {
            const saved = localStorage.getItem('swaf_contextual_templates');
            if (saved) {
                try {
                    const savedTemplates = JSON.parse(saved);
                    if (savedTemplates && typeof savedTemplates === 'object') {
                        contextualTemplates = savedTemplates;
                        console.log('✅ Gespeicherte kontextspezifische Templates geladen');
                    }
                } catch (error) {
                    console.error('❌ Fehler beim Laden der kontextspezifischen Templates:', error);
                }
            }
        }

        function saveContextualTemplates() {
            localStorage.setItem('swaf_contextual_templates', JSON.stringify(contextualTemplates));
            closeModal();
            showNotification('✅ Fragespezifische Formulierungen gespeichert', 'success');
        }

        // ===============================
        // PLZ-DISTANZBERECHNUNG
        // ===============================
        async function getPLZCoordinates(plz) {
            if (!plz || plz.length !== 5) return null;

            // Prüfe Cache
            if (plzCache[plz]) {
                console.log(`📍 PLZ ${plz} aus Cache geladen:`, plzCache[plz]);
                return plzCache[plz];
            }

            try {
                // Rate Limiting
                const now = Date.now();
                if (now - lastApiCall < API_DELAY) {
                    await new Promise(resolve => setTimeout(resolve, API_DELAY - (now - lastApiCall)));
                }
                lastApiCall = Date.now();

                console.log(`🌐 Lade PLZ ${plz} von OpenStreetMap...`);

                // Nominatim API Call
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&country=DE&postalcode=${plz}&limit=1`, {
                    headers: {
                        'User-Agent': 'SwaF Tandem Matcher v2.0'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data && data.length > 0) {
                    const coords = [parseFloat(data[0].lat), parseFloat(data[0].lon)];

                    // Speichere in Cache
                    plzCache[plz] = coords;
                    localStorage.setItem('swaf_plz_cache', JSON.stringify(plzCache));

                    console.log(`✅ PLZ ${plz} gefunden:`, coords);
                    return coords;
                } else {
                    console.log(`❌ PLZ ${plz} nicht gefunden`);
                    return null;
                }

            } catch (error) {
                console.error(`❌ Fehler beim Laden von PLZ ${plz}:`, error);
                return null;
            }
        }

        // Cache für Routing-Ergebnisse
        let routingCache = JSON.parse(localStorage.getItem('swaf_routing_cache') || '{}');

        async function calculatePLZDistanceAdvanced(plz1, plz2) {
            if (!plz1 || !plz2) return null;
            if (plz1 === plz2) return { 
                distance: 0, 
                type: 'same',
                mapsLinks: generateMapsLinks(plz1, plz2),
                routingInfo: 'Identische PLZ'
            };

            try {
                const coords1 = await getPLZCoordinates(plz1);
                const coords2 = await getPLZCoordinates(plz2);

                if (!coords1 || !coords2) {
                    console.log(`❌ Koordinaten nicht verfügbar für PLZ ${plz1} oder ${plz2}`);
                    return null;
                }

                // Luftlinien-Entfernung als Fallback
                const airDistance = calculateHaversineDistance(
                    coords1[0], coords1[1],
                    coords2[0], coords2[1]
                );

                // Maps-Links für genaue Navigation
                const mapsLinks = generateMapsLinks(plz1, plz2);

                // Versuche echte Routing-Distanz zu bekommen
                let routingResult = null;
                try {
                    routingResult = await getRoutingDistance(coords1, coords2, plz1, plz2);
                } catch (error) {
                    console.log('⚠️ Routing API nicht verfügbar, verwende Luftlinie:', error.message);
                }

                // Verwende Routing-Distanz wenn verfügbar, sonst Luftlinie
                const actualDistance = routingResult ? routingResult.distance : Math.round(airDistance * 1.3); // Luftlinie * 1.3 als Schätzung
                const actualTimes = routingResult ? routingResult.times : estimateTimesFromAirDistance(airDistance);

                return {
                    distance: Math.round(actualDistance),
                    airDistance: Math.round(airDistance),
                    routingDistance: routingResult ? Math.round(routingResult.distance) : null,
                    estimatedTimes: actualTimes,
                    mapsLinks: mapsLinks,
                    routingInfo: routingResult ? 'Echte Routing-Distanz' : 'Geschätzt aus Luftlinie (×1.3)',
                    type: actualDistance <= 5 ? 'very_close' :
                        actualDistance <= 15 ? 'close' :
                            actualDistance <= 30 ? 'medium' :
                                actualDistance <= 50 ? 'far' : 'very_far'
                };

            } catch (error) {
                console.error('❌ Fehler bei PLZ-Distanzberechnung:', error);
                return null;
            }
        }

        // Generiere Maps-Links für verschiedene Services
        function generateMapsLinks(plz1, plz2) {
            const googleMapsLink = `https://www.google.de/maps/dir/${encodeURIComponent(plz1)}/${encodeURIComponent(plz2)}`;
            const googleMapsTransit = `https://www.google.de/maps/dir/${encodeURIComponent(plz1)}/${encodeURIComponent(plz2)}/data=!3m1!4b1!4m2!4m1!3e3`; // ÖPNV
            const openStreetMapLink = `https://www.openstreetmap.org/directions?from=${encodeURIComponent(plz1)}&to=${encodeURIComponent(plz2)}`;
            
            return {
                googleMaps: googleMapsLink,
                googleMapsTransit: googleMapsTransit,
                openStreetMap: openStreetMapLink,
                // BVG/MVV je nach Region  
                localTransit: generateLocalTransitLink(plz1, plz2)
            };
        }

        // Generiere lokale ÖPNV-Links
        function generateLocalTransitLink(plz1, plz2) {
            // Berlin: BVG
            if ((plz1.startsWith('10') || plz1.startsWith('12') || plz1.startsWith('13')) &&
                (plz2.startsWith('10') || plz2.startsWith('12') || plz2.startsWith('13'))) {
                return `https://www.bvg.de/de/verbindungen?from=${plz1}&to=${plz2}`;
            }
            
            // München: MVV
            if (plz1.startsWith('80') || plz1.startsWith('81') || plz1.startsWith('82')) {
                return `https://www.mvv-muenchen.de/fahrplanauskunft/?from=${plz1}&to=${plz2}`;
            }
            
            // Hamburg: HVV
            if (plz1.startsWith('20') || plz1.startsWith('21') || plz1.startsWith('22')) {
                return `https://geofox.hvv.de/jsf/home.seam?from=${plz1}&to=${plz2}`;
            }
            
            // Fallback: Deutsche Bahn
            return `https://reiseauskunft.bahn.de/bin/query.exe/dn?S=${plz1}&Z=${plz2}`;
        }

        // OSRM (Open Source Routing Machine) - CORS-freundlich und kostenlos
        async function getRoutingDistance(coords1, coords2, plz1, plz2) {
            const cacheKey = `${plz1}-${plz2}`;
            
            // Prüfe Cache
            if (routingCache[cacheKey]) {
                console.log(`🔄 Routing aus Cache: ${plz1} → ${plz2}`);
                return routingCache[cacheKey];
            }
            
            // Rate Limiting
            const now = Date.now();
            if (now - lastApiCall < API_DELAY) {
                await new Promise(resolve => setTimeout(resolve, API_DELAY - (now - lastApiCall)));
            }
            lastApiCall = Date.now();

            try {
                // OSRM API - unterstützt CORS und ist kostenlos
                const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${coords1[1]},${coords1[0]};${coords2[1]},${coords2[0]}?overview=false&alternatives=false&steps=false`;
                
                console.log(`🌐 OSRM API Call: ${plz1} → ${plz2}`);
                
                const response = await fetch(osrmUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                
                if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    const distanceKm = route.distance / 1000;
                    const durationMin = route.duration / 60;
                    
                    // Erweiterte Verkehrsmittel-Schätzungen basierend auf echter Auto-Route
                    const result = {
                        distance: distanceKm,
                        times: {
                            driving: Math.round(durationMin),
                            // ÖPNV: 1.8x Auto-Zeit für Umsteigen + Wartezeiten
                            transit: Math.round(durationMin * 1.8), 
                            // Fahrrad: Realistische Geschwindigkeit je nach Distanz
                            cycling: Math.round(calculateCyclingTime(distanceKm)),
                            // Gehen: Realistische Geschwindigkeit
                            walking: Math.round(distanceKm * 12) // 5 km/h
                        }
                    };

                    // Cache speichern
                    routingCache[cacheKey] = result;
                    routingCache[`${plz2}-${plz1}`] = result; // Beide Richtungen
                    localStorage.setItem('swaf_routing_cache', JSON.stringify(routingCache));
                    
                    console.log(`✅ OSRM Routing: ${plz1} → ${plz2} = ${distanceKm.toFixed(1)}km, 🚗${Math.round(durationMin)}min`);
                    return result;
                } else {
                    throw new Error(`OSRM API Error: ${data.code || 'Keine Route gefunden'}`);
                }

            } catch (error) {
                console.log(`⚠️ OSRM Routing API Fehler für ${plz1} → ${plz2}:`, error.message);
                
                // Fallback zu GraphHopper (auch CORS-freundlich)
                try {
                    return await getGraphHopperDistance(coords1, coords2, plz1, plz2);
                } catch (fallbackError) {
                    console.log(`⚠️ GraphHopper Fallback auch fehlgeschlagen:`, fallbackError.message);
                    throw error;
                }
            }
        }

        // Fallback: GraphHopper API (kostenlos mit Limits)
        async function getGraphHopperDistance(coords1, coords2, plz1, plz2) {
            console.log(`🔄 Fallback zu GraphHopper: ${plz1} → ${plz2}`);
            
            // GraphHopper API - kostenlos bis 2500 Requests/Tag
            const ghUrl = `https://graphhopper.com/api/1/route?point=${coords1[0]},${coords1[1]}&point=${coords2[0]},${coords2[1]}&vehicle=car&debug=false&calc_points=false&key=LijBPDQGfu7Iiq80w3HzwB4RUDJbMbhs6BU0dEo`;
            
            const response = await fetch(ghUrl, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`GraphHopper HTTP ${response.status}`);
            }

            const data = await response.json();
            
            if (data.paths && data.paths.length > 0) {
                const path = data.paths[0];
                const distanceKm = path.distance / 1000;
                const durationMin = path.time / 60000; // GraphHopper gibt Zeit in ms zurück
                
                const result = {
                    distance: distanceKm,
                    times: {
                        driving: Math.round(durationMin),
                        transit: Math.round(durationMin * 1.8),
                        cycling: Math.round(calculateCyclingTime(distanceKm)),
                        walking: Math.round(distanceKm * 12)
                    }
                };

                console.log(`✅ GraphHopper Routing: ${plz1} → ${plz2} = ${distanceKm.toFixed(1)}km, 🚗${Math.round(durationMin)}min`);
                return result;
            } else {
                throw new Error('GraphHopper: Keine Route gefunden');
            }
        }

        // Realistische Fahrrad-Zeiten basierend auf Distanz
        function calculateCyclingTime(distanceKm) {
            // Fahrrad-Geschwindigkeit variiert je nach Distanz
            if (distanceKm <= 5) {
                return distanceKm * 3.5; // 17 km/h für kurze Strecken (Stadtverkehr)
            } else if (distanceKm <= 20) {
                return distanceKm * 3.8; // 16 km/h für mittlere Strecken
            } else {
                return distanceKm * 4.2; // 14 km/h für lange Strecken (Ermüdung)
            }
        }

        // Multi-Modal Routing: Verschiedene Verkehrsmittel parallel berechnen
        async function getMultiModalDistances(coords1, coords2, plz1, plz2) {
            const cacheKey = `${plz1}-${plz2}-multimodal`;
            
            // Prüfe Cache
            if (routingCache[cacheKey]) {
                console.log(`🔄 Multi-Modal aus Cache: ${plz1} → ${plz2}`);
                return routingCache[cacheKey];
            }

            try {
                // Parallel: Auto und Fahrrad-Routen
                const [carRoute, bikeRoute] = await Promise.allSettled([
                    getOSRMRoute(coords1, coords2, 'driving'),
                    getOSRMRoute(coords1, coords2, 'cycling')
                ]);

                let result = {
                    distance: null,
                    times: {
                        driving: null,
                        cycling: null,
                        transit: null,
                        walking: null
                    },
                    accuracy: 'mixed'
                };

                // Auto-Route verwenden für Basis-Distanz
                if (carRoute.status === 'fulfilled' && carRoute.value) {
                    result.distance = carRoute.value.distance;
                    result.times.driving = carRoute.value.duration;
                    result.times.transit = Math.round(carRoute.value.duration * 1.8);
                    result.times.walking = Math.round(carRoute.value.distance * 12);
                    result.accuracy = 'high';
                }

                // Fahrrad-Route falls verfügbar
                if (bikeRoute.status === 'fulfilled' && bikeRoute.value) {
                    result.times.cycling = bikeRoute.value.duration;
                } else if (result.distance) {
                    // Fallback-Berechnung für Fahrrad
                    result.times.cycling = Math.round(calculateCyclingTime(result.distance));
                }

                // Cache speichern
                if (result.distance) {
                    routingCache[cacheKey] = result;
                    localStorage.setItem('swaf_routing_cache', JSON.stringify(routingCache));
                    console.log(`✅ Multi-Modal: ${plz1} → ${plz2} = ${result.distance.toFixed(1)}km`);
                }

                return result;

            } catch (error) {
                console.error(`❌ Multi-Modal Routing fehlgeschlagen: ${error.message}`);
                throw error;
            }
        }

        // Spezifische OSRM-Route für verschiedene Verkehrsmittel
        async function getOSRMRoute(coords1, coords2, profile) {
            const profiles = {
                'driving': 'driving',
                'cycling': 'cycling', 
                'walking': 'foot'
            };

            const osrmProfile = profiles[profile] || 'driving';
            const url = `https://router.project-osrm.org/route/v1/${osrmProfile}/${coords1[1]},${coords1[0]};${coords2[1]},${coords2[0]}?overview=false&alternatives=false&steps=false`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`OSRM ${profile} HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                return {
                    distance: route.distance / 1000,
                    duration: Math.round(route.duration / 60)
                };
            } else {
                throw new Error(`OSRM ${profile}: ${data.code || 'Keine Route'}`);
            }
        }

        // Fallback: Schätze Zeiten aus Luftlinie
        function estimateTimesFromAirDistance(airDistance) {
            return {
                walking: Math.round(airDistance * 12), // ~5 km/h
                cycling: Math.round(airDistance * 4),  // ~15 km/h
                transit: Math.round(airDistance * 2.5), // ~25 km/h mit Umsteigen
                driving: Math.round(airDistance * 1.5)  // ~40 km/h in der Stadt
            };
        }

        function extractPLZ(text) {
            if (!text) return null;

            // Suche nach 5-stelliger PLZ
            const plzMatch = text.match(/\b(\d{5})\b/);
            if (plzMatch) {
                return plzMatch[1];
            }

            return null;
        }

        function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Erdradius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);

            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c;

            return distance;
        }

        async function testPLZDistanceAPI() {
            const testCases = [
                ['10115', '10117'], // Berlin intern
                ['10115', '80331'], // Berlin - München
                ['50667', '40210']  // Köln - Düsseldorf
            ];

            console.log('🧪 PLZ-Distanz API Tests:');

            for (const [plz1, plz2] of testCases) {
                const result = await calculatePLZDistanceAdvanced(plz1, plz2);
                if (result) {
                    console.log(`${plz1} ↔ ${plz2}: ${result.distance} km (${result.type})`);
                    console.log(`  Geschätzte Zeiten: 🚶 ${result.estimatedTimes.walking}min, 🚲 ${result.estimatedTimes.cycling}min, 🚌 ${result.estimatedTimes.transit}min, 🚗 ${result.estimatedTimes.driving}min`);
                } else {
                    console.log(`${plz1} ↔ ${plz2}: API-Fehler`);
                }
            }

            showNotification('PLZ-Distanz API Tests in Konsole ausgegeben', 'info');
        }

        // Neue Test-Funktion für erweiterte PLZ-Features
        // Neue Test-Funktion für erweiterte PLZ-Features
        async function testAdvancedPLZFeatures() {
            console.log('🗺️ === ERWEITERTE PLZ-FUNKTIONEN TEST (ECHTE ROUTEN) ===');
            
            const testCases = [
                ['10115', '10117'], // Berlin intern - sollte echte Route finden
                ['80331', '10115'], // München - Berlin - Fernstrecke
                ['50667', '40210']  // Köln - Düsseldorf - Regional
            ];

            for (const [plz1, plz2] of testCases) {
                console.log(`\n📍 Test: ${plz1} → ${plz2}`);
                
                try {
                    const result = await calculatePLZDistanceAdvanced(plz1, plz2);
                    
                    if (result) {
                        console.log(`  🎯 Distanz: ${result.distance}km (${result.routingInfo})`);
                        console.log(`  📏 Luftlinie: ${result.airDistance}km`);
                        if (result.routingDistance) {
                            console.log(`  🛣️ Routing: ${result.routingDistance}km`);
                            console.log(`  📊 Routing-Faktor: ${(result.routingDistance / result.airDistance).toFixed(2)}x`);
                        }
                        console.log(`  ⏱️ Zeiten: 🚗 ${result.estimatedTimes.driving}min, 🚌 ${result.estimatedTimes.transit}min, 🚲 ${result.estimatedTimes.cycling}min, 🚶 ${result.estimatedTimes.walking}min`);
                        console.log(`  🗺️ Google Maps: ${result.mapsLinks.googleMaps}`);
                        console.log(`  🚌 ÖPNV: ${result.mapsLinks.googleMapsTransit}`);
                        console.log(`  🌍 OpenStreetMap: ${result.mapsLinks.openStreetMap}`);
                        console.log(`  🚇 Lokale ÖPNV: ${result.mapsLinks.localTransit}`);
                        
                        // Zeige Qualität der Routing-Daten
                        if (result.routingInfo === 'Echte Routing-Distanz') {
                            console.log(`  ✅ ECHTE ROUTE berechnet!`);
                        } else {
                            console.log(`  ⚠️ Schätzung verwendet (API nicht verfügbar)`);
                        }
                    } else {
                        console.log(`  ❌ Berechnung fehlgeschlagen`);
                    }
                } catch (error) {
                    console.log(`  ❌ Fehler: ${error.message}`);
                }
            }
            
            showNotification('🗺️ Echte Routing-Tests in Konsole ausgegeben', 'info', 4000);
        }

        // Funktion für interaktive PLZ-Distanz-Berechnung
        function interactivePLZTest() {
            const plz1 = prompt('Erste PLZ eingeben:');
            const plz2 = prompt('Zweite PLZ eingeben:');
            
            if (plz1 && plz2) {
                calculatePLZDistanceAdvanced(plz1, plz2).then(result => {
                    if (result) {
                        const links = result.mapsLinks;
                        const message = `🗺️ PLZ-Distanz Ergebnis:\n\n` +
                            `📍 ${plz1} → ${plz2}\n` +
                            `🎯 Distanz: ${result.distance}km (${result.routingInfo})\n` +
                            `📏 Luftlinie: ${result.airDistance}km\n` +
                            `⏱️ Zeiten:\n` +
                            `  🚗 Auto: ${result.estimatedTimes.driving} min\n` +
                            `  🚌 ÖPNV: ${result.estimatedTimes.transit} min\n` +
                            `  🚲 Fahrrad: ${result.estimatedTimes.cycling} min\n\n` +
                            `🗺️ Navigation:\n` +
                            `• Google Maps: ${links.googleMaps}\n` +
                            `• ÖPNV: ${links.googleMapsTransit}\n` +
                            `• OpenStreetMap: ${links.openStreetMap}\n` +
                            `• Lokale ÖPNV: ${links.localTransit}`;
                        
                        alert(message);
                        
                        // Öffne Google Maps Link
                        if (confirm('Google Maps für genaue Route öffnen?')) {
                            window.open(links.googleMaps, '_blank');
                        }
                    } else {
                        alert('❌ PLZ-Distanz konnte nicht berechnet werden');
                    }
                });
            }
        }

        // Debug-Funktion für Routing-Cache
        function debugRoutingCache() {
            console.log('💾 === ROUTING CACHE DEBUG ===');
            console.log(`📊 Cache-Einträge: ${Object.keys(routingCache).length}`);
            console.log('🗂️ Gespeicherte Routen:');
            
            Object.entries(routingCache).forEach(([key, value]) => {
                console.log(`  ${key}: ${value.distance.toFixed(1)}km, ${value.times.driving}min Auto`);
            });
            
            const cacheSize = JSON.stringify(routingCache).length;
            console.log(`💾 Cache-Größe: ${(cacheSize / 1024).toFixed(1)} KB`);
            
            showNotification(`💾 Routing-Cache: ${Object.keys(routingCache).length} Routen gespeichert`, 'info');
        }

        // Routing-Cache leeren
        function clearRoutingCache() {
            if (confirm('Routing-Cache leeren? Alle gespeicherten Distanzen werden neu berechnet.')) {
                routingCache = {};
                localStorage.removeItem('swaf_routing_cache');
                showNotification('💾 Routing-Cache geleert', 'success');
            }
        }

        // ===============================
        // DATENBEREINIGUNG
        // ===============================
        function cleanProfileAnswer(answer) {
            if (!answer || typeof answer !== 'string') {
                return '';
            }

            let cleaned = answer.trim();

            // Liste der zu entfernenden Formulierungen
            const unwantedPhrases = [
                // Standardformulierungen
                '-- Hier kannst du etwas auswählen --',
                'Hier kannst du etwas auswählen',

                // Sonstiges-Einträge
                'sonstiges:,',
                'sonstiges:',
                'sonstiges,',
                'Sonstiges:,',
                'Sonstiges:',
                'Sonstiges,',

                // Andere Grund-Einträge
                'Anderer Grund:,',
                'Anderer Grund:',
                'anderer Grund:,',
                'anderer Grund:',
                'Anderer Grund,',
                'anderer Grund,',

                // Anderes-Einträge
                'anderes:,',
                'anderes:',
                'anderes,',
                'Anderes:,',
                'Anderes:',
                'Anderes,',

                // Beschreibungs-Aufforderungen
                'Etwas anderes (bitte genauer beschreiben),',
                'Etwas anderes (bitte genauer beschreiben)',
                'etwas anderes (bitte genauer beschreiben),',
                'etwas anderes (bitte genauer beschreiben)',
                'Bitte genauer beschreiben',
                'bitte genauer beschreiben',

                // Leere Auswahlen
                'Keine Auswahl',
                'keine Auswahl',
                'Nicht ausgewählt',
                'nicht ausgewählt',
                'Bitte auswählen',
                'bitte auswählen',

                // Weitere häufige Störer
                'Weitere Angaben:',
                'weitere Angaben:',
                'Weitere Angaben,',
                'weitere Angaben,',
                'Freitext:',
                'freitext:',
                'Kommentar:',
                'kommentar:',

                // Leer-Indikatoren
                '---',
                'n/a',
                'N/A',
                'k.A.',
                'k.a.',
                'unbekannt',
                'Unbekannt'
            ];

            // Entferne unwanted phrases
            unwantedPhrases.forEach(phrase => {
                // Case-insensitive Ersetzung am Anfang des Strings
                const regex1 = new RegExp('^\\s*' + escapeRegExp(phrase) + '\\s*', 'gi');
                cleaned = cleaned.replace(regex1, '');

                // Case-sensitive Ersetzung überall
                const regex2 = new RegExp('\\s*' + escapeRegExp(phrase) + '\\s*', 'g');
                cleaned = cleaned.replace(regex2, ' ');
            });

            // Zusätzliche Bereinigung für "Sonstige:" und "Andere:" Präfixe
            cleaned = cleaned
                .replace(/^sonstige\s*:\s*/gi, '')
                .replace(/^andere\s*:\s*/gi, '')
                .replace(/^weitere\s*:\s*/gi, '')
                .replace(/^zusätzlich\s*:\s*/gi, '')
                .replace(/,\s*sonstige\s*:\s*/gi, ', ')
                .replace(/,\s*andere\s*:\s*/gi, ', ')
                .replace(/;\s*sonstige\s*:\s*/gi, '; ')
                .replace(/;\s*andere\s*:\s*/gi, '; ');

            // Bereinige weitere Muster
            cleaned = cleaned
                // Entferne führende/trailing Kommas und Semikolons
                .replace(/^[,;:\s]+|[,;:\s]+$/g, '')
                // Entferne doppelte Kommas/Semikolons
                .replace(/[,;]{2,}/g, ',')
                // Entferne einzelne Kommas/Semikolons am Ende
                .replace(/[,;]\s*$/, '')
                // Entferne leere Klammern
                .replace(/\(\s*\)/g, '')
                // Entferne mehrfache Leerzeichen
                .replace(/\s{2,}/g, ' ')
                // Normalisiere Trennzeichen
                .replace(/[,;]\s*[,;]/g, ',')
                // Entferne führende Punkte/Striche
                .replace(/^[\.\-\s]+/, '')
                .trim();

            // Spezielle Bereinigung für Liste-Felder
            if (cleaned.includes(',') || cleaned.includes(';')) {
                const items = cleaned.split(/[,;]/)
                    .map(item => item.trim())
                    .filter(item => item.length > 0)
                    .filter(item => !unwantedPhrases.some(phrase =>
                        item.toLowerCase() === phrase.toLowerCase()
                    ));

                cleaned = items.join(', ');
            }

            // Final cleanup
            cleaned = cleaned.trim();

            // Log bei signifikanten Änderungen
            if (answer !== cleaned && cleaned.length < answer.length * 0.8) {
                console.log(`🧹 Bereinigung: "${answer}" → "${cleaned}"`);
            }

            return cleaned;
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function testDataCleaning() {
            const testCases = [
                '-- Hier kannst du etwas auswählen --, Sport, Musik',
                'Fußball, sonstiges:, Tennis',
                'Anderer Grund:, Ich mag Filme schauen',
                'Kochen, anderes:, Wandern',
                'Etwas anderes (bitte genauer beschreiben), Yoga, Meditation',
                'Sport, Tennis, ---',
                'Musik hören, n/a, Konzerte besuchen',
                'sonstiges:, anderes:, Etwas anderes (bitte genauer beschreiben), Kochen'
            ];

            console.log('🧹 Datenbereinigung Tests:');
            testCases.forEach((testCase, index) => {
                const cleaned = cleanProfileAnswer(testCase);
                console.log(`${index + 1}. "${testCase}"`);
                console.log(`   → "${cleaned}"`);
                console.log('');
            });

            showNotification('Datenbereinigung Tests in Konsole ausgegeben', 'info');
        }

        // ===============================
        // HILFSFUNKTIONEN
        // ===============================
        function saveProfiles() {
            localStorage.setItem('swaf_profiles', JSON.stringify(profiles));
        }

        function saveTandems() {
            localStorage.setItem('swaf_tandems', JSON.stringify(tandems));
        }

        function saveAllData() {
            saveProfiles();
            saveTandems();
            localStorage.setItem('swaf_selected_fields', JSON.stringify(selectedFields));
        }

        function quickSave() {
            saveAllData();
            showNotification('💾 Daten gespeichert', 'success', 2000);

            const fab = document.querySelector('.fab');
            fab.style.transform = 'scale(1.2)';
            setTimeout(() => {
                fab.style.transform = 'scale(1)';
            }, 200);
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType + ';charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        function createModal(title, content, buttons) {
            // Entferne existierende Modals
            document.querySelectorAll('.modal-overlay').forEach(m => m.remove());

            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.setAttribute('data-modal-id', Date.now());

            // Erstelle Modal-HTML
            modal.innerHTML = `
                <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
                    <h3 style="color: var(--swaf-red); margin-bottom: 1rem;">${title}</h3>
                    ${content}
                    <div id="modal-buttons-${modal.getAttribute('data-modal-id')}" style="text-align: right; margin-top: 1.5rem; display: flex; gap: 0.5rem; justify-content: flex-end;">
                        <!-- Buttons werden via JavaScript hinzugefügt -->
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Füge Buttons programmatisch hinzu
            const buttonContainer = document.getElementById(`modal-buttons-${modal.getAttribute('data-modal-id')}`);
            
            buttons.forEach((btn, index) => {
                const button = document.createElement('button');
                button.className = `btn ${btn.class}`;
                button.textContent = btn.text;
                
                // Event Listener für Button-Aktionen
                button.addEventListener('click', function() {
                    if (typeof btn.action === 'string') {
                        if (btn.action === 'closeModal') {
                            closeModal();
                        } else {
                            // Versuche globale Funktion aufzurufen
                            try {
                                const func = window[btn.action];
                                if (typeof func === 'function') {
                                    func();
                                } else {
                                    console.error('Funktion nicht gefunden:', btn.action);
                                }
                            } catch (error) {
                                console.error('Fehler beim Ausführen der Funktion:', btn.action, error);
                            }
                        }
                    } else if (typeof btn.action === 'function') {
                        btn.action();
                    }
                });
                
                buttonContainer.appendChild(button);
            });

            return modal;
        }

        function debugModalSystem() {
            console.log('🔧 Modal System Debug:');
            console.log('- Aktive Modals:', document.querySelectorAll('.modal-overlay').length);
            console.log('- Window functions verfügbar:', {
                processDuplicateChoice: typeof window.processDuplicateChoice,
                confirmManualMerge: typeof window.confirmManualMerge,
                addNewProfile: typeof window.addNewProfile,
                closeModal: typeof window.closeModal
            });
            
            showNotification('Modal Debug-Info in Konsole ausgegeben', 'info');
        }

        function closeModal() {
            document.querySelectorAll('.modal-overlay').forEach(m => m.remove());
        }

        // ===============================
        // DEBUG-FUNKTIONEN
        // ===============================
        function showDebugInfo() {
            const info = `
=== SwaF Tandem Matcher Debug Info ===

Profile geladen: ${profiles.length}
Tandems erstellt: ${tandems.length}

Profile im Detail:
${profiles.map((p, i) => `${i + 1}. ${p.name} (${p.fields.length} Felder)`).join('\n')}

Tandems im Detail:
${tandems.map((t, i) => `${i + 1}. ${t.name} (${t.commonalities.length} Gemeinsamkeiten)`).join('\n')}

localStorage Status:
- Profiles: ${localStorage.getItem('swaf_profiles') ? 'Vorhanden' : 'Leer'}
- Tandems: ${localStorage.getItem('swaf_tandems') ? 'Vorhanden' : 'Leer'}
- Bookmarklet Daten: ${localStorage.getItem('swaf_bookmarklet_data') ? 'Vorhanden' : 'Leer'}
- Text Templates: ${localStorage.getItem('swaf_text_templates') ? textTemplates.length + ' Stück' : 'Leer'}

Datenqualität:
- Durchschn. Antwortlänge: ${profiles.length > 0 ? Math.round(profiles.reduce((sum, p) => sum + p.fields.reduce((fSum, f) => fSum + f.answer.length, 0), 0) / profiles.reduce((sum, p) => sum + p.fields.length, 0)) : 0} Zeichen
- Leere Antworten: ${profiles.reduce((sum, p) => sum + p.fields.filter(f => !f.answer || f.answer.trim().length === 0).length, 0)}
- Profile mit > 10 Feldern: ${profiles.filter(p => p.fields.length > 10).length}
            `;

            alert(info);
            console.log(info);
        }

        function testLocalStorage() {
            try {
                localStorage.setItem('test', 'value');
                const result = localStorage.getItem('test');
                localStorage.removeItem('test');

                if (result === 'value') {
                    showNotification('✅ localStorage funktioniert korrekt', 'success');
                } else {
                    showNotification('❌ localStorage-Problem erkannt', 'error');
                }
            } catch (e) {
                showNotification('❌ localStorage nicht verfügbar: ' + e.message, 'error');
            }
        }

        function checkForBookmarkletData() {
            try {
                const data = localStorage.getItem('swaf_bookmarklet_data');
                if (data) {
                    console.log('📥 Fallback: Bookmarklet-Daten in localStorage gefunden:', data);
                    const profileData = JSON.parse(data);
                    receiveProfileData(profileData);
                    localStorage.removeItem('swaf_bookmarklet_data');
                    showNotification('📥 Profil über localStorage empfangen (Fallback-Methode)', 'success');
                } else {
                    showNotification('ℹ️ Keine Bookmarklet-Daten in localStorage gefunden', 'info');
                }
            } catch (e) {
                console.error('❌ Fehler beim Prüfen der localStorage-Daten:', e);
                showNotification('❌ Fehler beim Prüfen der localStorage-Daten', 'error');
            }
        }

        function testClipboardFormat() {
            console.log('🧪 Teste Clipboard-Format...');

            // Erstelle Test-Daten im erwarteten Format
            const testProfile = {
                url: 'https://portal.startwithafriend.de/test',
                name: 'Test Clipboard Format',
                fields: [
                    { question: 'Test Frage 1', answer: 'Test Antwort 1' },
                    { question: 'Test Frage 2', answer: 'Test Antwort mit "Anführungszeichen"' },
                    { question: 'Test Frage 3', answer: 'Test\nAntwort\nmit\nZeilenumbrüchen' }
                ]
            };

            const testData = 'SWAF_PROFILE_START' + JSON.stringify(testProfile) + 'SWAF_PROFILE_END';

            console.log('📋 Test-Daten erstellt:', testData);

            // Kopiere Test-Daten in Zwischenablage
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(testData).then(function () {
                    showNotification('✅ Test-Daten in Zwischenablage kopiert. Prüfe jetzt mit "📋 Zwischenablage prüfen"', 'success', 5000);
                }).catch(function (error) {
                    console.error('Fehler beim Kopieren der Test-Daten:', error);
                    showTestDataManually(testData);
                });
            } else {
                showTestDataManually(testData);
            }
        }

        function showTestDataManually(testData) {
            createModal('🧪 Test-Daten für Clipboard', `
                <p>Kopiere diese Test-Daten manuell in die Zwischenablage:</p>
                <textarea readonly style="width: 100%; height: 150px; font-family: monospace; font-size: 0.8rem;">${testData}</textarea>
                <p>Danach verwende "📋 Zwischenablage prüfen" um das Format zu testen.</p>
            `, [
                { text: 'Test-Daten kopiert', class: 'btn-primary', action: 'closeModal' }
            ]);
        }

        // ===============================
        // WEITERE UI-FUNKTIONEN
        // ===============================
        function addTestProfile() {
            const testProfile = {
                url: 'test://demo',
                name: `Test Person ${profiles.length + 1}`,
                fields: [
                    { question: 'Alter', answer: '25' },
                    { question: 'Wohnort', answer: 'Berlin' },
                    { question: 'Hobbys', answer: 'Fußball, Lesen, Musik' },
                    { question: 'Sprachen', answer: 'Deutsch, Englisch' },
                    { question: 'Beruf', answer: 'Student' }
                ]
            };

            receiveProfileData(testProfile);
        }

        function showManualInput() {
            const modal = createModal('✏️ Profil manuell eingeben', `
                <div class="form-group">
                    <label>Name der Person:</label>
                    <input type="text" id="manual-name" placeholder="z.B. Max Mustermann">
                </div>
                
                <div class="form-group">
                    <label>Profil-Daten (Format: Frage: Antwort, eine pro Zeile):</label>
                    <textarea id="manual-fields" rows="10" placeholder="Alter: 25&#10;Hobbys: Fußball, Lesen&#10;Wohnort: Berlin&#10;Sprachen: Deutsch, Englisch&#10;Beruf: Student"></textarea>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Profil speichern', class: 'btn-primary', action: 'saveManualProfile' }
            ]);
        }

        function saveManualProfile() {
            const name = document.getElementById('manual-name').value.trim();
            const fieldsText = document.getElementById('manual-fields').value.trim();

            if (!name) {
                alert('Bitte gib einen Namen ein.');
                return;
            }

            if (!fieldsText) {
                alert('Bitte gib mindestens ein Feld ein.');
                return;
            }

            const fields = [];
            const lines = fieldsText.split('\n');

            lines.forEach(line => {
                const colonIndex = line.indexOf(':');
                if (colonIndex > 0) {
                    const question = line.substring(0, colonIndex).trim();
                    let answer = line.substring(colonIndex + 1).trim();

                    // Bereinige auch manuell eingegebene Antworten
                    answer = cleanProfileAnswer(answer);

                    if (question && answer && answer.length > 0) {
                        fields.push({ question, answer });
                    }
                }
            });

            if (fields.length === 0) {
                alert('Keine gültigen Felder gefunden. Format: "Frage: Antwort"');
                return;
            }

            const profileData = {
                url: 'manual_input',
                name: name,
                fields: fields
            };

            receiveProfileData(profileData);
            closeModal();
        }

        function pasteFromClipboard() {
            console.log('📋 Manuelles Einfügen aus Zwischenablage...');

            if (navigator.clipboard && navigator.clipboard.readText) {
                navigator.clipboard.readText().then(function (text) {
                    if (text.includes('SWAF_PROFILE_START') && text.includes('SWAF_PROFILE_END')) {
                        processClipboardProfileData(text);
                    } else {
                        showManualPasteDialog();
                    }
                }).catch(function (error) {
                    console.error('Zwischenablage-Zugriff fehlgeschlagen:', error);
                    showManualPasteDialog();
                });
            } else {
                showManualPasteDialog();
            }
        }

        function showManualPasteDialog() {
            createModal('📋 Profildaten einfügen', `
                <p>Füge die kopierten Profildaten hier ein:</p>
                <div class="form-group">
                    <textarea id="manual-paste-data" rows="6" placeholder="SWAF_PROFILE_START{...}SWAF_PROFILE_END" style="font-family: monospace; font-size: 0.9rem;"></textarea>
                </div>
                <div class="alert alert-info">
                    <strong>Tipp:</strong> Die Daten sollten mit "SWAF_PROFILE_START" beginnen und mit "SWAF_PROFILE_END" enden.
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Verarbeiten', class: 'btn-primary', action: 'processManualPasteData' }
            ]);
        }

        function processManualPasteData() {
            const text = document.getElementById('manual-paste-data').value;
            if (text.trim()) {
                processClipboardProfileData(text);
                closeModal();
            } else {
                alert('Bitte füge die Profildaten ein.');
            }
        }

        function showDebugClipboardData(text, errorMessage) {
            const modal = createModal('🔧 Debug: Zwischenablage-Daten', `
                <div class="alert alert-error">
                    <strong>Fehler:</strong> ${errorMessage}
                </div>
                
                <h4>📋 Rohdaten aus Zwischenablage:</h4>
                <textarea readonly style="width: 100%; height: 150px; font-family: monospace; font-size: 0.8rem;">${text}</textarea>
                
                <h4>🔍 Debug-Informationen:</h4>
                <ul>
                    <li>Textlänge: ${text.length} Zeichen</li>
                    <li>Start-Marker gefunden: ${text.includes('SWAF_PROFILE_START') ? '✅' : '❌'}</li>
                    <li>End-Marker gefunden: ${text.includes('SWAF_PROFILE_END') ? '✅' : '❌'}</li>
                    <li>Enthält JSON-Zeichen: ${text.includes('{') && text.includes('}') ? '✅' : '❌'}</li>
                </ul>
                
                <div class="form-group">
                    <label>Korrigierte Daten (optional):</label>
                    <textarea id="debug-corrected-data" rows="4" placeholder="Korrigiere die Daten hier oder verwende das Bookmarklet erneut..."></textarea>
                </div>
            `, [
                { text: 'Bookmarklet erneut verwenden', class: 'btn-outline', action: 'closeModal' },
                { text: 'Korrigierte Daten verarbeiten', class: 'btn-primary', action: 'processCorrectedData' }
            ]);
        }

        function processCorrectedData() {
            const correctedData = document.getElementById('debug-corrected-data').value.trim();
            if (correctedData) {
                processClipboardProfileData(correctedData);
                closeModal();
            } else {
                alert('Bitte gib korrigierte Daten ein oder verwende das Bookmarklet erneut.');
            }
        }

        function showInstructions() {
            createModal('📖 Detaillierte Anleitung', `
                <div style="text-align: left;">
                    <h4>🔄 Neue Zwischenablage-Methode:</h4>
                    <p>Das Bookmarklet kopiert Profildaten automatisch in die Zwischenablage und diese App erkennt sie automatisch!</p>
                    
                    <h4>1. Bookmarklet installieren:</h4>
                    <p>Ziehe den roten "SwaF Sammler" Button in deine Lesezeichen-Leiste. Falls das nicht funktioniert, erstelle ein neues Lesezeichen und kopiere den JavaScript-Code hinein.</p>
                    
                    <h4>2. Portal öffnen:</h4>
                    <p>Gehe zu <a href="https://portal.startwithafriend.de" target="_blank">portal.startwithafriend.de</a> und logge dich ein.</p>
                    
                    <h4>3. Profile sammeln:</h4>
                    <p>Öffne ein Teilnehmer-Profil und klicke das "SwaF Sammler" Bookmarklet. Die Daten werden automatisch in die Zwischenablage kopiert.</p>
                    
                    <h4>4. Zurück zur App:</h4>
                    <p>Wechsle zurück zu dieser App. Die Profildaten werden automatisch erkannt und hinzugefügt!</p>
                    
                    <h4>📋 Alternative Methoden:</h4>
                    <ul>
                        <li><strong>Strg+V:</strong> Profildaten aus Zwischenablage einfügen</li>
                        <li><strong>Button "Aus Zwischenablage einfügen":</strong> Manuelles Einfügen</li>
                        <li><strong>Fenster-Fokus:</strong> Automatische Erkennung beim Zurückkehren zur App</li>
                    </ul>
                    
                    <h4>🔧 Problembehandlung:</h4>
                    <ul>
                        <li><strong>Bookmarklet funktioniert nicht:</strong> Erstelle manuell ein Lesezeichen mit dem JavaScript-Code</li>
                        <li><strong>Keine Datenübertragung:</strong> Verwende "📋 Zwischenablage prüfen" oder "📥 Manuell einfügen"</li>
                        <li><strong>Cross-Domain-Probleme:</strong> Das neue System umgeht diese durch Zwischenablage-Transfer</li>
                        <li><strong>Felder werden nicht erkannt:</strong> Das Portal-Layout könnte sich geändert haben</li>
                    </ul>
                    
                    <div style="background: var(--swaf-lightest-teal); padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>✨ Automatische Erkennung:</strong> Die App erkennt SwaF-Profildaten automatisch in der Zwischenablage und beim Fokus-Wechsel!
                    </div>
                </div>
            `, [
                { text: 'Verstanden', class: 'btn-primary', action: 'closeModal' }
            ]);
        }

        function toggleBookmarkletStatus() {
            const checkbox = document.getElementById('bookmarklet-installed');
            const installSection = document.getElementById('bookmarklet-install-section');

            if (checkbox.checked) {
                installSection.style.display = 'none';
                localStorage.setItem('swaf_bookmarklet_installed', 'true');
                showNotification('✅ Bookmarklet als installiert markiert', 'success', 3000);
            } else {
                installSection.style.display = 'block';
                localStorage.removeItem('swaf_bookmarklet_installed');
            }
        }

        function updateExportPreview() {
            // Optional: Preview implementation
        }

        function debugMatchingState() {
            console.log('🔍 === MATCHING DEBUG INFO ===');
            console.log('📊 Anzahl Profile gesamt:', profiles.length);
            console.log('📋 Ausgewählte Profile IDs:', selectedProfiles);
            console.log('🎯 Ausgewähltes Tandem:', selectedTandemPairId);
            console.log('🤝 Anzahl Tandems:', tandems.length);

            // Prüfe DOM-Elemente
            const selectedElements = document.querySelectorAll('.profile-item.selected');
            console.log('🎨 Visuell ausgewählte Profile:', selectedElements.length);

            selectedElements.forEach((el, index) => {
                const profileId = el.getAttribute('data-profile-id');
                console.log(`  ${index + 1}. Element mit ID: ${profileId}`);
            });

            // Validiere ausgewählte Profile
            selectedProfiles.forEach((id, index) => {
                const profile = profiles.find(p => p.id == id);
                if (profile) {
                    console.log(`✅ Profil ${index + 1}: ${profile.name} (ID: ${id}, Typ: ${typeof id})`);
                } else {
                    console.log(`❌ Profil ${index + 1}: ID ${id} (Typ: ${typeof id}) nicht gefunden!`);
                    console.log(`   Verfügbare IDs: ${profiles.map(p => `${p.id}(${typeof p.id})`).join(', ')}`);
                }
            });

            const debugInfo = `
=== SwaF Matching Debug Info ===

📊 Statistiken:
- Profile geladen: ${profiles.length}
- Profile ausgewählt: ${selectedProfiles.length}
- Tandems erstellt: ${tandems.length}
- Visuell markierte Profile: ${selectedElements.length}

📋 Ausgewählte Profile:
${selectedProfiles.map((id, i) => {
                const profile = profiles.find(p => p.id == id);
                return `${i + 1}. ${profile ? profile.name : 'NICHT GEFUNDEN'} (ID: ${id}, Typ: ${typeof id})`;
            }).join('\n')}

🔧 Profile-ID Debug:
${profiles.map(p => `- ${p.name}: ID ${p.id} (${typeof p.id})`).join('\n')}

🎨 DOM-Status:
- Elemente mit .selected Klasse: ${selectedElements.length}
- Match-Button aktiviert: ${!document.getElementById('match-btn')?.disabled}

🔧 Mögliche Probleme:
${selectedProfiles.length !== selectedElements.length ? '❌ Auswahl-Array und DOM nicht synchron!' : '✅ Auswahl-Array und DOM synchron'}
${selectedProfiles.length > 2 ? '❌ Zu viele Profile ausgewählt!' : '✅ Anzahl Profile OK'}
${selectedProfiles.some(id => !profiles.find(p => p.id == id)) ? '❌ Nicht alle ausgewählten Profile existieren!' : '✅ Alle ausgewählten Profile existieren'}
            `;

            alert(debugInfo);
            console.log(debugInfo);
        }

        function fixProfileSelection() {
            console.log('🔧 Repariere Profile-Auswahl-IDs...');

            // Backup der alten Auswahl
            const oldSelection = [...selectedProfiles];
            console.log('💾 Alte Auswahl:', oldSelection);

            // Lösche aktuelle Auswahl
            selectedProfiles = [];

            // Entferne alle visuellen Markierungen
            document.querySelectorAll('.profile-item.selected').forEach(el => {
                el.classList.remove('selected');
            });

            // Versuche die Auswahl zu rekonstruieren basierend auf DOM-Markierungen
            const selectedElements = document.querySelectorAll('.profile-item.selected');
            selectedElements.forEach(el => {
                const profileId = el.getAttribute('data-profile-id');
                if (profileId) {
                    selectedProfiles.push(profileId);
                    console.log('🔧 Wiederhergestellt:', profileId);
                }
            });

            // Falls keine DOM-Markierungen, versuche die alten IDs zu konvertieren
            if (selectedProfiles.length === 0 && oldSelection.length > 0) {
                console.log('🔄 Konvertiere alte IDs...');
                oldSelection.forEach(oldId => {
                    // Finde Profile mit flexiblem Typ-Vergleich
                    const profile = profiles.find(p => p.id == oldId);
                    if (profile) {
                        selectedProfiles.push(profile.id);
                        console.log(`✅ Konvertiert: ${oldId} -> ${profile.id} (${profile.name})`);
                    } else {
                        console.log(`❌ Konnte nicht konvertieren: ${oldId}`);
                    }
                });
            }

            console.log('✅ Neue Auswahl:', selectedProfiles);

            // UI aktualisieren
            loadAvailableProfiles();
            updateMatchingStatus();

            if (selectedProfiles.length > 0) {
                showNotification(`🔧 ${selectedProfiles.length} Profile-IDs repariert und wiederhergestellt`, 'success');
            } else {
                showNotification('🔧 IDs repariert - Profile-Auswahl zurückgesetzt', 'info');
            }
        }

        function testPLZDistance() {
            const testCases = [
                ['10115', '10117'], 
                ['80331', '10115'], 
                ['50667', '40210']  
            ];

            console.log('📍 PLZ-Distanz Tests (Synchron):');
            testCases.forEach(([plz1, plz2]) => {
                // Zeige nur synchrone Berechnungen
                console.log(`${plz1} ↔ ${plz2}: Berechnung läuft...`);
            });

            showNotification('PLZ-Distanz Tests werden in Konsole ausgegeben', 'info');
        }

        function generateContextualTemplatesHTML() {
            let html = '';

            Object.keys(contextualTemplates).forEach(category => {
                const templates = contextualTemplates[category];
                const categoryDisplayName = getCategoryDisplayName(category);

                html += `
                    <div class="contextual-category-section" style="border: 2px solid var(--swaf-teal); border-radius: 8px; margin: 1rem 0; padding: 1rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h4 style="margin: 0; color: var(--swaf-red);">
                                📂 ${categoryDisplayName} (${category})
                            </h4>
                            <div>
                                <button class="btn btn-outline btn-small" onclick="addTemplateToCategory('${category}')">➕ Template hinzufügen</button>
                                <button class="btn btn-outline btn-small" onclick="deleteCategory('${category}')" style="background: var(--swaf-red); color: white;">🗑️ Kategorie löschen</button>
                            </div>
                        </div>
                        
                        <table style="width: 100%; border-collapse: collapse; background: white;">
                            <thead>
                                <tr style="background: var(--swaf-teal); color: white;">
                                    <th style="padding: 0.5rem; border: 1px solid #ddd; width: 80px;">Priorität</th>
                                    <th style="padding: 0.5rem; border: 1px solid #ddd;">Formulierungstext</th>
                                    <th style="padding: 0.5rem; border: 1px solid #ddd; width: 120px;">Aktionen</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${templates.map((template, index) => `
                                    <tr>
                                        <td style="padding: 0.5rem; border: 1px solid #ddd; text-align: center;">
                                            <input type="checkbox" 
                                                ${template.priority ? 'checked' : ''} 
                                                onchange="toggleTemplatePriority('${category}', ${index})"
                                                title="Empfohlenes Template">
                                            <br><small>Empfohlen</small>
                                        </td>
                                        <td style="padding: 0.5rem; border: 1px solid #ddd;">
                                            <textarea style="width: 100%; min-height: 50px; border: 1px solid #ccc; padding: 0.3rem;" 
                                                    onchange="updateTemplateText('${category}', ${index}, this.value)">${template.text}</textarea>
                                        </td>
                                        <td style="padding: 0.5rem; border: 1px solid #ddd; text-align: center;">
                                            <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                                                <button class="btn btn-outline btn-small" 
                                                        onclick="moveTemplate('${category}', ${index}, -1)" 
                                                        ${index === 0 ? 'disabled' : ''}>↑</button>
                                                <button class="btn btn-outline btn-small" 
                                                        onclick="moveTemplate('${category}', ${index}, 1)" 
                                                        ${index === templates.length - 1 ? 'disabled' : ''}>↓</button>
                                                <button class="btn btn-outline btn-small" 
                                                        onclick="deleteTemplate('${category}', ${index})" 
                                                        style="background: var(--swaf-red); color: white;">🗑️</button>
                                            </div>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            });

            return html;
        }

        function getCategoryDisplayName(category) {
            const displayNames = {
                'alter': 'Alter & Lebenssituation',
                'hobby': 'Hobbys & Interessen',
                'sprache': 'Sprachen & Kommunikation',
                'postleitzahl': 'Postleitzahl & Entfernung',
                'wohnort': 'Wohnort & Region',
                'beruf': 'Beruf & Arbeit',
                'studium': 'Bildung & Studium',
                'zeit': 'Zeit & Verfügbarkeit',
                'verkehr': 'Mobilität & Transport'
            };

            return displayNames[category] || category.charAt(0).toUpperCase() + category.slice(1);
        }

        function addNewContextCategory() {
            const categoryKey = prompt('Neue Kategorie-ID eingeben (z.B. "musik", "familie"):\n\nHinweis: Verwende nur Kleinbuchstaben ohne Leerzeichen');
            if (!categoryKey || categoryKey.trim() === '') return;

            const cleanKey = categoryKey.toLowerCase().trim().replace(/[^a-z0-9]/g, '');

            if (contextualTemplates[cleanKey]) {
                alert('Kategorie existiert bereits!');
                return;
            }

            contextualTemplates[cleanKey] = [
                { text: `Ihr habt Gemeinsamkeiten im Bereich ${cleanKey}`, priority: true }
            ];

            refreshContextualTemplatesEditor();
        }

        function addTemplateToCategory(category) {
            const text = prompt('Neuen Formulierungstext eingeben:');
            if (!text || text.trim() === '') return;

            contextualTemplates[category].push({
                text: text.trim(),
                priority: false
            });

            refreshContextualTemplatesEditor();
        }

        function deleteCategory(category) {
            if (confirm(`Kategorie "${category}" mit allen Templates löschen?`)) {
                delete contextualTemplates[category];
                refreshContextualTemplatesEditor();
            }
        }

        function deleteTemplate(category, index) {
            if (confirm('Template wirklich löschen?')) {
                contextualTemplates[category].splice(index, 1);
                refreshContextualTemplatesEditor();
            }
        }

        function toggleTemplatePriority(category, index) {
            contextualTemplates[category][index].priority = !contextualTemplates[category][index].priority;
        }

        function updateTemplateText(category, index, newText) {
            contextualTemplates[category][index].text = newText;
        }

        function moveTemplate(category, index, direction) {
            const templates = contextualTemplates[category];

            if (direction === -1 && index > 0) {
                // Nach oben
                [templates[index - 1], templates[index]] = [templates[index], templates[index - 1]];
            } else if (direction === 1 && index < templates.length - 1) {
                // Nach unten
                [templates[index], templates[index + 1]] = [templates[index + 1], templates[index]];
            }

            refreshContextualTemplatesEditor();
        }

        function refreshContextualTemplatesEditor() {
            const container = document.getElementById('contextual-templates-editor');
            if (container) {
                container.innerHTML = generateContextualTemplatesHTML();
            }
        }

        function resetContextualTemplates() {
            if (confirm('Alle fragespezifischen Formulierungen auf Standardwerte zurücksetzen?')) {
                contextualTemplates = getDefaultContextualTemplates();
                localStorage.setItem('swaf_contextual_templates', JSON.stringify(contextualTemplates));
                refreshContextualTemplatesEditor();
                showNotification('✅ Fragespezifische Formulierungen zurückgesetzt', 'success');
            }
        }

        function exportContextualTemplates() {
            const data = {
                contextualTemplates: contextualTemplates,
                exported: new Date().toISOString(),
                version: '2.0'
            };

            downloadFile(
                JSON.stringify(data, null, 2),
                `SwaF_Fragespezifische_Formulierungen_${new Date().toISOString().split('T')[0]}.json`,
                'application/json'
            );

            showNotification('✅ Fragespezifische Formulierungen exportiert', 'success');
        }

        function importContextualTemplates() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function (event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const data = JSON.parse(e.target.result);

                        if (data.contextualTemplates && typeof data.contextualTemplates === 'object') {
                            if (confirm('Fragespezifische Formulierungen importieren? (Vorhandene werden überschrieben)')) {
                                contextualTemplates = data.contextualTemplates;
                                localStorage.setItem('swaf_contextual_templates', JSON.stringify(contextualTemplates));
                                refreshContextualTemplatesEditor();
                                showNotification('✅ Fragespezifische Formulierungen importiert', 'success');
                            }
                        } else {
                            throw new Error('Keine gültigen fragespezifischen Templates gefunden');
                        }
                    } catch (error) {
                        showNotification('❌ Import-Fehler: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function getDefaultContextualTemplates() {
            return {
                'alter': [
                    { text: 'So, wie ihr es euch vorgestellt habt.', priority: true },
                    { text: 'Altersunterschiede können auch super spannend sein! :)', priority: true },
                    { text: 'Ihr seid etwa gleich alt', priority: false },
                    { text: 'Generationsunterschied kann bereichernd sein', priority: false }
                ],
                'hobby': [
                    { text: 'Das sind nur die Hobbies, die ihr aus unserem Vorschlägen wählen konntet - mehr findet ihr weiter unten.', priority: true },
                    { text: 'Ihr könnt euch gegenseitig neue Hobbys zeigen', priority: true },
                    { text: 'Ihr habt ähnliche Hobbys', priority: false },
                    { text: 'Ihr interessiert euch beide für Sport', priority: false }
                ],
                'sprache': [
                    { text: 'Eine gemeinsame Sprache habt ihr also :)', priority: true },
                    { text: 'Ihr sprecht beide mehrere Sprachen', priority: false },
                    { text: 'Ihr könnt euch beim Deutschlernen helfen', priority: false }
                ],
                'postleitzahl': [
                    { text: 'Wenn ihr euch in der Mitte trefft, wird es noch kürzer :)', priority: true },
                    { text: 'Ihr seid ja sogar fast Nachbarn! :)', priority: true },
                    { text: 'Ihr wohnt nah beieinander', priority: false },
                    { text: 'Kurze Wege für Treffen', priority: false }
                ],
                'wohnort': [
                    { text: 'Ihr wohnt in der gleichen Gegend', priority: true },
                    { text: 'Ihr kennt die gleichen Orte', priority: false }
                ],
                'beruf': [
                    { text: 'Ihr arbeitet in ähnlichen Bereichen', priority: true },
                    { text: 'Unterschiedliche Berufe - kann spannend sein sich darüber auszutauschen :)', priority: true },
                    { text: 'Upsi, da haben wir vergessen nachzufragen - aber wir wollen ja auch nicht alles vor dem ersten Treffen verraten :D', priority: false }
                ],
                'studium': [
                    { text: 'Unterschiedlich - aber auch guter Gesprächsstoff!', priority: true },
                    { text: 'Ist das nicht ähnlich?', priority: true },
                    { text: 'Ihr habt beide studiert', priority: false }
                ],
                'zeit': [
                    { text: 'Na, einen Zeitpunkt für ein Treffen findet ihr doch, oder? :D', priority: true },
                    { text: 'Ihr habt zur gleichen Zeit frei', priority: false },
                    { text: 'Eure Zeitpläne passen gut zusammen', priority: false }
                ],
                'verkehr': [
                    { text: 'Der Weg ist das Ziel :D', priority: true },
                    { text: 'Ihr nutzt die gleichen Verkehrsmittel', priority: false },
                    { text: 'Ihr kommt gut zueinander', priority: false }
                ],             
                // NEUE KATEGORIEN:
                'motivation': [
                    { text: 'Ihr habt ähnliche Gründe für SwaF! :)', priority: true },
                    { text: 'Unterschiedliche Motivationen - spannend zum Austauschen!', priority: true },
                    { text: 'Ihr wisst beide, warum ihr hier seid', priority: false }
                ],
                'herkunft_swaf': [
                    { text: 'Ihr habt SwaF auf ähnliche Weise kennengelernt', priority: true },
                    { text: 'Unterschiedliche Wege zu SwaF - aber ihr seid da! :)', priority: false }
                ],
                'einwanderung': [
                    { text: 'Ihr habt ähnliche Erfahrungen mit dem Leben in Deutschland', priority: true },
                    { text: 'Unterschiedliche Hintergründe - perfekt zum Austauschen!', priority: true },
                    { text: 'Verschiedene Perspektiven können sehr bereichernd sein', priority: false }
                ],
                'zukunft': [
                    { text: 'Ihr habt ähnliche Pläne für die Zukunft!', priority: true },
                    { text: 'Unterschiedliche Träume - könnt euch gegenseitig inspirieren! :)', priority: true },
                    { text: 'Spannend, was ihr beide vorhabt', priority: false }
                ],
                'themen': [
                    { text: 'Ihr interessiert euch für ähnliche Themen!', priority: true },
                    { text: 'Verschiedene Interessen - perfekt für spannende Gespräche', priority: true },
                    { text: 'Da werdet ihr viel zu bereden haben! :)', priority: false }
                ],
                'name': [
                    { text: 'Schöne Namen habt ihr beide! :)', priority: false }
                ],
                'gruppe': [
                    { text: 'Ihr seid in den perfekten Gruppen! :)', priority: true },
                    { text: 'Local und Einwander*in - genau wie es sein soll!', priority: true }
                ],
                'matching_hinweise': [
                    { text: 'Die Hinweise passen gut zusammen', priority: true },
                    { text: 'Wir haben auf alles geachtet! :)', priority: false }
                ],
                'herausforderungen': [
                    { text: 'Herausforderungen meistert ihr zusammen bestimmt! :)', priority: true },
                    { text: 'Ihr könnt euch gegenseitig unterstützen', priority: false }
                ],
                'eindruck': [
                    { text: 'Ihr macht beide einen tollen Eindruck!', priority: true },
                    { text: 'Sympathische Menschen, die gut zusammenpassen', priority: false }
                ],
                'kontakt': [
                    { text: 'Eure Kontaktdaten sind ausgetauscht - los geht\'s! :)', priority: true }
                ],
                'termine': [
                    { text: 'Die Termine haben gut geklappt', priority: false }
                ],
                'status': [
                    { text: 'Alles ist bereit für euer Tandem! :)', priority: true }
                ]
            };
        }

        function editPredefinedTemplates() {
            const modal = createModal('✏️ Formulierungsvorschläge bearbeiten', `
                <div style="max-height: 400px; overflow-y: auto;">
                    <div id="edit-templates-list">
                        ${predefinedTemplates.map((template, index) => `
                            <div class="template-edit-item" style="border: 1px solid #ddd; padding: 1rem; margin: 0.5rem 0; border-radius: 4px;">
                                <div style="display: flex; gap: 1rem; align-items: flex-start;">
                                    <div style="flex: 1;">
                                        <div class="form-group">
                                            <label>Titel:</label>
                                            <input type="text" value="${template.title}" 
                                                onchange="updatePredefinedTemplate(${index}, 'title', this.value)"
                                                style="width: 100%;">
                                        </div>
                                        <div class="form-group">
                                            <label>Text:</label>
                                            <textarea rows="2" 
                                                    onchange="updatePredefinedTemplate(${index}, 'text', this.value)"
                                                    style="width: 100%;">${template.text}</textarea>
                                        </div>
                                    </div>
                                    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                        <button onclick="movePredefinedTemplate(${index}, -1)" 
                                                class="btn btn-outline btn-small" 
                                                ${index === 0 ? 'disabled' : ''}>↑</button>
                                        <button onclick="movePredefinedTemplate(${index}, 1)" 
                                                class="btn btn-outline btn-small"
                                                ${index === predefinedTemplates.length - 1 ? 'disabled' : ''}>↓</button>
                                        <button onclick="deletePredefinedTemplate(${index})" 
                                                class="btn btn-outline btn-small"
                                                style="background: var(--swaf-red); color: white;">🗑️</button>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--swaf-lightest-teal); border-radius: 4px;">
                        <h4>➕ Neue Formulierung hinzufügen:</h4>
                        <div style="display: flex; gap: 1rem; align-items: flex-end;">
                            <div class="form-group" style="flex: 1;">
                                <label>Titel:</label>
                                <input type="text" id="new-predefined-title" placeholder="z.B. Reisen">
                            </div>
                            <div class="form-group" style="flex: 2;">
                                <label>Text:</label>
                                <input type="text" id="new-predefined-text" placeholder="z.B. Ihr reist beide gerne und entdeckt neue Orte">
                            </div>
                            <button onclick="addPredefinedTemplate()" class="btn btn-primary">➕ Hinzufügen</button>
                        </div>
                    </div>
                </div>
            `, [
                { text: 'Abbrechen', class: 'btn-outline', action: 'closeModal' },
                { text: 'Speichern & Schließen', class: 'btn-primary', action: 'savePredefinedTemplates' }
            ]);
        }

        function updatePredefinedTemplate(index, field, value) {
            if (predefinedTemplates[index]) {
                predefinedTemplates[index][field] = value;
                console.log(`Updated template ${index}.${field} = "${value}"`);
            }
        }

        function movePredefinedTemplate(index, direction) {
            if (direction === -1 && index > 0) {
                [predefinedTemplates[index - 1], predefinedTemplates[index]] =
                    [predefinedTemplates[index], predefinedTemplates[index - 1]];
            } else if (direction === 1 && index < predefinedTemplates.length - 1) {
                [predefinedTemplates[index], predefinedTemplates[index + 1]] =
                    [predefinedTemplates[index + 1], predefinedTemplates[index]];
            }

            editPredefinedTemplates();
        }

        function deletePredefinedTemplate(index) {
            const template = predefinedTemplates[index];
            if (confirm(`Formulierung "${template.title}" wirklich löschen?`)) {
                predefinedTemplates.splice(index, 1);
                editPredefinedTemplates();
            }
        }

        function addPredefinedTemplate() {
            const title = document.getElementById('new-predefined-title').value.trim();
            const text = document.getElementById('new-predefined-text').value.trim();

            if (!title || !text) {
                alert('Bitte Titel und Text eingeben.');
                return;
            }

            predefinedTemplates.push({ title, text });

            document.getElementById('new-predefined-title').value = '';
            document.getElementById('new-predefined-text').value = '';

            editPredefinedTemplates();
        }

        function savePredefinedTemplates() {
            localStorage.setItem('swaf_predefined_templates', JSON.stringify(predefinedTemplates));
            loadPredefinedTemplates();
            closeModal();
            showNotification('✅ Formulierungsvorschläge gespeichert', 'success');
        }

        function loadPredefinedTemplates() {
            console.log('🔄 Lade vordefinierte Templates...');
            
            // Stelle sicher, dass Container existiert
            let container = ensurePredefinedTemplatesContainer();
            
            if (!container) {
                console.error('❌ Container "predefined-templates" konnte nicht erstellt werden');
                return;
            }

            console.log('✅ Container gefunden, lade', predefinedTemplates.length, 'Templates');

            container.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h4 style="margin: 0; color: var(--swaf-red);">📝 Vordefinierte Formulierungen (${predefinedTemplates.length})</h4>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-outline btn-small" onclick="editPredefinedTemplates()">✏️ Bearbeiten</button>
                        <button class="btn btn-outline btn-small" onclick="resetPredefinedTemplates()">🔄 Zurücksetzen</button>
                        <button class="btn btn-secondary btn-small" onclick="exportPredefinedTemplates()">📤 Exportieren</button>
                        <button class="btn btn-secondary btn-small" onclick="importPredefinedTemplates()">📥 Importieren</button>
                    </div>
                </div>
                <div id="predefined-templates-grid" style="display: flex; flex-wrap: wrap; gap: 0.3rem; max-height: 150px; overflow-y: auto; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; background: white;">
                    ${predefinedTemplates.map((template, index) => `
                        <button class="btn btn-outline btn-small template-btn" 
                                onclick="insertTemplate('${template.text.replace(/'/g, "\\'")}')"
                                data-index="${index}"
                                style="margin: 0.1rem; font-size: 0.8rem;"
                                title="${template.text}">
                            ${template.title}
                        </button>
                    `).join('')}
                </div>
                <div style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--swaf-dark-gray);">
                    💡 <strong>Verwendung:</strong> Doppelklick auf eine Formulierung um sie in eine ausgewählte Gemeinsamkeiten-Zelle einzufügen.
                </div>
            `;
            
            console.log('✅ Allgemeine Templates erfolgreich geladen');
        }

        // Hilfsfunktion um sicherzustellen, dass Container existiert
        function ensurePredefinedTemplatesContainer() {
            const container = document.getElementById('predefined-templates');
            if (!container) {
                console.warn('⚠️ Container "predefined-templates" nicht gefunden - wird erstellt');
                
                // Suche den Parent-Container und füge hinzu
                const parentContainer = document.querySelector('#tab-3 .card:last-child');
                if (parentContainer) {
                    const newContainer = document.createElement('div');
                    newContainer.innerHTML = `
                        <div style="margin-top: 2rem; padding: 1.5rem; border: 2px solid var(--swaf-red); border-radius: 8px; background: var(--swaf-lightest-red);">
                            <h4 style="color: var(--swaf-red); margin-top: 0;">📋 Allgemeine Formulierungsvorschläge</h4>
                            <p style="margin-bottom: 1rem; font-size: 0.9rem;">Diese Vorschläge stehen in allen Tandem-Bearbeitungen zur Verfügung:</p>
                            
                            <div id="predefined-templates">
                                <!-- Wird dynamisch gefüllt -->
                            </div>
                        </div>
                    `;
                    parentContainer.appendChild(newContainer);
                    return document.getElementById('predefined-templates');
                }
            }
            return container;
        }

        function resetPredefinedTemplates() {
            if (confirm('Alle Formulierungsvorschläge auf Standardwerte zurücksetzen?')) {
                predefinedTemplates.length = 0;
                predefinedTemplates.push(...getDefaultPredefinedTemplates());
                localStorage.setItem('swaf_predefined_templates', JSON.stringify(predefinedTemplates));
                loadPredefinedTemplates();
                showNotification('✅ Formulierungsvorschläge zurückgesetzt', 'success');
            }
        }

        function exportPredefinedTemplates() {
            console.log('📤 Exportiere vordefinierte Templates:', predefinedTemplates.length);
            
            const data = {
                templates: predefinedTemplates,
                exported: new Date().toISOString(),
                version: '2.0',
                type: 'swaf_predefined_templates'
            };

            const filename = `SwaF_Allgemeine_Formulierungen_${new Date().toISOString().split('T')[0]}.json`;
            
            downloadFile(
                JSON.stringify(data, null, 2),
                filename,
                'application/json'
            );

            showNotification(`✅ ${predefinedTemplates.length} allgemeine Formulierungsvorschläge exportiert`, 'success', 4000);
            console.log('✅ Export erfolgreich:', filename);
        }

        function importPredefinedTemplates() {
            console.log('📥 Starte Import von vordefinierten Templates...');
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function (event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        console.log('📄 Geladene Daten:', data);

                        if (data.templates && Array.isArray(data.templates)) {
                            const message = `${data.templates.length} allgemeine Formulierungen importieren?\n\n` +
                                        `Vorhandene ${predefinedTemplates.length} Formulierungen werden überschrieben!\n\n` +
                                        `Erste 3 Beispiele:\n` +
                                        data.templates.slice(0, 3).map(t => `• ${t.title}`).join('\n');
                            
                            if (confirm(message)) {
                                const oldCount = predefinedTemplates.length;
                                predefinedTemplates.length = 0;
                                predefinedTemplates.push(...data.templates);
                                localStorage.setItem('swaf_predefined_templates', JSON.stringify(predefinedTemplates));
                                loadPredefinedTemplates();
                                
                                console.log('✅ Import erfolgreich:', predefinedTemplates.length, 'Templates');
                                showNotification(`✅ ${data.templates.length} allgemeine Formulierungen importiert (vorher: ${oldCount})`, 'success', 5000);
                            }
                        } else {
                            throw new Error('Keine gültige Template-Datei gefunden. Erwartet: { templates: [...] }');
                        }
                    } catch (error) {
                        console.error('❌ Import-Fehler:', error);
                        showNotification('❌ Import-Fehler: ' + error.message, 'error', 6000);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function getDefaultPredefinedTemplates() {
            return [
                // Sport & Bewegung
                { title: 'Sport allgemein', text: 'Ihr habt beide Interesse an Sport und Bewegung' },
                { title: 'Fußball', text: 'Ihr interessiert euch beide für Fußball' },
                { title: 'Fitnessstudio', text: 'Ihr geht beide gerne ins Fitnessstudio' },
                { title: 'Wandern', text: 'Ihr wandert beide gerne und mögt die Natur' },
                { title: 'Laufen', text: 'Ihr lauft beide gerne und haltet euch fit' },
                // ... alle anderen Templates
                { title: 'Gegenseitige Unterstützung', text: 'Ihr könnt euch gegenseitig unterstützen und motivieren' }
            ];
        }

        function initializePredefinedTemplates() {
            const saved = localStorage.getItem('swaf_predefined_templates');
            if (saved) {
                try {
                    const savedTemplates = JSON.parse(saved);
                    if (Array.isArray(savedTemplates) && savedTemplates.length > 0) {
                        predefinedTemplates.length = 0;
                        predefinedTemplates.push(...savedTemplates);
                        console.log('✅ Gespeicherte Formulierungsvorschläge geladen:', savedTemplates.length);
                    }
                } catch (error) {
                    console.error('❌ Fehler beim Laden der gespeicherten Templates:', error);
                }
            }
        }

        // ===============================
        // EVENT LISTENERS
        // ===============================
        window.addEventListener('beforeunload', function (e) {
            if (profiles.length > 0 || tandems.length > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // Keyboard Shortcuts
        // Enhanced Keyboard Shortcuts
        document.addEventListener('keydown', function (e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 's':
                        e.preventDefault();
                        quickSave();
                        showShortcutFeedback('💾 Gespeichert!');
                        break;
                    case 'f':
                        e.preventDefault();
                        fillCommonPhrases();
                        showShortcutFeedback('⚡ Schnell-Phrasen eingefügt!');
                        break;
                    case 'l':
                        e.preventDefault();
                        clearAllCommonalities();
                        showShortcutFeedback('🧹 Gemeinsamkeiten geleert!');
                        break;
                    case 'b':
                        e.preventDefault();
                        toggleBulkEditMode();
                        showShortcutFeedback('🚀 Bulk-Edit Modus!');
                        break;
                    case 'v':
                        if (!e.target.matches('input, textarea, [contenteditable]')) {
                            e.preventDefault();
                            pasteFromClipboard();
                            showShortcutFeedback('📋 Eingefügt!');
                        }
                        break;
                    case '1':
                        e.preventDefault();
                        switchTab(0);
                        break;
                    case '2':
                        e.preventDefault();
                        switchTab(1);
                        break;
                }
            }
            
            // Escape-Taste für verschiedene Schließ-Aktionen
            if (e.key === 'Escape') {
                if (document.getElementById('bulk-edit-toolbar').classList.contains('visible')) {
                    exitBulkEditMode();
                } else if (floatingTemplatesVisible) {
                    hideFloatingTemplates();
                } else {
                    hideShortcutInfo();
                }
            }
            
            // Zeige Shortcuts bei Shift+?
            if (e.shiftKey && e.key === '?') {
                e.preventDefault();
                toggleShortcutInfo();
            }
        });

        function toggleAutoClipboardDetection() {
            const checkbox = document.getElementById('auto-clipboard-detection');
            
            if (checkbox.checked) {
                localStorage.setItem('swaf_auto_clipboard_detection', 'true');
                showNotification('✅ Automatische Zwischenablage-Erkennung aktiviert', 'success', 3000);
            } else {
                localStorage.setItem('swaf_auto_clipboard_detection', 'false');
                showNotification('⚠️ Automatische Erkennung deaktiviert. Verwende "📋 Aus Zwischenablage einfügen" manuell.', 'warning', 5000);
            }
        }

        // ===============================
        // GLOBALE FUNKTIONEN VERFÜGBAR MACHEN
        // ===============================
        window.switchTab = switchTab;
        window.removeProfile = removeProfile;
        window.clearAllProfiles = clearAllProfiles;
        window.addTestProfile = addTestProfile;
        window.showManualInput = showManualInput;
        window.pasteFromClipboard = pasteFromClipboard;
        window.checkClipboardForProfileData = checkClipboardForProfileData;
        window.testClipboardFormat = testClipboardFormat;
        window.checkForBookmarkletData = checkForBookmarkletData;
        window.showDebugInfo = showDebugInfo;
        window.testLocalStorage = testLocalStorage;
        window.testDataCleaning = testDataCleaning;
        window.showInstructions = showInstructions;
        window.testPLZDistanceAPI = testPLZDistanceAPI;
        window.testAdvancedPLZFeatures = testAdvancedPLZFeatures;
        window.interactivePLZTest = interactivePLZTest;
        window.debugRoutingCache = debugRoutingCache;
        window.clearRoutingCache = clearRoutingCache;
        window.updatePLZDistancesOnly = updatePLZDistancesOnly;
        window.showNavigationOptions = showNavigationOptions;
        window.copyToClipboard = copyToClipboard;
        window.enhancePLZCell = enhancePLZCell;
        window.getRegionInfo = getRegionInfo;
        window.testPLZDistance = testPLZDistance;
        window.loadAvailableProfiles = loadAvailableProfiles;
        window.filterProfiles = filterProfiles;
        window.matchSelectedProfiles = matchSelectedProfiles;
        window.suggestAutoMatches = suggestAutoMatches;
        window.clearProfileSelection = clearProfileSelection;
        window.debugMatchingState = debugMatchingState;
        window.fixProfileSelection = fixProfileSelection;
        window.removeSelectedPair = removeSelectedPair;
        window.clearAllTandems = clearAllTandems;
        window.selectAllFields = selectAllFields;
        window.loadTandemForEditing = loadTandemForEditing;
        window.deleteRow = deleteRow;
        window.saveTandem = saveTandem;
        window.generateCompleteEmail = generateCompleteEmail;
        window.copyTandemToClipboard = copyTandemToClipboard;
        window.recomputeCommonalities = recomputeCommonalities;
        window.previewEmail = previewEmail;
        window.hideEmailPreview = hideEmailPreview;
        window.copyCompleteEmailToClipboard = copyCompleteEmailToClipboard;
        window.downloadEmailAsHTML = downloadEmailAsHTML;
        window.saveEmailTemplate = saveEmailTemplate;
        window.loadEmailTemplate = loadEmailTemplate;
        window.resetEmailTemplate = resetEmailTemplate;
        window.formatText = formatText;
        window.insertText = insertText;
        window.insertPlaceholder = insertPlaceholder;
        window.editTandem = editTandem;
        window.deleteSavedTandem = deleteSavedTandem;
        window.exportAllTandems = exportAllTandems;
        window.exportAppData = exportAppData;
        window.importAppData = importAppData;
        window.clearProfiles = clearProfiles;
        window.clearTandems = clearTandems;
        window.resetAllData = resetAllData;
        window.loadSavedTandems = loadSavedTandems;
        window.saveTextTemplate = saveTextTemplate;
        window.loadTextTemplates = loadTextTemplates;
        window.clearAllTemplates = clearAllTemplates;
        window.editContextualTemplates = editContextualTemplates;
        window.editPredefinedTemplates = editPredefinedTemplates;
        window.toggleBookmarkletStatus = toggleBookmarkletStatus;
        window.handleCellFocus = handleCellFocus;
        window.toggleFloatingTemplates = toggleFloatingTemplates;
        window.selectProfile = selectProfile;
        window.selectTandemPair = selectTandemPair;
        window.removeTandem = removeTandem;
        window.toggleField = toggleField;
        window.removeTemplate = removeTemplate;
        window.insertTemplate = insertTemplate;
        window.insertFloatingTemplate = insertFloatingTemplate;
        window.quickSave = quickSave;
        window.handleDataImport = handleDataImport;
        window.saveManualProfile = saveManualProfile;
        window.processManualPasteData = processManualPasteData;
        window.closeModal = closeModal;
        window.processCorrectedData = processCorrectedData;
        window.addNewContextCategory = addNewContextCategory;
        window.addTemplateToCategory = addTemplateToCategory;
        window.deleteCategory = deleteCategory;
        window.deleteTemplate = deleteTemplate;
        window.toggleTemplatePriority = toggleTemplatePriority;
        window.updateTemplateText = updateTemplateText;
        window.moveTemplate = moveTemplate;
        window.saveContextualTemplates = saveContextualTemplates;
        window.resetContextualTemplates = resetContextualTemplates;
        window.exportContextualTemplates = exportContextualTemplates;
        window.importContextualTemplates = importContextualTemplates;
        window.updatePredefinedTemplate = updatePredefinedTemplate;
        window.movePredefinedTemplate = movePredefinedTemplate;
        window.deletePredefinedTemplate = deletePredefinedTemplate;
        window.addPredefinedTemplate = addPredefinedTemplate;
        window.savePredefinedTemplates = savePredefinedTemplates;
        window.resetPredefinedTemplates = resetPredefinedTemplates;
        window.exportPredefinedTemplates = exportPredefinedTemplates;
        window.importPredefinedTemplates = importPredefinedTemplates;
        window.applyAutoMatches = applyAutoMatches;
        window.toggleAutoClipboardDetection = toggleAutoClipboardDetection;
        window.updateMergeProfileLists = updateMergeProfileLists;
        window.showMergePreview = showMergePreview;
        window.manualMergeProfiles = manualMergeProfiles;
        window.showPossibleDuplicatesDialog = showPossibleDuplicatesDialog;
        window.processDuplicateChoice = processDuplicateChoice;
        window.mergeProfiles = mergeProfiles;
        window.confirmManualMerge = confirmManualMerge;
        window.addNewProfile = addNewProfile;
        window.debugModalSystem = debugModalSystem;
        window.migrateExistingProfiles = migrateExistingProfiles;
        window.createDataBackup = createDataBackup;
        window.analyzeCurrentData = analyzeCurrentData;
        window.debugQuestionSimilarity = debugQuestionSimilarity;
        window.ensurePredefinedTemplatesContainer = ensurePredefinedTemplatesContainer;

        function showAllFields() {
            console.log('🔄 Zeige alle Felder ohne Filter...');
            
            const tbody = document.querySelector('#tandem-table tbody');
            tbody.innerHTML = '';

            currentTandem.commonalities.forEach(c => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${c.question}</td>
                    <td contenteditable="true">${c.answer1}</td>
                    <td contenteditable="true">${c.answer2}</td>
                    <td contenteditable="true" 
                        style="background: var(--swaf-lightest-teal); cursor: text;" 
                        title="Klick hier für passende Formulierungsvorschläge"
                        onfocus="handleCellFocus(this)">${c.commonality}</td>
                    <td>
                        <button onclick="deleteRow(this)" class="btn btn-outline btn-small">🗑️</button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            showNotification('📊 Alle Felder werden angezeigt (Feldkonfiguration temporär ignoriert)', 'info', 3000);
        }

        // Globale Funktion verfügbar machen
        window.showAllFields = showAllFields;

        // ===============================
        // SCHNELLES TEXTING - NEUE FUNKTIONEN
        // ===============================

        let bulkEditMode = false;
        let shortcutInfoVisible = false;

        // Zeige Quick Actions nur bei Tandem-Bearbeitung
        function showQuickActions() {
            const quickActions = document.getElementById('quick-actions');
            const currentTab = document.querySelector('.tab.active');
            const isEditingTab = currentTab && currentTab.textContent.includes('Bearbeitung');
            
            if (isEditingTab && currentTandem) {
                quickActions.style.display = 'flex';
            } else {
                quickActions.style.display = 'none';
            }
        }

        // Fülle häufige Phrasen in leere Gemeinsamkeiten-Zellen
        function fillCommonPhrases() {
            if (!currentTandem) {
                showNotification('❌ Bitte zuerst ein Tandem auswählen', 'error');
                return;
            }
            
            const commonPhrases = [
                'Passt gut zusammen! :)',
                'Könnt ihr euch drüber austauschen',
                'Unterschiedlich - aber spannend!',
                'Das wird sicher interessant! :D',
                'Habt ihr gemeinsam',
                'Ergänzt sich gut'
            ];
            
            const table = document.getElementById('tandem-table');
            const rows = table.querySelectorAll('tbody tr');
            let filled = 0;
            
            rows.forEach((row, index) => {
                const commonalityCell = row.querySelector('td:nth-child(4)[contenteditable]');
                if (commonalityCell && (!commonalityCell.textContent.trim() || commonalityCell.textContent.trim() === 'Keine Übereinstimmung')) {
                    const phrase = commonPhrases[index % commonPhrases.length];
                    commonalityCell.textContent = phrase;
                    
                    // Animiere die Zelle
                    commonalityCell.style.background = 'var(--swaf-lightest-teal)';
                    setTimeout(() => {
                        commonalityCell.style.background = '';
                    }, 1000);
                    
                    filled++;
                }
            });
            
            if (filled > 0) {
                showNotification(`⚡ ${filled} Schnell-Phrasen eingefügt`, 'success', 3000);
            } else {
                showNotification('ℹ️ Alle Zellen sind bereits gefüllt', 'info', 2000);
            }
        }

        // Leere alle Gemeinsamkeiten für Neustart
        function clearAllCommonalities() {
            if (!currentTandem) {
                showNotification('❌ Bitte zuerst ein Tandem auswählen', 'error');
                return;
            }
            
            if (!confirm('Alle Gemeinsamkeiten-Texte löschen?')) return;
            
            const table = document.getElementById('tandem-table');
            const rows = table.querySelectorAll('tbody tr');
            let cleared = 0;
            
            rows.forEach(row => {
                const commonalityCell = row.querySelector('td:nth-child(4)[contenteditable]');
                if (commonalityCell && commonalityCell.textContent.trim()) {
                    commonalityCell.textContent = '';
                    cleared++;
                }
            });
            
            showNotification(`🧹 ${cleared} Gemeinsamkeiten geleert`, 'success', 2000);
        }

        // Bulk-Edit Modus
        function toggleBulkEditMode() {
            bulkEditMode = !bulkEditMode;
            const toolbar = document.getElementById('bulk-edit-toolbar');
            const table = document.getElementById('tandem-table');
            
            if (bulkEditMode) {
                table.classList.add('bulk-edit-mode');
                toolbar.classList.add('visible');
                showNotification('🚀 Bulk-Edit Modus aktiviert', 'info', 3000);
            } else {
                exitBulkEditMode();
            }
        }

        function exitBulkEditMode() {
            bulkEditMode = false;
            const toolbar = document.getElementById('bulk-edit-toolbar');
            const table = document.getElementById('tandem-table');
            
            table.classList.remove('bulk-edit-mode');
            toolbar.classList.remove('visible');
            showNotification('Bulk-Edit Modus beendet', 'info', 2000);
        }

        function applyBulkTemplate() {
            const select = document.getElementById('bulk-template-select');
            const template = select.value;
            
            if (!template) {
                alert('Bitte wähle einen Text aus.');
                return;
            }
            
            const table = document.getElementById('tandem-table');
            const rows = table.querySelectorAll('tbody tr');
            let applied = 0;
            
            rows.forEach(row => {
                const commonalityCell = row.querySelector('td:nth-child(4)[contenteditable]');
                if (commonalityCell && !commonalityCell.textContent.trim()) {
                    commonalityCell.textContent = template;
                    applied++;
                }
            });
            
            showNotification(`📝 ${applied} Zellen mit "${template}" gefüllt`, 'success', 3000);
            exitBulkEditMode();
        }

        // Shortcuts Info ein/ausblenden
        function toggleShortcutInfo() {
            shortcutInfoVisible = !shortcutInfoVisible;
            const shortcuts = document.getElementById('keyboard-shortcuts');
            shortcuts.classList.toggle('visible', shortcutInfoVisible);
            
            if (shortcutInfoVisible) {
                setTimeout(hideShortcutInfo, 5000); // Auto-hide nach 5 Sekunden
            }
        }

        function hideShortcutInfo() {
            shortcutInfoVisible = false;
            document.getElementById('keyboard-shortcuts').classList.remove('visible');
        }

        function showShortcutFeedback(message) {
            // Kurze Feedback-Nachricht
            const feedback = document.createElement('div');
            feedback.textContent = message;
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--swaf-teal);
                color: white;
                padding: 1rem 2rem;
                border-radius: 8px;
                font-weight: bold;
                font-size: 1.2rem;
                z-index: 10000;
                animation: fadeInOut 1.5s ease-in-out forwards;
            `;
            
            // CSS Animation
            if (!document.querySelector('#feedback-animation-css')) {
                const style = document.createElement('style');
                style.id = 'feedback-animation-css';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(feedback);
            setTimeout(() => feedback.remove(), 1500);
        }

        // Update showQuickActions wenn Tab gewechselt wird
        const originalSwitchTab = switchTab;
        switchTab = function(tabIndex) {
            originalSwitchTab(tabIndex);
            setTimeout(showQuickActions, 100);
        };

        // Update showQuickActions wenn Tandem ausgewählt wird  
        const originalLoadTandemForEditing = loadTandemForEditing;
        loadTandemForEditing = function() {
            originalLoadTandemForEditing();
            showQuickActions();
        };

        // ===============================
        // INTELLIGENTE LOKALE TEXTGENERIERUNG
        // ===============================

        function extractFirstNameSmart(fullName) {
            if (!fullName || typeof fullName !== 'string') {
                return 'die Person';
            }

            console.log(`📛 Analysiere Vollname: "${fullName}"`);

            // 1. Suche nach Namen in Klammern (höchste Priorität)
            const bracketMatch = fullName.match(/\(([^)]+)\)/);
            if (bracketMatch) {
                const nameInBrackets = bracketMatch[1].trim();
                const firstName = nameInBrackets.split(/[\s,]+/)[0];
                if (firstName && firstName.length > 1 && !firstName.match(/^(locals?|einwander|interview|gespräch)/i)) {
                    console.log(`✅ Name aus Klammern: "${firstName}"`);
                    return firstName;
                }
            }

            // 2. Prüfe ob es ein Profilname ohne Präfix ist (z.B. nur "Sara Mustermann")
            if (!fullName.match(/^(aufnahmegespräch|interview|gespräch)/i)) {
                const firstName = fullName.split(/[\s,]+/)[0];
                if (firstName && firstName.length > 1) {
                    console.log(`✅ Direkter Name: "${firstName}"`);
                    return firstName;
                }
            }

            // 3. Extrahiere Namen nach Präfix-Mustern
            const prefixPatterns = [
                /^aufnahmegespräch\s+einwander\*innen\s+\(([^)]+)\)/i,
                /^aufnahmegespräch\s+locals?\s+\(([^)]+)\)/i,
                /^interview\s+(.+?)$/i,
                /^gespräch\s+(.+?)$/i
            ];

            for (const pattern of prefixPatterns) {
                const match = fullName.match(pattern);
                if (match) {
                    const extractedName = match[1].trim();
                    const firstName = extractedName.split(/[\s,]+/)[0];
                    if (firstName && firstName.length > 1) {
                        console.log(`✅ Name nach Muster: "${firstName}" aus "${extractedName}"`);
                        return firstName;
                    }
                }
            }

            console.log(`⚠️ Fallback für: "${fullName}"`);
            return 'die Person';
        }

        function generateSmartTextsLocally() {
            if (!currentTandem) {
                showNotification('❌ Bitte wähle zuerst ein Tandem aus', 'error');
                return;
            }

            const table = document.getElementById('tandem-table');
            const rows = table.querySelectorAll('tbody tr');
            let generated = 0;

            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 4) {
                    const question = cells[0].textContent.trim();
                    const answer1 = cells[1].textContent.trim();
                    const answer2 = cells[2].textContent.trim();
                    const currentText = cells[3].textContent.trim();

                    // Nur leere oder Standard-Texte überschreiben, aber NIE ausgeschlossene Felder
                    if ((!currentText || currentText === 'Keine Übereinstimmung' || currentText.length < 5) && 
                        !shouldExcludeFromMatching(question)) {
                        const smartText = generateIntelligentText(question, answer1, answer2);
                        if (smartText) {
                            cells[3].textContent = smartText;
                            cells[3].style.background = 'var(--swaf-lightest-teal)';
                            setTimeout(() => cells[3].style.background = '', 2000);
                            generated++;
                        }
                    }
                }
            });

            if (generated > 0) {
                showNotification(`🧠 ${generated} intelligente Texte generiert!`, 'success', 4000);
            } else {
                showNotification('ℹ️ Alle Zellen sind bereits gefüllt', 'info', 2000);
            }
        }

        function generateIntelligentText(question, answer1, answer2, profile1 = null, profile2 = null) {
            // Normalisiere Antworten und erkenne leere/fehlende Werte
            const a1 = cleanAnswer(answer1);
            const a2 = cleanAnswer(answer2);
            const q = question.toLowerCase();
            
            // Prüfe ob Frage von der intelligenten Analyse ausgeschlossen werden soll
            if (shouldExcludeFromMatching(question)) {
                console.log(`🚫 Intelligente Analyse übersprungen für: "${question}"`);
                return ''; // Leer lassen für ausgeschlossene Felder
            }
            
            // Profile-Namen extrahieren - entweder aus übergebenen Profilen oder currentTandem
            let name1, name2;
            if (profile1 && profile2) {
                name1 = extractFirstName(profile1.name);
                name2 = extractFirstName(profile2.name);
            } else if (currentTandem && currentTandem.profile1 && currentTandem.profile2) {
                name1 = extractFirstName(currentTandem.profile1.name);
                name2 = extractFirstName(currentTandem.profile2.name);
            } else {
                console.log('⚠️ Keine Profile-Informationen verfügbar für intelligente Analyse');
                return '';
            }

            console.log(`🔍 Intelligente Analyse: "${question}" | "${a1}" vs "${a2}" | Namen: ${name1}, ${name2}`);

            // Keine verwertbaren Antworten
            if (!a1 && !a2) {
                return getNoAnswerText(question);
            }
            
            // Nur eine Person hat geantwortet
            if (!a1 && a2) {
                return getOneAnswerText(question, name2, name1, a2, false);
            }
            if (a1 && !a2) {
                return getOneAnswerText(question, name1, name2, a1, true);
            }

            // Beide haben geantwortet - intelligente Analyse
            return analyzeBothAnswersIntelligently(question, name1, name2, a1, a2);
        }

        function analyzeBothAnswersIntelligently(question, name1, name2, answer1, answer2) {
            const q = question.toLowerCase();
            
            console.log(`🧠 Detaillierte Analyse für: "${question}"`);
            console.log(`📝 Antworten: "${answer1}" vs "${answer2}"`);
            
            // 1. EXAKTE ÜBEREINSTIMMUNGEN zuerst prüfen
            if (answer1.toLowerCase().trim() === answer2.toLowerCase().trim()) {
                if (q.includes('wichtig') || q.includes('freundschaft')) {
                    return `Gemeinsamer Wert: ${answer1}! Das ist eine starke Basis für eure Freundschaft 💝`;
                }
                if (q.includes('studium') && answer1.toLowerCase().includes('ja')) {
                    return 'Ihr habt beide studiert - das verbindet! 🎓';
                }
                if (q.includes('deutschland') && answer1.toLowerCase().includes('nein')) {
                    return 'Ihr seid beide nicht in Deutschland geboren - ähnliche Erfahrungen! 🌍';
                }
                return `Identisch: ${answer1} - perfekte Übereinstimmung! ✨`;
            }
            
            // 2. ALTERS-ANALYSE
            if (q.includes('alter') || q.includes('geburt')) {
                const age1 = parseInt(answer1);
                const age2 = parseInt(answer2);
                if (!isNaN(age1) && !isNaN(age2)) {
                    const diff = Math.abs(age1 - age2);
                    if (diff === 0) return 'Ihr seid genau gleich alt! 🎂';
                    if (diff <= 3) return `Nur ${diff} Jahr${diff > 1 ? 'e' : ''} Unterschied - perfekt! 🎯`;
                    if (diff <= 7) return `${diff} Jahre Unterschied - das passt gut zusammen 😊`;
                    if (diff <= 12) return `Generationsunterschied kann bereichernd sein (${diff} Jahre) ✨`;
                    return 'Verschiedene Lebenserfahrungen zum Austauschen 🌟';
                }
            }
            
            // 3. HOBBY-ANALYSE (erweitert)
            if (q.includes('hobby') || q.includes('freizeit') || q.includes('interesse') || 
                q.includes('machst du gerne') || q.includes('ausprobieren') || 
                q.includes('was machst du gerne')) {
                return analyzeHobbysIntelligentlyImproved(answer1, answer2);
            }
            
            // 4. FREUNDSCHAFTS-WERTE (verbessert)
            if (q.includes('wichtig') || q.includes('freundschaft')) {
                return analyzeFriendshipValuesImproved(answer1, answer2);
            }
            
            // 5. SPRACHEN-ANALYSE
            if (q.includes('sprache') || q.includes('sprichst')) {
                return analyzeLanguagesIntelligently(answer1, answer2);
            }
            
            // 6. ZEIT-ANALYSE (verbessert)
            if (q.includes('zeit') || q.includes('treffen') || q.includes('wann')) {
                return analyzeTimeCompatibilityImproved(answer1, answer2);
            }
            
            // 7. TANDEM-VORSTELLUNG
            if (q.includes('tandem vor') || q.includes('stellst du dir')) {
                return analyzeTandemExpectations(answer1, answer2);
            }
            
            // 8. VERKEHRSMITTEL
            if (q.includes('bewegst') || q.includes('verkehr') || q.includes('stadt')) {
                return analyzeTransportation(answer1, answer2);
            }
            
            // 9. ERREICHBARKEIT
            if (q.includes('erreichen') || q.includes('kontakt')) {
                return analyzeContactMethods(answer1, answer2);
            }
            
            // 10. STUDIUM/BILDUNG
            if (q.includes('studium') || q.includes('schule') || q.includes('ausbildung')) {
                if (answer1.toLowerCase().trim() === answer2.toLowerCase().trim()) {
                    return `Identisch: ${answer1} - das verbindet! 🎓`;
                }
                return 'Verschiedene Bildungswege - viel zu erzählen! 📚';
            }
            
            // 11. JA/NEIN Fragen
            if ((answer1.toLowerCase().includes('ja') && answer2.toLowerCase().includes('ja')) ||
                (answer1.toLowerCase().includes('nein') && answer2.toLowerCase().includes('nein'))) {
                return `Ihr seid euch einig: ${answer1}! ✅`;
            }
            
            // 12. STANDARD für alle anderen
            return getDifferenceTextImproved(question, name1, name2, answer1, answer2);
        }

        function analyzeHobbysIntelligentlyImproved(answer1, answer2) {
            const hobbies1 = answer1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const hobbies2 = answer2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            
            console.log(`🎨 Verbesserte Hobby-Analyse: [${hobbies1.join(', ')}] vs [${hobbies2.join(', ')}]`);
            
            // Erweiterte Hobby-Synonyme für intelligente Erkennung
            const synonymGroups = [
                {
                    keywords: ['feiern', 'feiern gehen', 'party', 'ausgehen', 'clubs'],
                    name: 'Feiern/Party'
                },
                {
                    keywords: ['kino', 'ins kino gehen', 'filme schauen', 'film', 'serien'],
                    name: 'Kino/Filme'
                },
                {
                    keywords: ['kochen', 'gemeinsam kochen', 'essen zubereiten', 'kulinarik'],
                    name: 'Kochen'
                },
                {
                    keywords: ['museum', 'ins museum gehen', 'kultur', 'ausstellungen', 'theater', 'ins theater gehen'],
                    name: 'Kultur/Museum/Theater'
                },
                {
                    keywords: ['sport', 'fitness', 'training', 'bewegung', 'fitnessstudio'],
                    name: 'Sport/Fitness'
                },
                {
                    keywords: ['musik', 'musikhören', 'konzerte', 'konzert'],
                    name: 'Musik/Konzerte'
                },
                {
                    keywords: ['lesen', 'bücher', 'literatur'],
                    name: 'Lesen/Literatur'
                },
                {
                    keywords: ['spazieren', 'wandern', 'natur', 'draußen sein', 'wald'],
                    name: 'Natur/Wandern'
                },
                {
                    keywords: ['freunde treffen', 'leute treffen', 'soziale kontakte'],
                    name: 'Soziale Kontakte'
                },
                {
                    keywords: ['gesellschaftsspiele', 'brettspiele', 'spiele', 'gaming'],
                    name: 'Spiele'
                }
            ];
            
            const commonHobbies = [];
            
            // Finde Übereinstimmungen durch Synonym-Gruppen
            synonymGroups.forEach(group => {
                const hobby1Matches = hobbies1.some(h => 
                    group.keywords.some(keyword => h.includes(keyword) || keyword.includes(h))
                );
                const hobby2Matches = hobbies2.some(h => 
                    group.keywords.some(keyword => h.includes(keyword) || keyword.includes(h))
                );
                
                if (hobby1Matches && hobby2Matches) {
                    commonHobbies.push(group.name);
                    console.log(`✅ Gemeinsames Hobby gefunden: ${group.name}`);
                }
            });
            
            // Direkte Übereinstimmungen für nicht-kategorisierte Hobbys
            hobbies1.forEach(h1 => {
                hobbies2.forEach(h2 => {
                    if (h1 === h2 && h1.length > 3 && !commonHobbies.some(ch => h1.includes(ch.toLowerCase()))) {
                        commonHobbies.push(h1);
                        console.log(`✅ Direkte Übereinstimmung: ${h1}`);
                    }
                });
            });
            
            console.log(`🎯 Finale gemeinsame Hobbys: [${commonHobbies.join(', ')}]`);
            
            if (commonHobbies.length === 0) {
                return 'Verschiedene Hobbys - perfekt um neue Dinge voneinander zu lernen! 🌟';
            } else if (commonHobbies.length === 1) {
                return `Gemeinsames Hobby: ${commonHobbies[0]}! Das verbindet euch sofort 🎯`;
            } else if (commonHobbies.length <= 3) {
                return `${commonHobbies.length} gemeinsame Hobbys: ${commonHobbies.join(', ')}! Perfekte Basis für eure Freundschaft 🎨`;
            } else {
                return `Viele gemeinsame Hobbys: ${commonHobbies.slice(0, 3).join(', ')} und mehr! Ihr werdet zusammen viel Spaß haben 🎉`;
            }
        }

        function analyzeFriendshipValuesImproved(values1, values2) {
            const v1 = values1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const v2 = values2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            
            console.log(`💝 Verbesserte Freundschafts-Analyse: [${v1.join(', ')}] vs [${v2.join(', ')}]`);
            
            // Exakte Übereinstimmungen haben Priorität
            const exactMatches = v1.filter(val1 => 
                v2.some(val2 => val1 === val2)
            );
            
            if (exactMatches.length > 0) {
                if (exactMatches.length === 1) {
                    return `Gemeinsamer Wert: ${exactMatches[0]}! Das ist eine perfekte Basis für eure Freundschaft 💝`;
                } else {
                    return `${exactMatches.length} gemeinsame Werte: ${exactMatches.join(', ')}! Ihr passt wirklich gut zusammen 🤝`;
                }
            }
            
            // Ähnliche Werte
            const similarMatches = v1.filter(val1 => 
                v2.some(val2 => val1.includes(val2) || val2.includes(val1))
            );
            
            if (similarMatches.length > 0) {
                return `Ähnliche Werte: ${similarMatches[0]} - das ergänzt sich gut! 💫`;
            }
            
            // Ergänzende Werte
            const complementaryPairs = [
                ['ehrlichkeit', 'vertrauen'],
                ['humor', 'spaß'],
                ['treue', 'loyalität'],
                ['respekt', 'toleranz'],
                ['hilfsbereitschaft', 'unterstützung']
            ];
            
            for (const [val1, val2] of complementaryPairs) {
                if (v1.some(v => v.includes(val1)) && v2.some(v => v.includes(val2))) {
                    return `${val1} und ${val2} - das ergänzt sich perfekt! 🤝`;
                }
            }
            
            return 'Verschiedene Werte können Freundschaften bereichern! 🌟';
        }

        function analyzeTimeCompatibilityImproved(time1, time2) {
            const t1 = time1.toLowerCase();
            const t2 = time2.toLowerCase();
            
            console.log(`⏰ Zeit-Analyse: "${t1}" vs "${t2}"`);
            
            // Exakte Übereinstimmungen
            if (t1 === t2) {
                return `Identische Verfügbarkeit: ${time1}! ⏰`;
            }
            
            // Wochenende
            if (t1.includes('wochenende') && t2.includes('wochenende')) {
                return 'Beide am Wochenende verfügbar - perfekt für gemeinsame Aktivitäten! 📅';
            }
            
            // Abends
            if (t1.includes('abend') && t2.includes('abend')) {
                return 'Beide abends Zeit - ideal für entspannte Treffen! 🌆';
            }
            
            // Morgens/Vormittags
            if ((t1.includes('morgen') || t1.includes('vormittag')) && 
                (t2.includes('morgen') || t2.includes('vormittag'))) {
                return 'Beide Frühaufsteher - perfekt für Morgen-Aktivitäten! ☀️';
            }
            
            // Flexibilität erkennen
            if (t1.includes('flexibel') || t2.includes('flexibel') || 
                t1.includes('egal') || t2.includes('egal')) {
                return 'Einer von euch ist zeitlich flexibel - das macht Terminplanung einfach! ✨';
            }
            
            // Überschneidungen finden
            const overlap = findTimeOverlaps(t1, t2);
            if (overlap.length > 0) {
                return `Überschneidung bei: ${overlap.join(', ')} - ihr findet bestimmt gemeinsame Termine! ⏰`;
            }
            
            return 'Verschiedene Zeiten - aber Kompromisse machen Freundschaften stark! 💪';
        }

        function findTimeOverlaps(time1, time2) {
            const timeSlots = ['wochenende', 'samstag', 'sonntag', 'abend', 'morgen', 'vormittag', 'nachmittag'];
            return timeSlots.filter(slot => time1.includes(slot) && time2.includes(slot));
        }

        function analyzeTandemExpectations(expectation1, expectation2) {
            const e1 = expectation1.toLowerCase();
            const e2 = expectation2.toLowerCase();
            
            console.log(`🤝 Tandem-Erwartungen: "${e1}" vs "${e2}"`);
            
            // Deutsche Sprache
            if (e1.includes('deutsch') && e2.includes('deutsch')) {
                return 'Beide wollen Deutsch sprechen/lernen - perfektes Tandem! 🗣️';
            }
            
            // Stadt erkunden
            if ((e1.includes('stadt') || e1.includes('erkunden')) && 
                (e2.includes('stadt') || e2.includes('erkunden'))) {
                return 'Ihr wollt beide die Stadt erkunden - wird bestimmt spannend! 🗺️';
            }
            
            // Kochen
            if (e1.includes('kochen') && e2.includes('kochen')) {
                return 'Gemeinsam kochen - das verbindet und ist lecker! 🍳';
            }
            
            // Kultureller Austausch
            if ((e1.includes('kultur') || e1.includes('austausch')) && 
                (e2.includes('kultur') || e2.includes('austausch'))) {
                return 'Kultureller Austausch ist euch beiden wichtig - perfekte Voraussetzung! 🌍';
            }
            
            return 'Verschiedene Erwartungen können euer Tandem bereichern! ✨';
        }

        function analyzeTransportation(transport1, transport2) {
            const t1 = transport1.toLowerCase();
            const t2 = transport2.toLowerCase();
            
            // ÖPNV
            if (t1.includes('öpnv') && t2.includes('öpnv')) {
                return 'Beide mit ÖPNV unterwegs - umweltfreundlich und flexibel! 🚋';
            }
            
            // Auto
            if (t1.includes('auto') && t2.includes('auto')) {
                return 'Beide mit eigenem Auto - perfekt für Ausflüge! 🚗';
            }
            
            // Fahrrad
            if (t1.includes('fahrrad') && t2.includes('fahrrad')) {
                return 'Beide auf dem Fahrrad - gesund und sportlich! 🚲';
            }
            
            // Unterschiedliche Verkehrsmittel
            if (t1.includes('öpnv') && t2.includes('auto')) {
                return 'ÖPNV und Auto - ihr könnt flexibel entscheiden wie ihr euch trefft! 🚌🚗';
            }
            
            return 'Verschiedene Verkehrsmittel - ihr findet bestimmt einen Weg zueinander! 🛣️';
        }

        function analyzeContactMethods(contact1, contact2) {
            const c1 = contact1.toLowerCase();
            const c2 = contact2.toLowerCase();
            
            // Gemeinsame Kontaktmethoden
            const commonMethods = [];
            
            if (c1.includes('email') && c2.includes('email')) commonMethods.push('E-Mail');
            if (c1.includes('sms') && c2.includes('sms')) commonMethods.push('SMS');
            if (c1.includes('whatsapp') && c2.includes('whatsapp')) commonMethods.push('WhatsApp');
            if (c1.includes('telefon') && c2.includes('telefon')) commonMethods.push('Telefon');
            
            if (commonMethods.length > 0) {
                return `Kommunikation über ${commonMethods.join(' und ')} - perfekt! 📱`;
            }
            
            return 'Verschiedene Kontaktwege - ihr findet bestimmt einen gemeinsamen! 📞';
        }

        function analyzeHobbysIntelligently(answer1, answer2) {
            const hobbies1 = answer1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const hobbies2 = answer2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            
            console.log(`🎨 Hobby-Analyse: [${hobbies1.join(', ')}] vs [${hobbies2.join(', ')}]`);
            
            // Hobby-Synonyme für intelligente Erkennung
            const synonymGroups = [
                ['feiern', 'feiern gehen', 'party', 'ausgehen'],
                ['kino', 'ins kino gehen', 'filme schauen', 'film'],
                ['kochen', 'gemeinsam kochen', 'essen zubereiten'],
                ['museum', 'ins museum gehen', 'kultur', 'ausstellungen'],
                ['theater', 'ins theater gehen', 'schauspiel'],
                ['sport', 'fitness', 'training', 'bewegung'],
                ['musik', 'musikhören', 'konzerte'],
                ['lesen', 'bücher', 'literatur'],
                ['spazieren', 'wandern', 'natur', 'draußen sein']
            ];
            
            const commonHobbies = [];
            
            // Finde Übereinstimmungen durch Synonym-Gruppen
            synonymGroups.forEach(group => {
                const hobby1Matches = hobbies1.some(h => group.some(syn => h.includes(syn)));
                const hobby2Matches = hobbies2.some(h => group.some(syn => h.includes(syn)));
                
                if (hobby1Matches && hobby2Matches) {
                    commonHobbies.push(group[0]); // Hauptbegriff verwenden
                }
            });
            
            // Direkte Übereinstimmungen
            hobbies1.forEach(h1 => {
                hobbies2.forEach(h2 => {
                    if (h1 === h2 && !commonHobbies.includes(h1)) {
                        commonHobbies.push(h1);
                    }
                });
            });
            
            console.log(`🎯 Gemeinsame Hobbys gefunden: [${commonHobbies.join(', ')}]`);
            
            if (commonHobbies.length === 0) {
                return 'Verschiedene Hobbys - perfekt um neue Dinge auszuprobieren! 🌟';
            } else if (commonHobbies.length === 1) {
                return `Gemeinsames Hobby: ${commonHobbies[0]}! Das verbindet sofort 🎯`;
            } else if (commonHobbies.length <= 3) {
                return `${commonHobbies.length} gemeinsame Hobbys: ${commonHobbies.join(', ')}! Perfekte Basis 🎨`;
            } else {
                return `Viele gemeinsame Hobbys: ${commonHobbies.slice(0, 3).join(', ')} und mehr! Ihr werdet viel Spaß haben 🎉`;
            }
        }

        function analyzeFriendshipValuesIntelligently(values1, values2) {
            const v1 = values1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const v2 = values2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            
            console.log(`💝 Freundschafts-Analyse: [${v1.join(', ')}] vs [${v2.join(', ')}]`);
            
            // Suche nach gemeinsamen Werten
            const commonValues = v1.filter(val => 
                v2.some(val2 => val.includes(val2) || val2.includes(val) || val === val2)
            );
            
            if (commonValues.length > 0) {
                return `Gemeinsamer Wert: ${commonValues[0]}! Das ist eine starke Basis 💝`;
            }
            
            return 'Verschiedene Werte bereichern Freundschaften! 🤝';
        }

        function analyzeLanguagesIntelligently(lang1, lang2) {
            const l1 = lang1.toLowerCase();
            const l2 = lang2.toLowerCase();
            
            if (l1.includes('deutsch') && l2.includes('deutsch')) {
                return 'Ihr sprecht beide Deutsch - perfekt für die Kommunikation! 🗣️';
            }
            
            if (l1.includes('deutsch') || l2.includes('deutsch')) {
                return 'Perfekt für Deutsch-Praxis und kulturellen Austausch! 🌍';
            }
            
            return 'Verschiedene Sprachen - perfekt zum Voneinander-Lernen! 🌎';
        }

        function analyzeTimeCompatibility(time1, time2) {
            const t1 = time1.toLowerCase();
            const t2 = time2.toLowerCase();
            
            if (t1.includes('wochenende') && t2.includes('wochenende')) {
                return 'Beide am Wochenende verfügbar - perfekt! 📅';
            }
            
            if (t1.includes('abend') && t2.includes('abend')) {
                return 'Beide abends Zeit - ideal für Treffen! 🌆';
            }
            
            return 'Verschiedene Zeiten - aber Kompromisse sind möglich! ⏰';
        }        

        function cleanAnswer(answer) {
            if (!answer || typeof answer !== 'string') return '';
            
            const cleaned = answer.trim();
            
            // Erkenne "keine Antwort" Indikatoren
            const emptyIndicators = [
                '', 'keine angabe', 'nicht angegeben', 'k.a.', 'n/a',
                '---', 'leer', 'keine antwort', 'nicht beantwortet'
            ];
            
            if (emptyIndicators.includes(cleaned.toLowerCase())) {
                return '';
            }
            
            return cleaned;
        }

        function getNoAnswerText(question) {
            const q = question.toLowerCase();
            
            if (q.includes('hobby') || q.includes('interesse')) {
                return 'Perfekte Gelegenheit, eure Hobbys kennenzulernen! 🎯';
            }
            if (q.includes('sprache')) {
                return 'Sprachenaustausch wird spannend! 🗣️';
            }
            if (q.includes('beruf') || q.includes('arbeit')) {
                return 'Berufstalk beim ersten Treffen! 💼';
            }
            
            return 'Hier gibt\'s viel zu entdecken beim ersten Gespräch! ✨';
        }

        function getOneAnswerText(question, answererName, otherName, answer, isFirst) {
            const q = question.toLowerCase();
            
            // Spezielle Behandlung für verschiedene Fragetypen
            if (q.includes('hobby') || q.includes('interesse') || q.includes('freizeit')) {
                return `${answererName} kann ${otherName} ${answer} zeigen! 🎨`;
            }
            
            if (q.includes('sprache')) {
                return `${answererName} spricht ${answer} - perfekt zum Lernen für ${otherName}! 🌍`;
            }
            
            if (q.includes('beruf') || q.includes('arbeit') || q.includes('job')) {
                return `${answererName} arbeitet ${answer} - ${otherName} kann viel fragen! 💼`;
            }
            
            if (q.includes('wohnort') || q.includes('postleitzahl')) {
                return `${answererName} kennt sich in ${answer} aus - perfekter Tour-Guide! 📍`;
            }
            
            if (q.includes('zeit') || q.includes('treffen')) {
                return `${answererName} hat ${answer} Zeit - ihr findet bestimmt einen gemeinsamen Termin! ⏰`;
            }
            
            // Standard für einseitige Antworten
            return `${answererName} kann ${otherName} von ${answer} erzählen! 💬`;
        }

        function analyzeBothAnswers(question, name1, name2, answer1, answer2) {
            const q = question.toLowerCase();
            
            // Identische Antworten
            if (answer1.toLowerCase() === answer2.toLowerCase()) {
                return getExactMatchTextImproved(question, answer1);
            }

            // Ähnliche Antworten (erweiterte fuzzy matching)
            const similarity = calculateSimilarityImproved(answer1, answer2);
            if (similarity > 0.6) {
                return getSimilarMatchTextImproved(question, answer1, answer2, similarity);
            }

            // Spezifische Analysen nach Fragentyp
            if (q.includes('alter') || q.includes('geburt')) {
                return analyzeAgeCompatibilityImproved(answer1, answer2);
            }
            
            if (q.includes('hobby') || q.includes('freizeit') || q.includes('interesse')) {
                return analyzeHobbyCompatibilityImproved(answer1, answer2);
            }
            
            if (q.includes('sprache') || q.includes('sprichst')) {
                return analyzeLanguageCompatibilityImproved(answer1, answer2);
            }
            
            if (q.includes('postleitzahl') || q.includes('plz')) {
                return analyzePLZCompatibility(answer1, answer2);
            }
            
            if (q.includes('zeit') || q.includes('treffen') || q.includes('wann')) {
                return analyzeTimeCompatibilityImproved(answer1, answer2);
            }
            
            if (q.includes('wichtig') || q.includes('freundschaft')) {
                return analyzeFriendshipValues(answer1, answer2);
            }
            
            if (q.includes('altersunterschied')) {
                return analyzeAgePreferences(answer1, answer2);
            }
            if (q.includes('wichtig') || q.includes('freundschaft')) {
                return analyzeFriendshipValues(answer1, answer2);
            }            

            if (q.includes('anreisen') || q.includes('entfernung')) {
                return analyzeDistancePreferences(answer1, answer2);
            }

            // Standard für unterschiedliche Antworten
            return getDifferenceTextImproved(question, name1, name2, answer1, answer2);
        }

        function calculateSimilarityImproved(str1, str2) {
            const words1 = str1.toLowerCase().split(/[,;\s]+/).filter(w => w.length > 2);
            const words2 = str2.toLowerCase().split(/[,;\s]+/).filter(w => w.length > 2);
            
            let matches = 0;
            let totalWeight = 0;
            
            words1.forEach(word1 => {
                words2.forEach(word2 => {
                    if (word1 === word2) {
                        matches += 2; // Exakte Übereinstimmung
                    } else if (word1.includes(word2) || word2.includes(word1)) {
                        matches += 1; // Teilübereinstimmung
                    }
                    totalWeight += 2;
                });
            });
            
            return totalWeight > 0 ? matches / totalWeight : 0;
        }

        function analyzeAgeCompatibilityImproved(age1, age2) {
            const num1 = extractNumber(age1);
            const num2 = extractNumber(age2);
            
            if (num1 && num2) {
                const diff = Math.abs(num1 - num2);
                if (diff === 0) return 'Ihr seid genau gleich alt! 🎂';
                if (diff <= 3) return `Nur ${diff} Jahr${diff > 1 ? 'e' : ''} Unterschied - perfekt! 🎯`;
                if (diff <= 7) return `${diff} Jahre Unterschied - das passt gut zusammen 😊`;
                if (diff <= 12) return `Altersunterschied kann spannend sein (${diff} Jahre) ✨`;
                return 'Verschiedene Lebenserfahrungen zum Austauschen 🌟';
            }
            
            return 'Alter ist nur eine Zahl! 😊';
        }

        function analyzeHobbyCompatibilityImproved(answer1, answer2) {
            const hobbies1 = splitAndNormalize(answer1);
            const hobbies2 = splitAndNormalize(answer2);
            
            console.log(`🎨 Hobby-Analyse: "${hobbies1}" vs "${hobbies2}"`);
            
            // Erweiterte Hobby-Synonyme für besseres Matching
            const hobbyMappings = {
                'feiern': ['feiern gehen', 'ausgehen', 'party'],
                'kino': ['ins kino gehen', 'filme schauen', 'film'],
                'kochen': ['gemeinsam kochen', 'kulinarik', 'essen zubereiten'],
                'museum': ['ins museum gehen', 'kultur', 'ausstellungen'],
                'theater': ['ins theater gehen', 'schauspiel', 'bühne'],
                'sport': ['fitness', 'training', 'bewegung', 'fitnessstudio'],
                'musik': ['musikhören', 'konzerte', 'konzert'],
                'lesen': ['bücher', 'literatur', 'book'],
                'reisen': ['travel', 'urlaub', 'vacation']
            };
            
            // Finde intelligente Übereinstimmungen
            const commonHobbies = [];
            
            hobbies1.forEach(hobby1 => {
                hobbies2.forEach(hobby2 => {
                    // Exakte Übereinstimmung
                    if (hobby1.toLowerCase() === hobby2.toLowerCase()) {
                        if (!commonHobbies.includes(hobby1)) {
                            commonHobbies.push(hobby1);
                        }
                        return;
                    }
                    
                    // Synonym-Matching
                    for (const [mainHobby, synonyms] of Object.entries(hobbyMappings)) {
                        const hobby1IsMain = hobby1.toLowerCase().includes(mainHobby) || 
                                        synonyms.some(syn => hobby1.toLowerCase().includes(syn));
                        const hobby2IsMain = hobby2.toLowerCase().includes(mainHobby) || 
                                        synonyms.some(syn => hobby2.toLowerCase().includes(syn));
                        
                        if (hobby1IsMain && hobby2IsMain && !commonHobbies.includes(mainHobby)) {
                            commonHobbies.push(mainHobby);
                            return;
                        }
                    }
                    
                    // Teilstring-Matching für ähnliche Begriffe
                    if ((hobby1.length > 3 && hobby2.toLowerCase().includes(hobby1.toLowerCase())) || 
                        (hobby2.length > 3 && hobby1.toLowerCase().includes(hobby2.toLowerCase()))) {
                        const longerHobby = hobby1.length >= hobby2.length ? hobby1 : hobby2;
                        if (!commonHobbies.includes(longerHobby)) {
                            commonHobbies.push(longerHobby);
                        }
                    }
                });
            });
            
            // Generiere intelligenten Text
            if (commonHobbies.length > 0) {
                if (commonHobbies.length === 1) {
                    return `Gemeinsames Hobby: ${commonHobbies[0]}! Das verbindet sofort 🎯`;
                } else if (commonHobbies.length <= 3) {
                    return `${commonHobbies.length} gemeinsame Hobbys: ${commonHobbies.join(', ')}! Perfekte Basis 🎨`;
                } else {
                    return `Viele gemeinsame Hobbys: ${commonHobbies.slice(0, 3).join(', ')} und mehr! Ihr werdet viel Spaß haben 🎉`;
                }
            }
            
            // Standard für verschiedene Hobbys
            return 'Verschiedene Hobbys - perfekt um neue Dinge auszuprobieren! 🌟';
        }

        function splitAndNormalize(text) {
            if (!text) return [];
            return text.toLowerCase()
                .split(/[,;]/)
                .map(s => s.trim())
                .filter(s => s.length > 1);
        }

        function analyzeAgePreferences(pref1, pref2) {
            // Analysiere Präferenzen, nicht tatsächliches Alter
            const p1 = pref1.toLowerCase();
            const p2 = pref2.toLowerCase();
            
            if ((p1.includes('10') && p2.includes('10')) || 
                (p1.includes('egal') && p2.includes('egal'))) {
                return 'Ihr seid beide offen für verschiedene Altersgruppen! 🤗';
            }
            
            if (p1.includes('egal') || p2.includes('egal')) {
                return 'Einer ist sehr flexibel beim Alter - das passt! ✨';
            }
            
            return 'Eure Altersvorstellungen ergänzen sich gut 😊';
        }

        function analyzeLanguageCompatibilityImproved(lang1, lang2) {
            const l1 = lang1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 1);
            const l2 = lang2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 1);
            
            console.log(`🗣️ Sprachen-Analyse: "${l1}" vs "${l2}"`);
            
            // Suche nach gemeinsamen Sprachen
            const commonLanguages = l1.filter(lang => 
                l2.some(lang2 => 
                    lang.includes(lang2) || lang2.includes(lang) || 
                    (lang.includes('deutsch') && lang2.includes('deutsch'))
                )
            );
            
            if (commonLanguages.length > 0) {
                return `Gemeinsame Sprache: ${commonLanguages[0]}! Das erleichtert die Kommunikation 🗣️`;
            }
            
            // Prüfe auf Lern-Möglichkeiten
            if (l1.some(l => l.includes('deutsch')) && l2.some(l => !l.includes('deutsch'))) {
                return 'Perfekt für Deutsch-Praxis und kulturellen Austausch! 🌍';
            }
            
            if (l2.some(l => l.includes('deutsch')) && l1.some(l => !l.includes('deutsch'))) {
                return 'Tolle Gelegenheit für Sprachpraxis und neue Kulturen! 🌍';
            }
            
            return 'Verschiedene Sprachen - perfekt zum Voneinander-Lernen! 🌎';
        }

        function analyzePLZCompatibility(plz1, plz2) {
            const num1 = extractNumber(plz1);
            const num2 = extractNumber(plz2);
            
            if (num1 && num2) {
                if (num1 === num2) return 'Gleiche PLZ - ihr seid quasi Nachbarn! 🏠';
                
                const diff = Math.abs(num1 - num2);
                if (diff < 100) return 'Sehr nah beieinander - kurze Wege! 🚶‍♀️';
                if (diff < 1000) return 'Gute Erreichbarkeit mit ÖPNV! 🚋';
                if (diff < 10000) return 'Gleiche Region - das ist praktisch! 📍';
            }
            
            return 'Verschiedene Gegenden - könnt euch eure Kieze zeigen! 🗺️';
        }

        function analyzeFriendshipValues(values1, values2) {
            const v1 = values1.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            const v2 = values2.toLowerCase().split(/[,;]/).map(s => s.trim()).filter(s => s.length > 2);
            
            console.log(`💝 Freundschafts-Analyse: "${v1}" vs "${v2}"`);
            
            // Suche nach gemeinsamen Werten
            const commonValues = v1.filter(val => 
                v2.some(val2 => val.includes(val2) || val2.includes(val) || val === val2)
            );
            
            if (commonValues.length > 0) {
                const mainValue = commonValues[0];
                return `Gemeinsamer Wert: ${mainValue}! Das ist eine starke Basis 💝`;
            }
            
            // Prüfe auf ergänzende Werte
            const complementaryPairs = [
                ['ehrlichkeit', 'vertrauen'],
                ['humor', 'spaß'],
                ['treue', 'loyalität'],
                ['respekt', 'toleranz']
            ];
            
            for (const [val1, val2] of complementaryPairs) {
                if (v1.some(v => v.includes(val1)) && v2.some(v => v.includes(val2))) {
                    return `${val1} + ${val2} - das ergänzt sich perfekt! 🤝`;
                }
            }
            
            return 'Verschiedene Werte bereichern Freundschaften! 🌟';
        }

        function getDifferenceTextImproved(question, name1, name2, answer1, answer2) {
            const q = question.toLowerCase();
            
            // Spezifische Unterschieds-Texte
            if (q.includes('beruf') || q.includes('arbeit')) {
                return `${name1}: ${answer1} | ${name2}: ${answer2} - perfekt für neue Perspektiven! 💼`;
            }
            
            if (q.includes('studium') || q.includes('ausbildung')) {
                return 'Verschiedene Bildungswege - viel zu erzählen! 🎓';
            }
            
            if (q.includes('geboren') || q.includes('herkunft')) {
                return 'Verschiedene Hintergründe - perfekt für kulturellen Austausch! 🌍';
            }
            
            // Motivierende Standard-Texte
            const encouragingTexts = [
                'Unterschiede machen Freundschaften spannend! ✨',
                'Perfekt zum Voneinander-Lernen! 🤝', 
                'Verschiedene Perspektiven bereichern! 🌟',
                'Das wird sicher interessant! 💭',
                'Gegensätze können sich perfekt ergänzen! 😊'
            ];
            
            const index = (question.length + answer1.length + answer2.length) % encouragingTexts.length;
            return encouragingTexts[index];
        }

        function splitAndNormalize(text) {
            return text.toLowerCase()
                .split(/[,;]/)
                .map(s => s.trim())
                .filter(s => s.length > 1)
                .map(s => s.replace(/[^a-zäöüß\s]/g, '').trim());
        }

        function findCommonItems(arr1, arr2) {
            return arr1.filter(item => 
                arr2.some(item2 => 
                    item === item2 || 
                    item.includes(item2) || 
                    item2.includes(item)
                )
            );
        }

        function extractNumber(text) {
            const match = text.match(/\d+/);
            return match ? parseInt(match[0]) : null;
        }

        function analyzeDistancePreferences(dist1, dist2) {
            const d1 = dist1.toLowerCase();
            const d2 = dist2.toLowerCase();
            
            if (d1 === d2) {
                return `Identische Anreise-Vorstellungen: ${dist1}! 🎯`;
            }
            
            if ((d1.includes('stunde') && d2.includes('stunde')) ||
                (d1.includes('30') && d2.includes('30'))) {
                return 'Ähnliche Entfernungsvorstellungen - das passt! 🚋';
            }
            
            return 'Unterschiedliche Anreise-Präferenzen - Kompromisse sind möglich! 🗺️';
        }

        function getExactMatchTextImproved(question, answer) {
            const q = question.toLowerCase();
            const a = answer.toLowerCase();
            
            if (q.includes('hobby') || q.includes('interesse')) {
                return `Gemeinsames Interesse: ${answer}! Das verbindet 🎯`;
            }
            if (q.includes('sprache')) {
                return `Perfekt - ihr sprecht beide: ${answer}! 🗣️`;
            }
            if (q.includes('studium') && a.includes('ja')) {
                return 'Ihr habt beide studiert - akademischer Austausch! 🎓';
            }
            if (a.includes('ja') || a.includes('gerne')) {
                return `Ihr seid euch einig: ${answer}! ✨`;
            }
            
            return `Identisch: ${answer} - das passt perfekt! 😊`;
        }

        function getSimilarMatchTextImproved(question, answer1, answer2, similarity) {
            const q = question.toLowerCase();
            const simPercent = Math.round(similarity * 100);
            
            if (q.includes('hobby')) {
                return `${simPercent}% Übereinstimmung bei Hobbys - perfekte Mischung! 🎨`;
            }
            if (q.includes('sprache')) {
                return 'Ähnliche Sprachkenntnisse - könnt euch super helfen! 🌍';
            }
            
            return `Das passt gut zusammen (${simPercent}% ähnlich)! 😊`;
        }

        function debugQuestionSimilarity() {
            const allQuestions = new Set();
            profiles.forEach(profile => {
                profile.fields.forEach(field => {
                    allQuestions.add(field.question);
                });
            });
            
            const questionGroups = findSimilarQuestions(Array.from(allQuestions));
            const duplicateGroups = questionGroups.filter(group => group.length > 1);
            
            console.log('🔍 === FRAGEN-ÄHNLICHKEITS-ANALYSE ===');
            console.log(`📊 Gesamt: ${allQuestions.size} Fragen`);
            console.log(`🔄 Gruppen mit Duplikaten: ${duplicateGroups.length}`);
            
            duplicateGroups.forEach((group, index) => {
                console.log(`\n📝 Gruppe ${index + 1}:`);
                group.forEach(q => {
                    const count = profiles.reduce((count, profile) => 
                        count + (profile.fields.some(f => f.question === q) ? 1 : 0), 0
                    );
                    console.log(`  - "${q}" (${count} Profile)`);
                });
            });
            
            showNotification(`🔍 Fragen-Analyse: ${duplicateGroups.length} Duplikat-Gruppen gefunden`, 'info', 5000);
        }

        // ===============================
        // RÜCKWIRKENDE DATEN-BEREINIGUNG
        // ===============================

        function migrateExistingProfiles() {
            if (profiles.length === 0) {
                showNotification('❌ Keine Profile zum Migrieren vorhanden', 'warning');
                return;
            }

            if (!confirm(`🔄 Rückwirkende Fragen-Bereinigung für ${profiles.length} Profile durchführen?\n\nDies wird:\n- Ähnliche Fragen zusammenführen\n- Duplikate bereinigen\n- Tandems aktualisieren\n\nEmpfohlen: Erstelle vorher ein Backup!`)) {
                return;
            }

            console.log('🚀 Starte Migration der bestehenden Profile...');
            
            let totalChanges = 0;
            let profilesChanged = 0;

            // 1. Profile bereinigen
            profiles.forEach((profile, profileIndex) => {
                console.log(`📋 Migriere Profil ${profileIndex + 1}/${profiles.length}: ${profile.name}`);
                
                const originalFieldCount = profile.fields.length;
                const cleanedFields = cleanupProfileFields(profile.fields);
                
                if (cleanedFields.length !== originalFieldCount) {
                    console.log(`  ✅ ${originalFieldCount} → ${cleanedFields.length} Felder (${originalFieldCount - cleanedFields.length} Duplikate entfernt)`);
                    profile.fields = cleanedFields;
                    totalChanges += (originalFieldCount - cleanedFields.length);
                    profilesChanged++;
                } else {
                    console.log(`  ℹ️ Keine Änderungen nötig`);
                }
            });

            // 2. Tandems aktualisieren
            let tandemsUpdated = 0;
            tandems.forEach((tandem, tandemIndex) => {
                console.log(`🤝 Aktualisiere Tandem ${tandemIndex + 1}/${tandems.length}: ${tandem.name}`);
                
                const updatedCommonalities = updateTandemCommonalities(tandem);
                
                if (updatedCommonalities.length !== tandem.commonalities.length) {
                    tandem.commonalities = updatedCommonalities;
                    tandemsUpdated++;
                    console.log(`  ✅ Gemeinsamkeiten aktualisiert`);
                }
            });

            // 3. Speichern
            saveProfiles();
            saveTandems();

            // 4. UI aktualisieren
            updateUI();
            
            // 5. Ergebnis anzeigen
            const summary = `🎉 Migration abgeschlossen!\n\n📊 Ergebnisse:\n- ${profilesChanged} von ${profiles.length} Profilen bereinigt\n- ${totalChanges} Duplikat-Felder entfernt\n- ${tandemsUpdated} Tandems aktualisiert\n\n💾 Alle Änderungen wurden gespeichert.`;
            
            console.log('✅ Migration erfolgreich abgeschlossen');
            showNotification('✅ Rückwirkende Bereinigung erfolgreich!', 'success', 5000);
            alert(summary);
        }

        function cleanupProfileFields(fields) {
            console.log(`    🔍 Bereinige ${fields.length} Felder...`);
            
            // 1. Erstelle Mapping: normalisierte Frage → beste Original-Frage + alle Antworten
            const questionGroups = new Map();
            
            fields.forEach(field => {
                const normalizedQ = normalizeQuestion(field.question);
                
                if (!questionGroups.has(normalizedQ)) {
                    questionGroups.set(normalizedQ, {
                        originalQuestions: [],
                        answers: [],
                        bestQuestion: field.question
                    });
                }
                
                const group = questionGroups.get(normalizedQ);
                group.originalQuestions.push(field.question);
                group.answers.push(field.answer);
                
                // Wähle die beste Frage (kürzeste, häufigste, oder klarste)
                if (field.question.length < group.bestQuestion.length || 
                    field.question.split(' ').length < group.bestQuestion.split(' ').length) {
                    group.bestQuestion = field.question;
                }
            });

            // 2. Erstelle bereinigte Felder
            const cleanedFields = [];
            
            questionGroups.forEach((group, normalizedQ) => {
                if (group.originalQuestions.length > 1) {
                    console.log(`      🔄 Zusammenführung: ${group.originalQuestions.length} Variationen von "${normalizedQ}"`);
                    console.log(`        → Beste Frage: "${group.bestQuestion}"`);
                    group.originalQuestions.forEach(q => console.log(`        - "${q}"`));
                }
                
                // Wähle die beste Antwort (längste, vollständigste)
                const bestAnswer = group.answers.reduce((best, current) => {
                    if (!best) return current;
                    if (!current) return best;
                    
                    // Längere Antwort bevorzugen, außer wenn sie nur Wiederholungen sind
                    const cleanCurrent = cleanProfileAnswer(current);
                    const cleanBest = cleanProfileAnswer(best);
                    
                    if (cleanCurrent.length > cleanBest.length) return current;
                    return best;
                });
                
                if (bestAnswer && bestAnswer.trim()) {
                    cleanedFields.push({
                        question: group.bestQuestion,
                        answer: bestAnswer
                    });
                }
            });

            console.log(`    ✅ ${fields.length} → ${cleanedFields.length} Felder (${fields.length - cleanedFields.length} Duplikate entfernt)`);
            return cleanedFields;
        }

        function updateTandemCommonalities(tandem) {
            console.log(`    🔍 Aktualisiere Gemeinsamkeiten für "${tandem.name}"`);
            
            // Neu berechnen basierend auf den bereinigten Profildaten
            const profile1 = profiles.find(p => p.id === tandem.profile1.id);
            const profile2 = profiles.find(p => p.id === tandem.profile2.id);
            
            if (!profile1 || !profile2) {
                console.log(`    ⚠️ Profile nicht gefunden - überspringe`);
                return tandem.commonalities;
            }
            
            // Aktualisiere Profile-Referenzen im Tandem
            tandem.profile1 = profile1;
            tandem.profile2 = profile2;
            
            // Berechne Gemeinsamkeiten neu
            const newCommonalities = findCommonalities(profile1, profile2);
            
            console.log(`    ✅ ${tandem.commonalities.length} → ${newCommonalities.length} Gemeinsamkeiten`);
            return newCommonalities;
        }

        function createDataBackup() {
            const backup = {
                profiles: JSON.parse(JSON.stringify(profiles)),
                tandems: JSON.parse(JSON.stringify(tandems)),
                selectedFields: JSON.parse(JSON.stringify(selectedFields)),
                timestamp: new Date().toISOString(),
                version: '2.0-pre-migration'
            };
            
            const filename = `SwaF_Backup_Pre_Migration_${new Date().toISOString().split('T')[0]}.json`;
            downloadFile(JSON.stringify(backup, null, 2), filename, 'application/json');
            
            showNotification('💾 Backup erstellt!', 'success', 3000);
        }

        function analyzeCurrentData() {
            if (profiles.length === 0) {
                showNotification('❌ Keine Profile zum Analysieren', 'warning');
                return;
            }
            
            console.log('🔍 === DATEN-ANALYSE VOR MIGRATION ===');
            
            // Sammle alle Fragen
            const allQuestions = new Set();
            let totalFields = 0;
            
            profiles.forEach(profile => {
                totalFields += profile.fields.length;
                profile.fields.forEach(field => {
                    allQuestions.add(field.question);
                });
            });
            
            // Finde Duplikate
            const questionGroups = findSimilarQuestions(Array.from(allQuestions));
            const duplicateGroups = questionGroups.filter(group => group.length > 1);
            
            let potentialSavings = 0;
            duplicateGroups.forEach(group => {
                potentialSavings += (group.length - 1);
            });
            
            const analysis = `📊 Aktuelle Daten-Analyse:

        📋 Profile: ${profiles.length}
        📝 Gesamt Felder: ${totalFields}
        ❓ Einzigartige Fragen: ${allQuestions.size}
        🔄 Duplikat-Gruppen: ${duplicateGroups.length}
        💾 Potentielle Einsparungen: ${potentialSavings} Duplikat-Felder

        🔍 Größte Duplikat-Gruppen:`;

            console.log(analysis);
            
            // Zeige größte Duplikat-Gruppen
            duplicateGroups
                .sort((a, b) => b.length - a.length)
                .slice(0, 5)
                .forEach((group, index) => {
                    console.log(`\n${index + 1}. ${group.length} Variationen:`);
                    group.forEach(q => console.log(`   - "${q}"`));
                });
            
            alert(analysis + '\n\nDetails siehe Browser-Konsole.');
        }

        function testIntelligentMatching() {
            console.log('🧪 === INTELLIGENTE MATCHING TESTS ===');
            
            const testCases = [
                { q: 'Vorname', a1: 'Max', a2: 'Anna', expected: 'Sollte leer bleiben' },
                { q: 'Hobbys', a1: 'Fußball, Lesen', a2: 'Sport, Bücher', expected: 'Sollte Gemeinsamkeiten finden' },
                { q: 'ID', a1: '12345', a2: '67890', expected: 'Sollte ausgeschlossen werden' },
                { q: 'Status', a1: 'aktiv', a2: 'aktiv', expected: 'Sollte als sinnlos erkannt werden' }
            ];
            
            testCases.forEach((test, index) => {
                console.log(`\n${index + 1}. Test: "${test.q}"`);
                console.log(`   Input: "${test.a1}" vs "${test.a2}"`);
                console.log(`   Erwarte: ${test.expected}`);
                
                const excluded = shouldExcludeFromMatching(test.q);
                const meaningless = isMeaninglessComparison(test.a1, test.a2, test.q);
                const intelligentText = generateIntelligentText(test.q, test.a1, test.a2);
                
                console.log(`   → Ausgeschlossen: ${excluded}`);
                console.log(`   → Sinnlos: ${meaningless}`);
                console.log(`   → Generierter Text: "${intelligentText}"`);
            });
            
            showNotification('🧪 Intelligente Matching Tests in Konsole ausgegeben', 'info', 4000);
        }

        // Globale Funktion verfügbar machen
        window.testIntelligentMatching = testIntelligentMatching;

        function testNameExtraction() {
            const testNames = [
                'Aufnahmegespräch Einwander*innen (Sara Pooramin)',
                'Aufnahmegespräch Locals (Nekhat Hasrat-Nazimi)', 
                'Sara Mustermann',
                'Interview mit Max',
                'Gespräch Teilnehmer (Anna Schmidt)'
            ];
            
            console.log('👤 === NAMEN-EXTRAKTION TESTS ===');
            testNames.forEach(name => {
                const extracted = extractFirstName(name);
                console.log(`"${name}" → "${extracted}"`);
            });
            
            showNotification('👤 Namen-Tests in Konsole ausgegeben', 'info', 3000);
        }

        window.testNameExtraction = testNameExtraction;        
    </script>
            <!-- Leaflet JS für Karten -->
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
                integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
                crossorigin=""></script>
</body>

</html>


